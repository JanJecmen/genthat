
toStringLiteral <- function (str) {
    concatVec(deparse(str))
}

listToArgumentList <- function(args) {
    elems <- c()
    argNames <- names(args)
    for (i in seq(along.with = args)) {
        src <- if (length(argNames) != 0 && argNames[[i]] != "") {
            concat(argNames[i], " = ", args[[i]])
        } else {
            args[[i]]
        }
        elems <- c(elems, src) 
    }
    concatVec(elems, sep=", ")
}

#' @title Test Case generator based on capture files
#'
#' @description This function works with the trace information generated by instrumented GNU-R.
#'
#' It is strictly oriented to that, please see readme for more information.
#'
#' @param root a directory containg capture information or capture file
#' @param output_dir directory where generated test cases will be saved
#' @param verbose wheater display debug output
#' @param timed whether result is dependent on time of generation
test_gen <- function(root, output_dir, timed = F, verbose=testr_options("verbose")) {
  if (verbose) {
    cat("Output:", output_dir, "\n")
    cat("Root:", root, "\n")
  }
  # input dir checks
  if (missing(root) || !file.exists(root)) {
    stop("Input dir/file doesn't exist!")
  }
  if (file.info(root)$isdir){
    all.capture <- lapply(list.files(root, recursive=TRUE, all.files = TRUE), function(x) file.path(root,x))
  } else {
    all.capture <- root
  }
  # output dir checks
  if (missing(output_dir)) stop("A output directory must be provided!");
  if (!file.exists(output_dir) || !file.info(output_dir)$isdir) dir.create(output_dir)
  if (timed)
    output_dir <- file.path(output_dir, format(Sys.time(), "%Y-%m-%d %H:%M:%S"))
  cache$output_dir <- output_dir
  # bad.arguments file to store incorrect arguments
  cache$bad_argv <- file.path(cache$output_dir, "bad_arguments");
  if (!file.exists(cache$bad_argv)
      && !file.create(cache$bad_argv))
      stop("Unable to create file: ", cache$bad_argv)
  cache$tid <- list()
  Map(function(x) { process_capture(x) }, all.capture)
  cache$tid <- NULL
  cache$output_dir <- NULL
  cache$bad_argv <- NULL
}

#' @title Manage Test Case file
#'
#' @description This function creates a test case file if one does not exist already
#' @param name directory where generated test cases will be saved
#' @seealso test_gen
ensure_file <- function(name) {

    fname <- gsub(.Platform$file.sep, "sep", name)
    # replace ::: with ___ so that we work on Windows too
    fname <- gsub(":::", "___", fname)
    # check if the folder for the function exists and create it if not
    tc.folder = file.path(cache$output_dir, fname, fsep = .Platform$file.sep)
    dir.create(tc.folder, showWarnings = FALSE)
    # get the index of the file, based on number of files in the folder (but use the cache information for it)
    cache$tid[[name]] <- ifelse(is.null(cache$tid[[name]]), -1, cache$tid[[name]] + 1)
    tc.file = file.path(tc.folder, paste("test-", cache$tid[[name]], ".R", sep=""), fsep = .Platform$file.sep)
    # the file should not exist
    if (!file.create(tc.file))
        stop("Unable to create file: ", tc.file)
    # TODO perhaps this is not needed for testthat
    write("library(testthat)", file = tc.file, append = TRUE)
    write("library(testr)", file = tc.file, append = TRUE)
    write("", file = tc.file, append = TRUE)
    # write context information (the function name)
    write(paste("context(\"",name,"\")\n", sep=""), file = tc.file, append = TRUE)
    return(tc.file)
}

#' @title Process File with Closure capture information
#'
#' @description This function parses file with closure capture information and generates test cases
#' @param cap_file path to closure capture file
process_capture <- function(cap_file){
  lines <- readLines(cap_file)
  cache$i <- 1
  pkgName <- read_value(lines, kPkgPrefix)
  while (cache$i < length(lines)) {
    # read test case information
    func <- read_value(lines, kFuncPrefix)
    args <- read_value(lines, kArgsPrefix)
    retv <- read_value(lines, kRetvPrefix)

    if (args != "<unserializable>") {
        feedback <- generate_tc(pkgName, func, args, retv)

        #### see what we get
        if (feedback$type == "err") {
          print("...ERROR TEST")
          print(paste0("CAUSE: ", feedback$err_type))
          # the captured information is not usable
          write(feedback$msg, file=cache$bad_argv, append=TRUE);
        } else if (feedback$type == "src") {
          print("...VALID TEST")
          #### good, we get the source code
          tc.file <- ensure_file(func)
          write(feedback$msg, file=tc.file, append=TRUE);
        } else {
          stop("Unexpected generate_tc() return value!");
        }
    }
  }
}

read_value <- function(lines, prefix){
  value <- vector()
  j <- cache$i
  while (TRUE) {
    if (identical(lines[j], "")) {
      j <- j + 1
      next
    } else if (starts_with(prefix, lines[j])) {
      value <- c(value, strip_prefix(prefix, lines[j]))
      j <- j + 1
    } else {
      break
    }
  }
  cache$i <- j
  paste(value, collapse="\n", sep="")
}

#' @title Generates a testcase for closure function
#'
#' @description This function generates a test case for builtin function using supplied arguments. All elements should be given as text.
#' @param func function name
#' @param argv input arguments for a closure function call
#' @seealso test_gen ProcessClosure
generate_tc <- function(pkgName, func, argv, retv) {
  # check validity of arguments
  valid.argv <- tryCatch(deserialize(argv), error = function(e) "GENTHAT_UNPARSEABLE")
  valid.retv <- tryCatch(deserialize(retv), error = function(e) "GENTHAT_UNPARSEABLE")

  # proper arguments should always be packed in a list
  if (identical(valid.argv, "GENTHAT_UNPARSEABLE") || identical(valid.retv, "GENTHAT_UNPARSEABLE")) {
      list(
          type = "err",
          err_type = "UNPARSEABLE",
          msg = paste(
            paste0("cause: ", "UNPARSEABLE"),
            paste0("func: ", func),
            paste0("argv: ", argv),
            paste0("retv: ", retv),
            "\n",
            sep = "\n"
          )
      )
  } else {
      cache$warns <- NULL
      cache$errs <- NULL

      fn <- eval(parse(text=func))
      call <- as.call(if (0 == length(valid.argv)) list(fn) else append(fn, valid.argv))

	  new.retv <- withCallingHandlers(
                    tryCatch(
                        eval(call, envir = getNamespace(pkgName)),
                        error = function(e) cache$errs <- e$message
                    ),
                    warning=function(w) {
                        cache$warns <- ifelse(is.null(cache$warns), w$message, paste(cache$warns, w$message, sep="; "))
                        invokeRestart("muffleWarning")
                    }
              )

      if (is.null(cache$errs) && !identical(valid.retv, new.retv)) {
          print(valid.retv)
          print(new.retv)
          list(
              type = "err",
              err_type = "RETV_MISMATCH",
              msg = paste(
                paste0("cause: ", "RETV_MISMATCH"),
                paste0("func: ", func),
                paste0("argv: ", argv),
                paste0("retv: ", retv),
                paste0("computed.retv: ", serialize(new.retv)),
                "\n",
                sep = "\n"
             )
          )
      } else {
          argSources <- Map(function(arg) { concat("deserialize(", toStringLiteral(serialize(arg)), ")") }, valid.argv)
          callSource <- concat(func, "(", listToArgumentList(argSources), ")")

          if (!is.null(cache$errs)) {
              test_body <- paste(
                "\texpect_error({\n",
                "\t", callSource, "}\n,",
                "\t", deparse(cache$errs), ")\n"
              )
          } else {
              test_body <- concat(
                  "\texpected <- deserialize(", toStringLiteral(serialize(quoter(new.retv))), ")\n",
                  "\texpect_equal(", callSource, ", expected)\n"
              )
          }

          warningChecks <- if (!is.null(cache$warns) && length(cache$warns) > 0) paste("\texpect_warning(", callSource, ", ", deparse(cache$warns), ")\n", sep="") else ""

          src <- concat(
            "test_that(", deparse(func), ", {\n",
            test_body,
            warningChecks,
            "})"
          )

          list(
            type = "src",
            msg = src
          )
      }
  }
}
