
toStringLiteral <- function (str) {
    concatVec(deparse(str))
}

listToArgumentList <- function(args) {
    elems <- c()
    argNames <- names(args)
    for (i in seq(along.with = args)) {
        src <- if (length(argNames) != 0 && argNames[[i]] != "") {
            concat(argNames[i], " = ", args[[i]])
        } else {
            args[[i]]
        }
        elems <- c(elems, src) 
    }
    concatVec(elems, sep=", ")
}

#' @title Test Case generator based on capture files
#'
#' @description This function works with the trace information generated by instrumented GNU-R.
#'
#' It is strictly oriented to that, please see readme for more information.
#'
#' @param root a directory containg capture information or capture file
#' @param output_dir directory where generated test cases will be saved
#' @param verbose wheater display debug output
#' @param timed whether result is dependent on time of generation
test_gen <- function(root, output_dir, timed = F, verbose=testr_options("verbose")) {
  if (verbose) {
    cat("Output:", output_dir, "\n")
    cat("Root:", root, "\n")
  }
  # input dir checks
  if (missing(root) || !file.exists(root)) {
    stop("Input dir/file doesn't exist!")
  }
  if (file.info(root)$isdir){
    all.capture <- lapply(list.files(root, recursive=TRUE, all.files = TRUE), function(x) file.path(root,x))
  } else {
    all.capture <- root
  }
  # output dir checks
  if (missing(output_dir)) stop("A output directory must be provided!");
  if (!file.exists(output_dir) || !file.info(output_dir)$isdir) dir.create(output_dir)
  if (timed)
    output_dir <- file.path(output_dir, format(Sys.time(), "%Y-%m-%d %H:%M:%S"))
  cache$output_dir <- output_dir
  # bad.arguments file to store incorrect arguments
  cache$bad_argv <- file.path(cache$output_dir, "bad_arguments");
  if (!file.exists(cache$bad_argv)
      && !file.create(cache$bad_argv))
      stop("Unable to create file: ", cache$bad_argv)
  cache$tid <- list()
  Map(function(x) { process_capture(x) }, all.capture)
  cache$tid <- NULL
  cache$output_dir <- NULL
  cache$bad_argv <- NULL
}

#' @title Manage Test Case file
#'
#' @description This function creates a test case file if one does not exist already
#' @param name directory where generated test cases will be saved
#' @seealso test_gen
ensure_file <- function(name) {

    fname <- gsub(.Platform$file.sep, "sep", name)
    # replace ::: with ___ so that we work on Windows too
    fname <- gsub(":::", "___", fname)
    # check if the folder for the function exists and create it if not
    tc.folder = file.path(cache$output_dir, fname, fsep = .Platform$file.sep)
    dir.create(tc.folder, showWarnings = FALSE)
    # get the index of the file, based on number of files in the folder (but use the cache information for it)
    cache$tid[[name]] <- ifelse(is.null(cache$tid[[name]]), -1, cache$tid[[name]] + 1)
    tc.file = file.path(tc.folder, paste("test-", cache$tid[[name]], ".R", sep=""), fsep = .Platform$file.sep)
    # the file should not exist
    if (!file.create(tc.file))
        stop("Unable to create file: ", tc.file)
    # TODO perhaps this is not needed for testthat
    write("library(testthat)", file = tc.file, append = TRUE)
    write("library(testr)", file = tc.file, append = TRUE)
    write("", file = tc.file, append = TRUE)
    # write context information (the function name)
    write(paste("context(\"",name,"\")\n", sep=""), file = tc.file, append = TRUE)
    return(tc.file)
}

#' @title Process File with Closure capture information
#'
#' @description This function parses file with closure capture information and generates test cases
#' @param cap_file path to closure capture file
process_capture <- function(cap_file){
  lines <- readLines(cap_file)
  cache$i <- 1
  while (cache$i < length(lines)){
    # read test case information
    symbol.values <- read_symbol_values(lines)
    symb <- symbol.values[[1]]
    vsym <- symbol.values[[2]]
    func <- read_value(lines, kFuncPrefix)
    args <- read_value(lines, kArgsPrefix)
    retv <- read_value(lines, kRetvPrefix)

    if (args != "<unserializable>") {
        feedback <- generate_tc(symb, vsym, func, args, retv)

        #### see what we get
        if (feedback$type == "err") {
          print("...ERROR TEST")
          print(paste0("CAUSE: ", feedback$err_type))
          # the captured information is not usable
          write(feedback$msg, file=cache$bad_argv, append=TRUE);
        } else if (feedback$type == "src") {
          print("...VALID TEST")
          #### good, we get the source code
          tc.file <- ensure_file(func)
          write(feedback$msg, file=tc.file, append=TRUE);
        } else {
          stop("Unexpected generate_tc() return value!");
        }
    }

    cache$i <- cache$i + 1
  }
}


read_symbol_values <- function(lines){
  k_sym <- 1
  k_value <- 1
  symb <- vector()
  vsym <- vector()
  symb[k_sym] <- ""
  vsym[k_value] <- ""
  while (starts_with(kSymbPrefix, lines[cache$i])){
    symb[k_sym] <- paste(symb[k_sym], substr_line(lines[cache$i]), sep = "")
    cache$i <- cache$i + 1
    k_sym <- k_sym + 1
    symb[k_sym] <- ""
    vsym[k_value] <- read_value(lines, kValSPrefix)
    k_value <- k_value + 1
    vsym[k_value] <- ""
  }
  length(symb) <- length(symb) - 1
  length(vsym) <- length(vsym) - 1
  return(list(symb, vsym))
}

read_value <- function(lines, prefix){
  value <- vector()
  j <- cache$i
  while (starts_with(prefix, lines[j])){
    value <- c(value, substr_line(lines[j]))
    j <- j + 1
  }
  cache$i <- j
  return(paste(value, collapse="\n", sep=""))
}

#' @title Generates a testcase for closure function
#'
#' @description This function generates a test case for builtin function using supplied arguments. All elements should be given as text.
#' @param symb symbols to be initialized before the call
#' @param vsym values of the symbols
#' @param func function name
#' @param argv input arguments for a closure function call
#' @seealso test_gen ProcessClosure
generate_tc <- function(symb, vsym, func, argv, retv) {

  # DOESN'T SEEM TO BE USED ANYMORE
  # check validity of symbol values and construct part of the test
  # invalid.symbols <- vector()
  # variables <- ""
  # if (length(symb) > 0 && symb[1] != ""){
  #   for (i in 1:length(vsym)){
  #     symbol <- paste(symb[i], "<-", vsym[i])
  #     if (!parse_eval(symbol)){
  #       invalid.symbols <- c(invalid.symbols, i)
  #     } else {
  #       variables <- paste(variables, symbol, "\n")
  #     }
  #   }
  #   if (length(invalid.symbols) != 0){
  #     symb <- symb[-invalid.symbols]
  #     vsym <- vsym[-invalid.symbols]
  #   }
  # }

  # check validity of arguments
  valid.argv <- tryCatch(deserialize(argv), error = function(e) "GENTHAT_UNPARSEABLE")
  valid.retv <- tryCatch(deserialize(retv), error = function(e) "GENTHAT_UNPARSEABLE")

  # proper argument should always be packed in a list
  if (identical(valid.argv, "GENTHAT_UNPARSEABLE") || identical(valid.retv, "GENTHAT_UNPARSEABLE")) {
      list(
          type = "err",
          err_type = "UNPARSEABLE",
          msg = concat("func:", func, "\nargv:", argv, "\nretv:", retv, "\n")
      )
  } else {
      cache$warns <- NULL
      cache$errs <- NULL

      fn <- eval(parse(text=func))
      call <- as.call(append(fn, valid.argv))

      #retv <- withCallingHandlers(
      #    eval(call), 
      #    error=function(e) {
      #       cache$errs <- e$message
      #    },
      #    warning=function(w) {
      #        cache$warns <- ifelse(is.null(cache$warns), w$message, paste(cache$warns, w$message, sep="; "))
      #        invokeRestart("muffleWarning")
      #    },
      #    silent = TRUE
      #)

	  new.retv <- withCallingHandlers(
                    tryCatch(
                        eval(call, envir = getNamespace("ggplot2")),
                        error=function(e) cache$errs <- e$message,
                        silent = TRUE # what is this?
                    ),
                    warning=function(w) {
                         cache$warns <- ifelse(is.null(cache$warns), w$message, paste(cache$warns, w$message, sep="; "))
                         invokeRestart("muffleWarning")
                    }
              )

      if (!identical(valid.retv, new.retv)) {
          print(valid.retv)
          print(new.retv)
          list(
              type = "err",
              err_type = "RETV_MISMATCH",
              msg = concat("func:", func, "\nargv:", argv, "\nretv:", retv, "\ncomputed.retv:", serialize(new.retv), "\n")
          )
      } else {
          argSources <- Map(function(arg) { concat("deserialize(", toStringLiteral(serialize(arg)), ")") }, valid.argv)
          callSource <- concat(func, "(", listToArgumentList(argSources), ")")

          if (!is.null(cache$errs)) {
              test_body <- paste("expect_error({\n", callSource, "}\n,", deparse(cache$errs), ")\n")
          } else {
              test_body <- concat(
                  "\texpected <- deserialize(", toStringLiteral(serialize(quoter(new.retv))), ")\n",
                  "\texpect_equal(", callSource, ", expected)\n"
              )
          }

          warningChecks <- paste("\texpect_warning(", callSource, ", ", deparse(cache$warns), ")\n", sep="")

          src <- concat(
            "test_that(", deparse(func), ", {\n",
            test_body,
            warningChecks,
            "})"
          )

          list(
            type = "src",
            msg = src
          )
      }
  }
}
