testR test specification
========================

Each test consists of an optional name, commands and code. The commands are either generics (commands to make the same code for different values), conditions (commands that are executed before executing the test on a target that may select the test not to be executed) and checks (commands executed after the test has been ran on the target that may analyze its output). There are predefined commands, and custom commands which can be extended by a supplied R code for better flexibility. 

Generics
--------

A generic is either independent, or dependent. Dependent generic is changed when its master generic (specified by dependsOn argument) is changed. The tests produced are all permutations of values of the independent generics. The order of definition of the generics matters as the generic defined last flips most often. The values of the generics should be independent of any other other generics. For general examples, this is assumed and no substitution is performed (or even evaluation). However, if the user decides to override the generic instantiation process, this can be changed so that any independent generic can see values of previously defined independent generics and any dependent generic can see all independent generics and dependent generics defined above. 

Substitution
------------

In code and in any checks and conditions, the values of the generics are substituted for their actual values. Both the original value and the generic value can be in different formats (R code or a string). Depending on the types of those, a different substitution method is used:

Original | Generic | Substitution used
--------------------------------------
code     | code    | AST of the generic is replaced with the AST of the generic value
code     | string  | AST of the generic is replaced with the character literal corresponding to the value of the generic
string   | code    | occurence of the generic is replaced with deparse of the generic AST
string   | string  | occurence of the generic is replaced with the generic value W/o the quotes

Based on the source format, different means are used to identify the generics' placeholders. In code, either a variable corresponding to the generic name is replaced with the value itself, or a %genericName% can be used if the generic holds operators. In this case, whatever the value of the generic is, as.name() conversion is applied to it so that the AST will hold. 

If replacing in a string, a generic name prefixed with single % will be replaced with the generic value. %% can be used to escape a % character. Also, if % is followed by a non-generic name the % will stay. 

General & Custom generics
-------------------------

General generic is such a generic, that is defined by N R expressions, or string literals, where N is the length of the generic. The generic values are the R expressions themselves. Such a generic is instantiated by the generic command, or its shorthand g:

g(name, dependsOn = NULL, ...) # where ... are the values and dependsOn if present indicates a dependent generic. 

Custom generic is a generic that is defined by its length and a function taking as an argument the index to be produced, the environment so far, and the generic object itself. When a value of this generic is to be obtained the supplied function is called with proper arguments. To define this type of generic, the customGeneric, or its shorthand cg command is used. Any other named arguments supplied will be added to the generic object as fields:

cg(name, dependsOn = NULL, length, f, ...)

An example will be the following generic, that assumes that there are already two generics "a" and "b" defined in the environment (it depends on "b" generic to be sure it is reevaluated on any change) and the custom generic "c" is simply their addition. 

g(a, 1, 2, 3, 4, 5)
g(b, 10, 20, 30)
cg(c, dependsOn = a, length = 15, f = function(i, env, g) { env$a + env$b })

A shorthand, only for dependent generics is to elliminate the length argument as it might well be irrelevant, in which case the length will be assumed to be 1, but on each change of the master generic, the evaluating function will be called again yielding possibly different values. The above example can thus be siplified:

g(a, 1, 2, 3, 4, 5)
g(b, 10, 20, 30)
cg(c, dependsOn = a, f = function(i, env, g) { env$a + env$b })

Checks & Conditions
-------------------

Each check or condition (a command for short) contains the arguments and the evaluating function. This is a generic command form, but shorthands exist for common variations. A new check or condition is created by function check or condition, which takes as an argument a function and arbitrary list of fields. In the fields, before calling the function, the generics are substitued by their values as defined above based on their types.

For checks the function takes as an argument the following: target, module, test (current test with pure R code after generic replacements) and a list of its arguments. It must return either NULL to allow the execution, or a list indicating the failure mode and the reason. There will be shorthand functions to do this. A simple example will be a disable target check:

check(function(target, module, test, o) { if (target$name == env$target) skip(paste("Disabled for target ",env$target)) }, target = "gnu-r")

Since this is a common check, there is a shorthand for this, named disableTarget, or dt:

disableTarget("gnu-r")

Condition is very similar, but the arguments to the method are the test itself and the execution record, this record will be specified later, but will contain the processed output of the target, etc. 








