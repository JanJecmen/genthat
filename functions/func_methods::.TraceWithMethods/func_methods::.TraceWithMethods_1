func: quote(methods::.TraceWithMethods)
body: function (what, tracer = NULL, exit = NULL, at = numeric(), print = TRUE, signature = NULL, where = .GlobalEnv, edit = FALSE, from = NULL, untrace = FALSE, classMethod = FALSE) 
body: {
body:     if (is.function(where)) {
body:         if (is(where, "genericFunction")) 
body:             where <- parent.env(environment(where))
body:         else where <- environment(where)
body:         fromPackage <- getPackageName(where)
body:     }
body:     else fromPackage <- ""
body:     doEdit <- !identical(edit, FALSE)
body:     whereF <- NULL
body:     pname <- character()
body:     def <- NULL
body:     tracingWhere <- "in package"
body:     refCase <- isS4(where) && (is(where, "envRefClass") || is(where, "refClassRepresentation"))
body:     if (refCase) {
body:         if (!is.null(signature)) 
body:             stop("argument 'signature' is not meaningful for tracing reference methods")
body:         .where <- where
body:         if (is(.where, "refGeneratorSlot") && !classMethod) 
body:             .where <- .where$def
body:         if (is(.where, "refClassRepresentation")) {
body:             pname <- .where@className
body:             .where <- .where@refMethods
body:             tracingWhere <- "for class"
body:         }
body:         else {
body:             tracingWhere <- "for object from class"
body:             pname <- class(.where)
body:         }
body:         def <- eval(substitute(.dollarForEnvRefClass(.where, what)))
body:         if (!is(def, "refMethodDef")) {
body:             thisName <- substitute(what)
body:             stop(gettextf("%s is not a method for reference class %s", sQuote(as.character(if (is.symbol(thisName)) thisName else what)), dQuote(class(where))), domain = NA)
body:         }
body:         what <- def@name
body:         whereF <- .where
body:     }
body:     else if (is.function(what)) {
body:         def <- what
body:         if (is(def, "genericFunction")) {
body:             what <- def@generic
body:             whereF <- .genEnv(what, where)
body:             pname <- def@package
body:         }
body:         else {
body:             fname <- substitute(what)
body:             if (is.name(fname)) {
body:                 what <- as.character(fname)
body:                 temp <- .findFunEnvAndName(what, where)
body:                 whereF <- temp$whereF
body:                 pname <- temp$pname
body:             }
body:             else if (is.call(fname) && identical(fname[[1L]], as.name("::"))) {
body:                 whereF <- as.character(fname[[2L]])
body:                 require(whereF, character.only = TRUE)
body:                 whereF <- as.environment(paste("package", whereF, sep = ":"))
body:                 pname <- fname[[2L]]
body:                 what <- as.character(fname[[3L]])
body:             }
body:             else if (is.call(fname) && identical(fname[[1L]], as.name(":::"))) {
body:                 pname <- paste(fname[[2L]], "(not-exported)")
body:                 whereF <- loadNamespace(as.character(fname[[2L]]))
body:                 what <- as.character(fname[[3L]])
body:             }
body:             else stop("argument 'what' should be the name of a function")
body:         }
body:     }
body:     else {
body:         what <- as(what, "character")
body:         if (length(what) != 1) {
body:             for (f in what) {
body:                 if (nargs() == 1) 
body:                   trace(f)
body:                 else Recall(f, tracer, exit, at, print, signature, where, edit, from, untrace)
body:             }
body:             return(what)
body:         }
body:         temp <- .findFunEnvAndName(what, where, signature)
body:         whereF <- temp$whereF
body:         pname <- temp$pname
body:     }
body:     if (what %in% .InvalidTracedFunctions) 
body:         stop(gettextf("tracing the internal function %s is not allowed", sQuote(what)))
body:     if (.traceTraceState) {
body:         message(".TraceWithMethods: after computing what, whereF", domain = NA)
body:         browser()
body:     }
body:     if (nargs() == 1) 
body:         return(.primTrace(what))
body:     if (is.null(whereF)) {
body:         allWhere <- findFunction(what, where = where)
body:         if (length(allWhere) == 0) 
body:             stop(gettextf("no function definition for %s found", sQuote(what)), domain = NA)
body:         whereF <- as.environment(allWhere[[1L]])
body:     }
body:     if (is.null(tracer) && is.null(exit) && identical(edit, FALSE)) 
body:         tracer <- quote({
body:         })
body:     if (is.null(def)) 
body:         def <- getFunction(what, where = whereF)
body:     if (is(def, "traceable") && identical(edit, FALSE) && !untrace) 
body:         def <- .untracedFunction(def)
body:     if (!is.null(signature)) {
body:         fdef <- if (is.primitive(def)) 
body:             getGeneric(what, TRUE, where)
body:         else def
body:         def <- selectMethod(what, signature, fdef = fdef, optional = TRUE)
body:         if (is.null(def)) {
body:             warning(gettextf("cannot untrace method for %s; no method defined for this signature: %s", sQuote(what), paste(signature, collapse = ", ")), domain = NA)
body:             return(def)
body:         }
body:         signature <- def@target
body:     }
body:     if (untrace) {
body:         if (.traceTraceState) {
body:             message(".TraceWithMethods: untrace case", domain = NA)
body:             browser()
body:         }
body:         if (is.null(signature)) {
body:             if (is(def, "traceable")) {
body:                 newFun <- .untracedFunction(def)
body:             }
body:             else {
body:                 .primUntrace(what)
body:                 return(what)
body:             }
body:         }
body:         else {
body:             if (is(def, "traceable")) 
body:                 newFun <- .untracedFunction(def)
body:             else {
body:                 warning(gettextf("the method for %s for this signature was not being traced", sQuote(what)), domain = NA)
body:                 return(what)
body:             }
body:         }
body:     }
body:     else {
body:         if (!is.null(exit)) {
body:             if (is.function(exit)) {
body:                 tname <- substitute(exit)
body:                 if (is.name(tname)) 
body:                   exit <- tname
body:                 exit <- substitute(TRACE(), list(TRACE = exit))
body:             }
body:         }
body:         if (!is.null(tracer)) {
body:             if (is.function(tracer)) {
body:                 tname <- substitute(tracer)
body:                 if (is.name(tname)) 
body:                   tracer <- tname
body:                 tracer <- substitute(TRACE(), list(TRACE = tracer))
body:             }
body:         }
body:         original <- .untracedFunction(def)
body:         traceClass <- .traceClassName(class(original))
body:         if (is.null(getClassDef(traceClass))) 
body:             traceClass <- .makeTraceClass(traceClass, class(original))
body:         if (doEdit && is.environment(edit)) {
body:             def <- .findNewDefForTrace(what, signature, edit, fromPackage)
body:             environment(def) <- environment(original)
body:             if (is.null(c(tracer, exit))) {
body:                 newFun <- new(traceClass, original)
body:                 newFun@.Data <- def
body:             }
body:             else {
body:                 newFun <- new(traceClass, def = def, tracer = tracer, exit = exit, at = at, print = print, doEdit = FALSE)
body:                 newFun@original <- original
body:             }
body:             newFun@source <- edit
body:         }
body:         else newFun <- new(traceClass, def = if (doEdit) 
body:             def
body:         else original, tracer = tracer, exit = exit, at = at, print = print, doEdit = edit)
body:     }
body:     global <- identical(whereF, .GlobalEnv)
body:     if (.traceTraceState) {
body:         message(".TraceWithMethods: about to assign or setMethod", domain = NA)
body:         browser()
body:     }
body:     if (is.null(signature)) {
body:         if (bindingIsLocked(what, whereF)) 
body:             .assignOverBinding(what, newFun, whereF, global)
body:         else assign(what, newFun, whereF)
body:         if (length(grep("[^.]+[.][^.]+", what)) > 0) {
body:             S3MTableName <- ".__S3MethodsTable__."
body:             tracedFun <- get(what, envir = whereF, inherits = TRUE)
body:             if (exists(S3MTableName, envir = whereF, inherits = FALSE)) {
body:                 tbl <- get(S3MTableName, envir = whereF, inherits = FALSE)
body:                 if (exists(what, envir = tbl, inherits = FALSE)) 
body:                   assign(what, tracedFun, envir = tbl)
body:             }
body:         }
body:     }
body:     else {
body:         if (untrace && is(newFun, "MethodDefinition") && !identical(newFun@target, newFun@defined)) 
body:             newFun <- NULL
body:         setMethod(fdef, signature, newFun, where = baseenv())
body:     }
body:     if (!global) {
body:         action <- if (untrace) 
body:             "Untracing"
body:         else "Tracing"
body:         nameSpaceCase <- FALSE
body:         location <- if (.identC(fromPackage, "")) {
body:             if (length(pname) == 0 && !is.null(whereF)) 
body:                 pname <- getPackageName(whereF)
body:             nameSpaceCase <- isNamespace(whereF) && !is.na(match(pname, loadedNamespaces())) && identical(whereF, getNamespace(pname))
body:             if (length(pname) == 0) 
body:                 ""
body:             else {
body:                 if (nameSpaceCase) 
body:                   paste0(" in environment <namespace:", pname, ">")
body:                 else paste0(" ", tracingWhere, " \"", pname, "\"")
body:             }
body:         }
body:         else paste0(" as seen from package \"", fromPackage, "\"")
body:         object <- if (refCase) 
body:             "reference method"
body:         else if (is.null(signature)) 
body:             "function"
body:         else "specified method for function"
body:         object <- paste0(" ", object, " \"", what, "\" ")
body:         .message(action, object, location)
body:         if (nameSpaceCase && !untrace && exists(what, envir = .GlobalEnv)) {
body:             untcall <- paste("untrace(\"", what, "\", where = getNamespace(\"", pname, "\"))", sep = "")
body:             .message("Warning: Tracing only in the namespace; to untrace you will need:\n    ", untcall, "\n")
body:         }
body:     }
body:     what
body: }
args: list(NULL, where = <environment>, untrace = TRUE)
retn: character(0)

func: quote(methods::.TraceWithMethods)
body: function (what, tracer = NULL, exit = NULL, at = numeric(), print = TRUE, signature = NULL, where = .GlobalEnv, edit = FALSE, from = NULL, untrace = FALSE, classMethod = FALSE) 
body: {
body:     if (is.function(where)) {
body:         if (is(where, "genericFunction")) 
body:             where <- parent.env(environment(where))
body:         else where <- environment(where)
body:         fromPackage <- getPackageName(where)
body:     }
body:     else fromPackage <- ""
body:     doEdit <- !identical(edit, FALSE)
body:     whereF <- NULL
body:     pname <- character()
body:     def <- NULL
body:     tracingWhere <- "in package"
body:     refCase <- isS4(where) && (is(where, "envRefClass") || is(where, "refClassRepresentation"))
body:     if (refCase) {
body:         if (!is.null(signature)) 
body:             stop("argument 'signature' is not meaningful for tracing reference methods")
body:         .where <- where
body:         if (is(.where, "refGeneratorSlot") && !classMethod) 
body:             .where <- .where$def
body:         if (is(.where, "refClassRepresentation")) {
body:             pname <- .where@className
body:             .where <- .where@refMethods
body:             tracingWhere <- "for class"
body:         }
body:         else {
body:             tracingWhere <- "for object from class"
body:             pname <- class(.where)
body:         }
body:         def <- eval(substitute(.dollarForEnvRefClass(.where, what)))
body:         if (!is(def, "refMethodDef")) {
body:             thisName <- substitute(what)
body:             stop(gettextf("%s is not a method for reference class %s", sQuote(as.character(if (is.symbol(thisName)) thisName else what)), dQuote(class(where))), domain = NA)
body:         }
body:         what <- def@name
body:         whereF <- .where
body:     }
body:     else if (is.function(what)) {
body:         def <- what
body:         if (is(def, "genericFunction")) {
body:             what <- def@generic
body:             whereF <- .genEnv(what, where)
body:             pname <- def@package
body:         }
body:         else {
body:             fname <- substitute(what)
body:             if (is.name(fname)) {
body:                 what <- as.character(fname)
body:                 temp <- .findFunEnvAndName(what, where)
body:                 whereF <- temp$whereF
body:                 pname <- temp$pname
body:             }
body:             else if (is.call(fname) && identical(fname[[1L]], as.name("::"))) {
body:                 whereF <- as.character(fname[[2L]])
body:                 require(whereF, character.only = TRUE)
body:                 whereF <- as.environment(paste("package", whereF, sep = ":"))
body:                 pname <- fname[[2L]]
body:                 what <- as.character(fname[[3L]])
body:             }
body:             else if (is.call(fname) && identical(fname[[1L]], as.name(":::"))) {
body:                 pname <- paste(fname[[2L]], "(not-exported)")
body:                 whereF <- loadNamespace(as.character(fname[[2L]]))
body:                 what <- as.character(fname[[3L]])
body:             }
body:             else stop("argument 'what' should be the name of a function")
body:         }
body:     }
body:     else {
body:         what <- as(what, "character")
body:         if (length(what) != 1) {
body:             for (f in what) {
body:                 if (nargs() == 1) 
body:                   trace(f)
body:                 else Recall(f, tracer, exit, at, print, signature, where, edit, from, untrace)
body:             }
body:             return(what)
body:         }
body:         temp <- .findFunEnvAndName(what, where, signature)
body:         whereF <- temp$whereF
body:         pname <- temp$pname
body:     }
body:     if (what %in% .InvalidTracedFunctions) 
body:         stop(gettextf("tracing the internal function %s is not allowed", sQuote(what)))
body:     if (.traceTraceState) {
body:         message(".TraceWithMethods: after computing what, whereF", domain = NA)
body:         browser()
body:     }
body:     if (nargs() == 1) 
body:         return(.primTrace(what))
body:     if (is.null(whereF)) {
body:         allWhere <- findFunction(what, where = where)
body:         if (length(allWhere) == 0) 
body:             stop(gettextf("no function definition for %s found", sQuote(what)), domain = NA)
body:         whereF <- as.environment(allWhere[[1L]])
body:     }
body:     if (is.null(tracer) && is.null(exit) && identical(edit, FALSE)) 
body:         tracer <- quote({
body:         })
body:     if (is.null(def)) 
body:         def <- getFunction(what, where = whereF)
body:     if (is(def, "traceable") && identical(edit, FALSE) && !untrace) 
body:         def <- .untracedFunction(def)
body:     if (!is.null(signature)) {
body:         fdef <- if (is.primitive(def)) 
body:             getGeneric(what, TRUE, where)
body:         else def
body:         def <- selectMethod(what, signature, fdef = fdef, optional = TRUE)
body:         if (is.null(def)) {
body:             warning(gettextf("cannot untrace method for %s; no method defined for this signature: %s", sQuote(what), paste(signature, collapse = ", ")), domain = NA)
body:             return(def)
body:         }
body:         signature <- def@target
body:     }
body:     if (untrace) {
body:         if (.traceTraceState) {
body:             message(".TraceWithMethods: untrace case", domain = NA)
body:             browser()
body:         }
body:         if (is.null(signature)) {
body:             if (is(def, "traceable")) {
body:                 newFun <- .untracedFunction(def)
body:             }
body:             else {
body:                 .primUntrace(what)
body:                 return(what)
body:             }
body:         }
body:         else {
body:             if (is(def, "traceable")) 
body:                 newFun <- .untracedFunction(def)
body:             else {
body:                 warning(gettextf("the method for %s for this signature was not being traced", sQuote(what)), domain = NA)
body:                 return(what)
body:             }
body:         }
body:     }
body:     else {
body:         if (!is.null(exit)) {
body:             if (is.function(exit)) {
body:                 tname <- substitute(exit)
body:                 if (is.name(tname)) 
body:                   exit <- tname
body:                 exit <- substitute(TRACE(), list(TRACE = exit))
body:             }
body:         }
body:         if (!is.null(tracer)) {
body:             if (is.function(tracer)) {
body:                 tname <- substitute(tracer)
body:                 if (is.name(tname)) 
body:                   tracer <- tname
body:                 tracer <- substitute(TRACE(), list(TRACE = tracer))
body:             }
body:         }
body:         original <- .untracedFunction(def)
body:         traceClass <- .traceClassName(class(original))
body:         if (is.null(getClassDef(traceClass))) 
body:             traceClass <- .makeTraceClass(traceClass, class(original))
body:         if (doEdit && is.environment(edit)) {
body:             def <- .findNewDefForTrace(what, signature, edit, fromPackage)
body:             environment(def) <- environment(original)
body:             if (is.null(c(tracer, exit))) {
body:                 newFun <- new(traceClass, original)
body:                 newFun@.Data <- def
body:             }
body:             else {
body:                 newFun <- new(traceClass, def = def, tracer = tracer, exit = exit, at = at, print = print, doEdit = FALSE)
body:                 newFun@original <- original
body:             }
body:             newFun@source <- edit
body:         }
body:         else newFun <- new(traceClass, def = if (doEdit) 
body:             def
body:         else original, tracer = tracer, exit = exit, at = at, print = print, doEdit = edit)
body:     }
body:     global <- identical(whereF, .GlobalEnv)
body:     if (.traceTraceState) {
body:         message(".TraceWithMethods: about to assign or setMethod", domain = NA)
body:         browser()
body:     }
body:     if (is.null(signature)) {
body:         if (bindingIsLocked(what, whereF)) 
body:             .assignOverBinding(what, newFun, whereF, global)
body:         else assign(what, newFun, whereF)
body:         if (length(grep("[^.]+[.][^.]+", what)) > 0) {
body:             S3MTableName <- ".__S3MethodsTable__."
body:             tracedFun <- get(what, envir = whereF, inherits = TRUE)
body:             if (exists(S3MTableName, envir = whereF, inherits = FALSE)) {
body:                 tbl <- get(S3MTableName, envir = whereF, inherits = FALSE)
body:                 if (exists(what, envir = tbl, inherits = FALSE)) 
body:                   assign(what, tracedFun, envir = tbl)
body:             }
body:         }
body:     }
body:     else {
body:         if (untrace && is(newFun, "MethodDefinition") && !identical(newFun@target, newFun@defined)) 
body:             newFun <- NULL
body:         setMethod(fdef, signature, newFun, where = baseenv())
body:     }
body:     if (!global) {
body:         action <- if (untrace) 
body:             "Untracing"
body:         else "Tracing"
body:         nameSpaceCase <- FALSE
body:         location <- if (.identC(fromPackage, "")) {
body:             if (length(pname) == 0 && !is.null(whereF)) 
body:                 pname <- getPackageName(whereF)
body:             nameSpaceCase <- isNamespace(whereF) && !is.na(match(pname, loadedNamespaces())) && identical(whereF, getNamespace(pname))
body:             if (length(pname) == 0) 
body:                 ""
body:             else {
body:                 if (nameSpaceCase) 
body:                   paste0(" in environment <namespace:", pname, ">")
body:                 else paste0(" ", tracingWhere, " \"", pname, "\"")
body:             }
body:         }
body:         else paste0(" as seen from package \"", fromPackage, "\"")
body:         object <- if (refCase) 
body:             "reference method"
body:         else if (is.null(signature)) 
body:             "function"
body:         else "specified method for function"
body:         object <- paste0(" ", object, " \"", what, "\" ")
body:         .message(action, object, location)
body:         if (nameSpaceCase && !untrace && exists(what, envir = .GlobalEnv)) {
body:             untcall <- paste("untrace(\"", what, "\", where = getNamespace(\"", pname, "\"))", sep = "")
body:             .message("Warning: Tracing only in the namespace; to untrace you will need:\n    ", untcall, "\n")
body:         }
body:     }
body:     what
body: }
args: list(NULL, NULL, where = <environment>, untrace = TRUE)
retn: character(0)

func: quote(methods::.TraceWithMethods)
body: function (what, tracer = NULL, exit = NULL, at = numeric(), print = TRUE, signature = NULL, where = .GlobalEnv, edit = FALSE, from = NULL, untrace = FALSE, classMethod = FALSE) 
body: {
body:     if (is.function(where)) {
body:         if (is(where, "genericFunction")) 
body:             where <- parent.env(environment(where))
body:         else where <- environment(where)
body:         fromPackage <- getPackageName(where)
body:     }
body:     else fromPackage <- ""
body:     doEdit <- !identical(edit, FALSE)
body:     whereF <- NULL
body:     pname <- character()
body:     def <- NULL
body:     tracingWhere <- "in package"
body:     refCase <- isS4(where) && (is(where, "envRefClass") || is(where, "refClassRepresentation"))
body:     if (refCase) {
body:         if (!is.null(signature)) 
body:             stop("argument 'signature' is not meaningful for tracing reference methods")
body:         .where <- where
body:         if (is(.where, "refGeneratorSlot") && !classMethod) 
body:             .where <- .where$def
body:         if (is(.where, "refClassRepresentation")) {
body:             pname <- .where@className
body:             .where <- .where@refMethods
body:             tracingWhere <- "for class"
body:         }
body:         else {
body:             tracingWhere <- "for object from class"
body:             pname <- class(.where)
body:         }
body:         def <- eval(substitute(.dollarForEnvRefClass(.where, what)))
body:         if (!is(def, "refMethodDef")) {
body:             thisName <- substitute(what)
body:             stop(gettextf("%s is not a method for reference class %s", sQuote(as.character(if (is.symbol(thisName)) thisName else what)), dQuote(class(where))), domain = NA)
body:         }
body:         what <- def@name
body:         whereF <- .where
body:     }
body:     else if (is.function(what)) {
body:         def <- what
body:         if (is(def, "genericFunction")) {
body:             what <- def@generic
body:             whereF <- .genEnv(what, where)
body:             pname <- def@package
body:         }
body:         else {
body:             fname <- substitute(what)
body:             if (is.name(fname)) {
body:                 what <- as.character(fname)
body:                 temp <- .findFunEnvAndName(what, where)
body:                 whereF <- temp$whereF
body:                 pname <- temp$pname
body:             }
body:             else if (is.call(fname) && identical(fname[[1L]], as.name("::"))) {
body:                 whereF <- as.character(fname[[2L]])
body:                 require(whereF, character.only = TRUE)
body:                 whereF <- as.environment(paste("package", whereF, sep = ":"))
body:                 pname <- fname[[2L]]
body:                 what <- as.character(fname[[3L]])
body:             }
body:             else if (is.call(fname) && identical(fname[[1L]], as.name(":::"))) {
body:                 pname <- paste(fname[[2L]], "(not-exported)")
body:                 whereF <- loadNamespace(as.character(fname[[2L]]))
body:                 what <- as.character(fname[[3L]])
body:             }
body:             else stop("argument 'what' should be the name of a function")
body:         }
body:     }
body:     else {
body:         what <- as(what, "character")
body:         if (length(what) != 1) {
body:             for (f in what) {
body:                 if (nargs() == 1) 
body:                   trace(f)
body:                 else Recall(f, tracer, exit, at, print, signature, where, edit, from, untrace)
body:             }
body:             return(what)
body:         }
body:         temp <- .findFunEnvAndName(what, where, signature)
body:         whereF <- temp$whereF
body:         pname <- temp$pname
body:     }
body:     if (what %in% .InvalidTracedFunctions) 
body:         stop(gettextf("tracing the internal function %s is not allowed", sQuote(what)))
body:     if (.traceTraceState) {
body:         message(".TraceWithMethods: after computing what, whereF", domain = NA)
body:         browser()
body:     }
body:     if (nargs() == 1) 
body:         return(.primTrace(what))
body:     if (is.null(whereF)) {
body:         allWhere <- findFunction(what, where = where)
body:         if (length(allWhere) == 0) 
body:             stop(gettextf("no function definition for %s found", sQuote(what)), domain = NA)
body:         whereF <- as.environment(allWhere[[1L]])
body:     }
body:     if (is.null(tracer) && is.null(exit) && identical(edit, FALSE)) 
body:         tracer <- quote({
body:         })
body:     if (is.null(def)) 
body:         def <- getFunction(what, where = whereF)
body:     if (is(def, "traceable") && identical(edit, FALSE) && !untrace) 
body:         def <- .untracedFunction(def)
body:     if (!is.null(signature)) {
body:         fdef <- if (is.primitive(def)) 
body:             getGeneric(what, TRUE, where)
body:         else def
body:         def <- selectMethod(what, signature, fdef = fdef, optional = TRUE)
body:         if (is.null(def)) {
body:             warning(gettextf("cannot untrace method for %s; no method defined for this signature: %s", sQuote(what), paste(signature, collapse = ", ")), domain = NA)
body:             return(def)
body:         }
body:         signature <- def@target
body:     }
body:     if (untrace) {
body:         if (.traceTraceState) {
body:             message(".TraceWithMethods: untrace case", domain = NA)
body:             browser()
body:         }
body:         if (is.null(signature)) {
body:             if (is(def, "traceable")) {
body:                 newFun <- .untracedFunction(def)
body:             }
body:             else {
body:                 .primUntrace(what)
body:                 return(what)
body:             }
body:         }
body:         else {
body:             if (is(def, "traceable")) 
body:                 newFun <- .untracedFunction(def)
body:             else {
body:                 warning(gettextf("the method for %s for this signature was not being traced", sQuote(what)), domain = NA)
body:                 return(what)
body:             }
body:         }
body:     }
body:     else {
body:         if (!is.null(exit)) {
body:             if (is.function(exit)) {
body:                 tname <- substitute(exit)
body:                 if (is.name(tname)) 
body:                   exit <- tname
body:                 exit <- substitute(TRACE(), list(TRACE = exit))
body:             }
body:         }
body:         if (!is.null(tracer)) {
body:             if (is.function(tracer)) {
body:                 tname <- substitute(tracer)
body:                 if (is.name(tname)) 
body:                   tracer <- tname
body:                 tracer <- substitute(TRACE(), list(TRACE = tracer))
body:             }
body:         }
body:         original <- .untracedFunction(def)
body:         traceClass <- .traceClassName(class(original))
body:         if (is.null(getClassDef(traceClass))) 
body:             traceClass <- .makeTraceClass(traceClass, class(original))
body:         if (doEdit && is.environment(edit)) {
body:             def <- .findNewDefForTrace(what, signature, edit, fromPackage)
body:             environment(def) <- environment(original)
body:             if (is.null(c(tracer, exit))) {
body:                 newFun <- new(traceClass, original)
body:                 newFun@.Data <- def
body:             }
body:             else {
body:                 newFun <- new(traceClass, def = def, tracer = tracer, exit = exit, at = at, print = print, doEdit = FALSE)
body:                 newFun@original <- original
body:             }
body:             newFun@source <- edit
body:         }
body:         else newFun <- new(traceClass, def = if (doEdit) 
body:             def
body:         else original, tracer = tracer, exit = exit, at = at, print = print, doEdit = edit)
body:     }
body:     global <- identical(whereF, .GlobalEnv)
body:     if (.traceTraceState) {
body:         message(".TraceWithMethods: about to assign or setMethod", domain = NA)
body:         browser()
body:     }
body:     if (is.null(signature)) {
body:         if (bindingIsLocked(what, whereF)) 
body:             .assignOverBinding(what, newFun, whereF, global)
body:         else assign(what, newFun, whereF)
body:         if (length(grep("[^.]+[.][^.]+", what)) > 0) {
body:             S3MTableName <- ".__S3MethodsTable__."
body:             tracedFun <- get(what, envir = whereF, inherits = TRUE)
body:             if (exists(S3MTableName, envir = whereF, inherits = FALSE)) {
body:                 tbl <- get(S3MTableName, envir = whereF, inherits = FALSE)
body:                 if (exists(what, envir = tbl, inherits = FALSE)) 
body:                   assign(what, tracedFun, envir = tbl)
body:             }
body:         }
body:     }
body:     else {
body:         if (untrace && is(newFun, "MethodDefinition") && !identical(newFun@target, newFun@defined)) 
body:             newFun <- NULL
body:         setMethod(fdef, signature, newFun, where = baseenv())
body:     }
body:     if (!global) {
body:         action <- if (untrace) 
body:             "Untracing"
body:         else "Tracing"
body:         nameSpaceCase <- FALSE
body:         location <- if (.identC(fromPackage, "")) {
body:             if (length(pname) == 0 && !is.null(whereF)) 
body:                 pname <- getPackageName(whereF)
body:             nameSpaceCase <- isNamespace(whereF) && !is.na(match(pname, loadedNamespaces())) && identical(whereF, getNamespace(pname))
body:             if (length(pname) == 0) 
body:                 ""
body:             else {
body:                 if (nameSpaceCase) 
body:                   paste0(" in environment <namespace:", pname, ">")
body:                 else paste0(" ", tracingWhere, " \"", pname, "\"")
body:             }
body:         }
body:         else paste0(" as seen from package \"", fromPackage, "\"")
body:         object <- if (refCase) 
body:             "reference method"
body:         else if (is.null(signature)) 
body:             "function"
body:         else "specified method for function"
body:         object <- paste0(" ", object, " \"", what, "\" ")
body:         .message(action, object, location)
body:         if (nameSpaceCase && !untrace && exists(what, envir = .GlobalEnv)) {
body:             untcall <- paste("untrace(\"", what, "\", where = getNamespace(\"", pname, "\"))", sep = "")
body:             .message("Warning: Tracing only in the namespace; to untrace you will need:\n    ", untcall, "\n")
body:         }
body:     }
body:     what
body: }
args: list(list(), where = <environment>, untrace = TRUE)
retn: character(0)

func: quote(methods::.TraceWithMethods)
body: function (what, tracer = NULL, exit = NULL, at = numeric(), print = TRUE, signature = NULL, where = .GlobalEnv, edit = FALSE, from = NULL, untrace = FALSE, classMethod = FALSE) 
body: {
body:     if (is.function(where)) {
body:         if (is(where, "genericFunction")) 
body:             where <- parent.env(environment(where))
body:         else where <- environment(where)
body:         fromPackage <- getPackageName(where)
body:     }
body:     else fromPackage <- ""
body:     doEdit <- !identical(edit, FALSE)
body:     whereF <- NULL
body:     pname <- character()
body:     def <- NULL
body:     tracingWhere <- "in package"
body:     refCase <- isS4(where) && (is(where, "envRefClass") || is(where, "refClassRepresentation"))
body:     if (refCase) {
body:         if (!is.null(signature)) 
body:             stop("argument 'signature' is not meaningful for tracing reference methods")
body:         .where <- where
body:         if (is(.where, "refGeneratorSlot") && !classMethod) 
body:             .where <- .where$def
body:         if (is(.where, "refClassRepresentation")) {
body:             pname <- .where@className
body:             .where <- .where@refMethods
body:             tracingWhere <- "for class"
body:         }
body:         else {
body:             tracingWhere <- "for object from class"
body:             pname <- class(.where)
body:         }
body:         def <- eval(substitute(.dollarForEnvRefClass(.where, what)))
body:         if (!is(def, "refMethodDef")) {
body:             thisName <- substitute(what)
body:             stop(gettextf("%s is not a method for reference class %s", sQuote(as.character(if (is.symbol(thisName)) thisName else what)), dQuote(class(where))), domain = NA)
body:         }
body:         what <- def@name
body:         whereF <- .where
body:     }
body:     else if (is.function(what)) {
body:         def <- what
body:         if (is(def, "genericFunction")) {
body:             what <- def@generic
body:             whereF <- .genEnv(what, where)
body:             pname <- def@package
body:         }
body:         else {
body:             fname <- substitute(what)
body:             if (is.name(fname)) {
body:                 what <- as.character(fname)
body:                 temp <- .findFunEnvAndName(what, where)
body:                 whereF <- temp$whereF
body:                 pname <- temp$pname
body:             }
body:             else if (is.call(fname) && identical(fname[[1L]], as.name("::"))) {
body:                 whereF <- as.character(fname[[2L]])
body:                 require(whereF, character.only = TRUE)
body:                 whereF <- as.environment(paste("package", whereF, sep = ":"))
body:                 pname <- fname[[2L]]
body:                 what <- as.character(fname[[3L]])
body:             }
body:             else if (is.call(fname) && identical(fname[[1L]], as.name(":::"))) {
body:                 pname <- paste(fname[[2L]], "(not-exported)")
body:                 whereF <- loadNamespace(as.character(fname[[2L]]))
body:                 what <- as.character(fname[[3L]])
body:             }
body:             else stop("argument 'what' should be the name of a function")
body:         }
body:     }
body:     else {
body:         what <- as(what, "character")
body:         if (length(what) != 1) {
body:             for (f in what) {
body:                 if (nargs() == 1) 
body:                   trace(f)
body:                 else Recall(f, tracer, exit, at, print, signature, where, edit, from, untrace)
body:             }
body:             return(what)
body:         }
body:         temp <- .findFunEnvAndName(what, where, signature)
body:         whereF <- temp$whereF
body:         pname <- temp$pname
body:     }
body:     if (what %in% .InvalidTracedFunctions) 
body:         stop(gettextf("tracing the internal function %s is not allowed", sQuote(what)))
body:     if (.traceTraceState) {
body:         message(".TraceWithMethods: after computing what, whereF", domain = NA)
body:         browser()
body:     }
body:     if (nargs() == 1) 
body:         return(.primTrace(what))
body:     if (is.null(whereF)) {
body:         allWhere <- findFunction(what, where = where)
body:         if (length(allWhere) == 0) 
body:             stop(gettextf("no function definition for %s found", sQuote(what)), domain = NA)
body:         whereF <- as.environment(allWhere[[1L]])
body:     }
body:     if (is.null(tracer) && is.null(exit) && identical(edit, FALSE)) 
body:         tracer <- quote({
body:         })
body:     if (is.null(def)) 
body:         def <- getFunction(what, where = whereF)
body:     if (is(def, "traceable") && identical(edit, FALSE) && !untrace) 
body:         def <- .untracedFunction(def)
body:     if (!is.null(signature)) {
body:         fdef <- if (is.primitive(def)) 
body:             getGeneric(what, TRUE, where)
body:         else def
body:         def <- selectMethod(what, signature, fdef = fdef, optional = TRUE)
body:         if (is.null(def)) {
body:             warning(gettextf("cannot untrace method for %s; no method defined for this signature: %s", sQuote(what), paste(signature, collapse = ", ")), domain = NA)
body:             return(def)
body:         }
body:         signature <- def@target
body:     }
body:     if (untrace) {
body:         if (.traceTraceState) {
body:             message(".TraceWithMethods: untrace case", domain = NA)
body:             browser()
body:         }
body:         if (is.null(signature)) {
body:             if (is(def, "traceable")) {
body:                 newFun <- .untracedFunction(def)
body:             }
body:             else {
body:                 .primUntrace(what)
body:                 return(what)
body:             }
body:         }
body:         else {
body:             if (is(def, "traceable")) 
body:                 newFun <- .untracedFunction(def)
body:             else {
body:                 warning(gettextf("the method for %s for this signature was not being traced", sQuote(what)), domain = NA)
body:                 return(what)
body:             }
body:         }
body:     }
body:     else {
body:         if (!is.null(exit)) {
body:             if (is.function(exit)) {
body:                 tname <- substitute(exit)
body:                 if (is.name(tname)) 
body:                   exit <- tname
body:                 exit <- substitute(TRACE(), list(TRACE = exit))
body:             }
body:         }
body:         if (!is.null(tracer)) {
body:             if (is.function(tracer)) {
body:                 tname <- substitute(tracer)
body:                 if (is.name(tname)) 
body:                   tracer <- tname
body:                 tracer <- substitute(TRACE(), list(TRACE = tracer))
body:             }
body:         }
body:         original <- .untracedFunction(def)
body:         traceClass <- .traceClassName(class(original))
body:         if (is.null(getClassDef(traceClass))) 
body:             traceClass <- .makeTraceClass(traceClass, class(original))
body:         if (doEdit && is.environment(edit)) {
body:             def <- .findNewDefForTrace(what, signature, edit, fromPackage)
body:             environment(def) <- environment(original)
body:             if (is.null(c(tracer, exit))) {
body:                 newFun <- new(traceClass, original)
body:                 newFun@.Data <- def
body:             }
body:             else {
body:                 newFun <- new(traceClass, def = def, tracer = tracer, exit = exit, at = at, print = print, doEdit = FALSE)
body:                 newFun@original <- original
body:             }
body:             newFun@source <- edit
body:         }
body:         else newFun <- new(traceClass, def = if (doEdit) 
body:             def
body:         else original, tracer = tracer, exit = exit, at = at, print = print, doEdit = edit)
body:     }
body:     global <- identical(whereF, .GlobalEnv)
body:     if (.traceTraceState) {
body:         message(".TraceWithMethods: about to assign or setMethod", domain = NA)
body:         browser()
body:     }
body:     if (is.null(signature)) {
body:         if (bindingIsLocked(what, whereF)) 
body:             .assignOverBinding(what, newFun, whereF, global)
body:         else assign(what, newFun, whereF)
body:         if (length(grep("[^.]+[.][^.]+", what)) > 0) {
body:             S3MTableName <- ".__S3MethodsTable__."
body:             tracedFun <- get(what, envir = whereF, inherits = TRUE)
body:             if (exists(S3MTableName, envir = whereF, inherits = FALSE)) {
body:                 tbl <- get(S3MTableName, envir = whereF, inherits = FALSE)
body:                 if (exists(what, envir = tbl, inherits = FALSE)) 
body:                   assign(what, tracedFun, envir = tbl)
body:             }
body:         }
body:     }
body:     else {
body:         if (untrace && is(newFun, "MethodDefinition") && !identical(newFun@target, newFun@defined)) 
body:             newFun <- NULL
body:         setMethod(fdef, signature, newFun, where = baseenv())
body:     }
body:     if (!global) {
body:         action <- if (untrace) 
body:             "Untracing"
body:         else "Tracing"
body:         nameSpaceCase <- FALSE
body:         location <- if (.identC(fromPackage, "")) {
body:             if (length(pname) == 0 && !is.null(whereF)) 
body:                 pname <- getPackageName(whereF)
body:             nameSpaceCase <- isNamespace(whereF) && !is.na(match(pname, loadedNamespaces())) && identical(whereF, getNamespace(pname))
body:             if (length(pname) == 0) 
body:                 ""
body:             else {
body:                 if (nameSpaceCase) 
body:                   paste0(" in environment <namespace:", pname, ">")
body:                 else paste0(" ", tracingWhere, " \"", pname, "\"")
body:             }
body:         }
body:         else paste0(" as seen from package \"", fromPackage, "\"")
body:         object <- if (refCase) 
body:             "reference method"
body:         else if (is.null(signature)) 
body:             "function"
body:         else "specified method for function"
body:         object <- paste0(" ", object, " \"", what, "\" ")
body:         .message(action, object, location)
body:         if (nameSpaceCase && !untrace && exists(what, envir = .GlobalEnv)) {
body:             untcall <- paste("untrace(\"", what, "\", where = getNamespace(\"", pname, "\"))", sep = "")
body:             .message("Warning: Tracing only in the namespace; to untrace you will need:\n    ", untcall, "\n")
body:         }
body:     }
body:     what
body: }
args: list(list(), list(), where = <environment>, untrace = TRUE)
retn: character(0)

