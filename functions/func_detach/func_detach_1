func: quote(detach)
body: function (name, pos = 2L, unload = FALSE, character.only = FALSE, force = FALSE) 
body: {
body:     if (!missing(name)) {
body:         if (!character.only) 
body:             name <- substitute(name)
body:         pos <- if (is.numeric(name)) 
body:             name
body:         else {
body:             if (!is.character(name)) 
body:                 name <- deparse(name)
body:             match(name, search())
body:         }
body:         if (is.na(pos)) 
body:             stop("invalid 'name' argument")
body:     }
body:     packageName <- search()[[pos]]
body:     if (!grepl("^package:", packageName)) 
body:         return(invisible(.Internal(detach(pos))))
body:     pkgname <- sub("^package:", "", packageName)
body:     for (pkg in search()[-1L]) {
body:         if (grepl("^package:", pkg) && exists(".Depends", pkg, inherits = FALSE) && pkgname %in% get(".Depends", pkg, inherits = FALSE)) 
body:             if (force) 
body:                 warning(gettextf("package %s is required by %s, which may no longer work correctly", sQuote(pkgname), sQuote(sub("^package:", "", pkg))), call. = FALSE, domain = NA)
body:             else stop(gettextf("package %s is required by %s so will not be detached", sQuote(pkgname), sQuote(sub("^package:", "", pkg))), call. = FALSE, domain = NA)
body:     }
body:     env <- as.environment(pos)
body:     libpath <- attr(env, "path")
body:     hook <- getHook(packageEvent(pkgname, "detach"))
body:     for (fun in rev(hook)) try(fun(pkgname, libpath))
body:     ns <- .getNamespace(pkgname)
body:     if (!is.null(ns) && exists(".onDetach", mode = "function", where = ns, inherits = FALSE)) {
body:         .onDetach <- get(".onDetach", mode = "function", pos = ns, inherits = FALSE)
body:         if (!is.null(libpath)) {
body:             res <- tryCatch(.onDetach(libpath), error = identity)
body:             if (inherits(res, "error")) {
body:                 warning(gettextf("%s failed in %s() for '%s', details:\n  call: %s\n  error: %s", ".onDetach", "detach", pkgname, deparse(conditionCall(res))[1L], conditionMessage(res)), call. = FALSE, domain = NA)
body:             }
body:         }
body:     }
body:     else if (exists(".Last.lib", mode = "function", where = pos, inherits = FALSE)) {
body:         .Last.lib <- get(".Last.lib", mode = "function", pos = pos, inherits = FALSE)
body:         if (!is.null(libpath)) {
body:             res <- tryCatch(.Last.lib(libpath), error = identity)
body:             if (inherits(res, "error")) {
body:                 warning(gettextf("%s failed in %s() for '%s', details:\n  call: %s\n  error: %s", ".Last.lib", "detach", pkgname, deparse(conditionCall(res))[1L], conditionMessage(res)), call. = FALSE, domain = NA)
body:             }
body:         }
body:     }
body:     .Internal(detach(pos))
body:     if (pkgname %in% loadedNamespaces()) {
body:         if (unload) {
body:             tryCatch(unloadNamespace(pkgname), error = function(e) warning(gettextf("%s namespace cannot be unloaded:\n  ", sQuote(pkgname)), conditionMessage(e), call. = FALSE, domain = NA))
body:         }
body:     }
body:     else {
body:         if (.isMethodsDispatchOn() && methods:::.hasS4MetaData(env)) 
body:             methods:::cacheMetaData(env, FALSE)
body:         .Internal(lazyLoadDBflush(paste0(libpath, "/R/", pkgname, ".rdb")))
body:     }
body:     invisible()
body: }
args: list(pos = 2)
retn: NULL

