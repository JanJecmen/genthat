func: quote(matplot)
body: function (x, y, type = "p", lty = 1:5, lwd = 1, lend = par("lend"), pch = NULL, col = 1:6, cex = NULL, bg = NA, xlab = NULL, ylab = NULL, xlim = NULL, ylim = NULL, ..., add = FALSE, verbose = getOption("verbose")) 
body: {
body:     paste.ch <- function(chv) paste0("\"", chv, "\"", collapse = " ")
body:     str2vec <- function(string) {
body:         if (nchar(string, type = "c")[1L] > 1L) 
body:             strsplit(string[1L], NULL)[[1L]]
body:         else string
body:     }
body:     xlabel <- if (!missing(x)) 
body:         deparse(substitute(x))
body:     ylabel <- if (!missing(y)) 
body:         deparse(substitute(y))
body:     if (missing(x)) {
body:         if (missing(y)) 
body:             stop("must specify at least one of 'x' and 'y'")
body:         else x <- seq_len(NROW(y))
body:     }
body:     else if (missing(y)) {
body:         y <- x
body:         ylabel <- xlabel
body:         x <- seq_len(NROW(y))
body:         xlabel <- ""
body:     }
body:     kx <- ncol(x <- as.matrix(x))
body:     ky <- ncol(y <- as.matrix(y))
body:     n <- nrow(x)
body:     if (n != nrow(y)) 
body:         stop("'x' and 'y' must have same number of rows")
body:     if (kx > 1L && ky > 1L && kx != ky) 
body:         stop("'x' and 'y' must have only 1 or the same number of columns")
body:     if (kx == 1L) 
body:         x <- matrix(x, nrow = n, ncol = ky)
body:     if (ky == 1L) 
body:         y <- matrix(y, nrow = n, ncol = kx)
body:     k <- max(kx, ky)
body:     type <- str2vec(type)
body:     if (is.null(pch)) {
body:         pch <- c(1L:9L, 0L, letters, LETTERS)
body:         if (k > length(pch) && any(type %in% c("p", "o", "b"))) 
body:             warning("default 'pch' is smaller than number of columns and hence recycled")
body:     }
body:     else if (is.character(pch)) 
body:         pch <- str2vec(pch)
body:     if (verbose) 
body:         message("matplot: doing ", k, " plots with ", paste0(" col= (", paste.ch(col), ")"), paste0(" pch= (", paste.ch(pch), ")"), " ...\n", domain = NA)
body:     ii <- match("log", names(xargs <- list(...)), nomatch = 0L)
body:     log <- if (ii != 0) 
body:         xargs[[ii]]
body:     xy <- xy.coords(x, y, xlabel, ylabel, log = log)
body:     xlab <- if (is.null(xlab)) 
body:         xy$xlab
body:     else xlab
body:     ylab <- if (is.null(ylab)) 
body:         xy$ylab
body:     else ylab
body:     xlim <- if (is.null(xlim)) 
body:         range(xy$x[is.finite(xy$x)])
body:     else xlim
body:     ylim <- if (is.null(ylim)) 
body:         range(xy$y[is.finite(xy$y)])
body:     else ylim
body:     if (length(type) < k) 
body:         type <- rep_len(type, k)
body:     if (length(lty) < k) 
body:         lty <- rep_len(lty, k)
body:     if (length(lend) < k) 
body:         lend <- rep_len(lend, k)
body:     if (length(lwd) < k && !is.null(lwd)) 
body:         lwd <- rep_len(lwd, k)
body:     if (length(pch) < k) 
body:         pch <- rep_len(pch, k)
body:     if (length(col) < k) 
body:         col <- rep_len(col, k)
body:     if (length(bg) < k) 
body:         bg <- rep_len(bg, k)
body:     if (is.null(cex)) 
body:         cex <- 1
body:     if (length(cex) < k) 
body:         cex <- rep_len(cex, k)
body:     ii <- seq_len(k)
body:     dev.hold()
body:     on.exit(dev.flush())
body:     if (!add) {
body:         ii <- ii[-1L]
body:         plot(x[, 1L], y[, 1L], type = type[1L], xlab = xlab, ylab = ylab, xlim = xlim, ylim = ylim, lty = lty[1L], lwd = lwd[1L], lend = lend[1L], pch = pch[1L], col = col[1L], cex = cex[1L], bg = bg[1L], ...)
body:     }
body:     for (i in ii) lines(x[, i], y[, i], type = type[i], lty = lty[i], lwd = lwd[i], lend = lend[i], pch = pch[i], col = col[i], cex = cex[i], bg = bg[i])
body:     invisible()
body: }
args: list(structure(c(4, 6, 2, 2, 6, 3, 6, 6, 5, 2, 4, 4, 2, 2, 3, 6, 6, 6, 5, 2, 4, 4, 2, 2, 3, 6, 6, 6, 5, 3, 4, 4, 2, 2, 3, 6, 6, 6, 5, 2, 4, 4, 2, 2, 3, 6, 6, 6, 5, 3, 4, 4, 4, 3, 3, 6, 6, 6, 5, 3), .Dim = c(10L, 6L), .Dimnames = list(NULL, c("x", "3c", "3", "3Rc", "3R", "sm"))), main = "Tukey Smoothers", ylab = "y ;  sm(y)", type = c("p", "l", "l", "l", "l", "l"), pch = 1L, lwd = c(1, 1, 4, 1, 3, 2), lty = c(0, 2, 3, 4, 5, 6))
retn: NULL

func: quote(matplot)
body: function (x, y, type = "p", lty = 1:5, lwd = 1, lend = par("lend"), pch = NULL, col = 1:6, cex = NULL, bg = NA, xlab = NULL, ylab = NULL, xlim = NULL, ylim = NULL, ..., add = FALSE, verbose = getOption("verbose")) 
body: {
body:     paste.ch <- function(chv) paste0("\"", chv, "\"", collapse = " ")
body:     str2vec <- function(string) {
body:         if (nchar(string, type = "c")[1L] > 1L) 
body:             strsplit(string[1L], NULL)[[1L]]
body:         else string
body:     }
body:     xlabel <- if (!missing(x)) 
body:         deparse(substitute(x))
body:     ylabel <- if (!missing(y)) 
body:         deparse(substitute(y))
body:     if (missing(x)) {
body:         if (missing(y)) 
body:             stop("must specify at least one of 'x' and 'y'")
body:         else x <- seq_len(NROW(y))
body:     }
body:     else if (missing(y)) {
body:         y <- x
body:         ylabel <- xlabel
body:         x <- seq_len(NROW(y))
body:         xlabel <- ""
body:     }
body:     kx <- ncol(x <- as.matrix(x))
body:     ky <- ncol(y <- as.matrix(y))
body:     n <- nrow(x)
body:     if (n != nrow(y)) 
body:         stop("'x' and 'y' must have same number of rows")
body:     if (kx > 1L && ky > 1L && kx != ky) 
body:         stop("'x' and 'y' must have only 1 or the same number of columns")
body:     if (kx == 1L) 
body:         x <- matrix(x, nrow = n, ncol = ky)
body:     if (ky == 1L) 
body:         y <- matrix(y, nrow = n, ncol = kx)
body:     k <- max(kx, ky)
body:     type <- str2vec(type)
body:     if (is.null(pch)) {
body:         pch <- c(1L:9L, 0L, letters, LETTERS)
body:         if (k > length(pch) && any(type %in% c("p", "o", "b"))) 
body:             warning("default 'pch' is smaller than number of columns and hence recycled")
body:     }
body:     else if (is.character(pch)) 
body:         pch <- str2vec(pch)
body:     if (verbose) 
body:         message("matplot: doing ", k, " plots with ", paste0(" col= (", paste.ch(col), ")"), paste0(" pch= (", paste.ch(pch), ")"), " ...\n", domain = NA)
body:     ii <- match("log", names(xargs <- list(...)), nomatch = 0L)
body:     log <- if (ii != 0) 
body:         xargs[[ii]]
body:     xy <- xy.coords(x, y, xlabel, ylabel, log = log)
body:     xlab <- if (is.null(xlab)) 
body:         xy$xlab
body:     else xlab
body:     ylab <- if (is.null(ylab)) 
body:         xy$ylab
body:     else ylab
body:     xlim <- if (is.null(xlim)) 
body:         range(xy$x[is.finite(xy$x)])
body:     else xlim
body:     ylim <- if (is.null(ylim)) 
body:         range(xy$y[is.finite(xy$y)])
body:     else ylim
body:     if (length(type) < k) 
body:         type <- rep_len(type, k)
body:     if (length(lty) < k) 
body:         lty <- rep_len(lty, k)
body:     if (length(lend) < k) 
body:         lend <- rep_len(lend, k)
body:     if (length(lwd) < k && !is.null(lwd)) 
body:         lwd <- rep_len(lwd, k)
body:     if (length(pch) < k) 
body:         pch <- rep_len(pch, k)
body:     if (length(col) < k) 
body:         col <- rep_len(col, k)
body:     if (length(bg) < k) 
body:         bg <- rep_len(bg, k)
body:     if (is.null(cex)) 
body:         cex <- 1
body:     if (length(cex) < k) 
body:         cex <- rep_len(cex, k)
body:     ii <- seq_len(k)
body:     dev.hold()
body:     on.exit(dev.flush())
body:     if (!add) {
body:         ii <- ii[-1L]
body:         plot(x[, 1L], y[, 1L], type = type[1L], xlab = xlab, ylab = ylab, xlim = xlim, ylim = ylim, lty = lty[1L], lwd = lwd[1L], lend = lend[1L], pch = pch[1L], col = col[1L], cex = cex[1L], bg = bg[1L], ...)
body:     }
body:     for (i in ii) lines(x[, i], y[, i], type = type[i], lty = lty[i], lwd = lwd[i], lend = lend[i], pch = pch[i], col = col[i], cex = cex[i], bg = bg[i])
body:     invisible()
body: }
args: list(structure(c(3, 2, 1, 4, 5, 1, 3, 2, 4, 5, 2, 3, 2, 2, 4, 4, 3, 2, 3, 4, 4, 2, 2, 2, 2, 4, 4, 3, 2, 3, 4, 4, 4, 3, 2, 2, 4, 4, 3, 3, 3, 4, 4, 2, 2, 2, 2, 4, 4, 3, 3, 3, 4, 4, 4, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4), .Dim = c(11L, 6L), .Dimnames = list(NULL, c("x", "3c", "3", "3Rc", "3R", "sm"))), main = "Tukey Smoothers", ylab = "y ;  sm(y)", type = c("p", "l", "l", "l", "l", "l"), pch = 1L, lwd = c(1, 1, 4, 1, 3, 2), lty = c(0, 2, 3, 4, 5, 6))
retn: NULL

func: quote(matplot)
body: function (x, y, type = "p", lty = 1:5, lwd = 1, lend = par("lend"), pch = NULL, col = 1:6, cex = NULL, bg = NA, xlab = NULL, ylab = NULL, xlim = NULL, ylim = NULL, ..., add = FALSE, verbose = getOption("verbose")) 
body: {
body:     paste.ch <- function(chv) paste0("\"", chv, "\"", collapse = " ")
body:     str2vec <- function(string) {
body:         if (nchar(string, type = "c")[1L] > 1L) 
body:             strsplit(string[1L], NULL)[[1L]]
body:         else string
body:     }
body:     xlabel <- if (!missing(x)) 
body:         deparse(substitute(x))
body:     ylabel <- if (!missing(y)) 
body:         deparse(substitute(y))
body:     if (missing(x)) {
body:         if (missing(y)) 
body:             stop("must specify at least one of 'x' and 'y'")
body:         else x <- seq_len(NROW(y))
body:     }
body:     else if (missing(y)) {
body:         y <- x
body:         ylabel <- xlabel
body:         x <- seq_len(NROW(y))
body:         xlabel <- ""
body:     }
body:     kx <- ncol(x <- as.matrix(x))
body:     ky <- ncol(y <- as.matrix(y))
body:     n <- nrow(x)
body:     if (n != nrow(y)) 
body:         stop("'x' and 'y' must have same number of rows")
body:     if (kx > 1L && ky > 1L && kx != ky) 
body:         stop("'x' and 'y' must have only 1 or the same number of columns")
body:     if (kx == 1L) 
body:         x <- matrix(x, nrow = n, ncol = ky)
body:     if (ky == 1L) 
body:         y <- matrix(y, nrow = n, ncol = kx)
body:     k <- max(kx, ky)
body:     type <- str2vec(type)
body:     if (is.null(pch)) {
body:         pch <- c(1L:9L, 0L, letters, LETTERS)
body:         if (k > length(pch) && any(type %in% c("p", "o", "b"))) 
body:             warning("default 'pch' is smaller than number of columns and hence recycled")
body:     }
body:     else if (is.character(pch)) 
body:         pch <- str2vec(pch)
body:     if (verbose) 
body:         message("matplot: doing ", k, " plots with ", paste0(" col= (", paste.ch(col), ")"), paste0(" pch= (", paste.ch(pch), ")"), " ...\n", domain = NA)
body:     ii <- match("log", names(xargs <- list(...)), nomatch = 0L)
body:     log <- if (ii != 0) 
body:         xargs[[ii]]
body:     xy <- xy.coords(x, y, xlabel, ylabel, log = log)
body:     xlab <- if (is.null(xlab)) 
body:         xy$xlab
body:     else xlab
body:     ylab <- if (is.null(ylab)) 
body:         xy$ylab
body:     else ylab
body:     xlim <- if (is.null(xlim)) 
body:         range(xy$x[is.finite(xy$x)])
body:     else xlim
body:     ylim <- if (is.null(ylim)) 
body:         range(xy$y[is.finite(xy$y)])
body:     else ylim
body:     if (length(type) < k) 
body:         type <- rep_len(type, k)
body:     if (length(lty) < k) 
body:         lty <- rep_len(lty, k)
body:     if (length(lend) < k) 
body:         lend <- rep_len(lend, k)
body:     if (length(lwd) < k && !is.null(lwd)) 
body:         lwd <- rep_len(lwd, k)
body:     if (length(pch) < k) 
body:         pch <- rep_len(pch, k)
body:     if (length(col) < k) 
body:         col <- rep_len(col, k)
body:     if (length(bg) < k) 
body:         bg <- rep_len(bg, k)
body:     if (is.null(cex)) 
body:         cex <- 1
body:     if (length(cex) < k) 
body:         cex <- rep_len(cex, k)
body:     ii <- seq_len(k)
body:     dev.hold()
body:     on.exit(dev.flush())
body:     if (!add) {
body:         ii <- ii[-1L]
body:         plot(x[, 1L], y[, 1L], type = type[1L], xlab = xlab, ylab = ylab, xlim = xlim, ylim = ylim, lty = lty[1L], lwd = lwd[1L], lend = lend[1L], pch = pch[1L], col = col[1L], cex = cex[1L], bg = bg[1L], ...)
body:     }
body:     for (i in ii) lines(x[, i], y[, i], type = type[i], lty = lty[i], lwd = lwd[i], lend = lend[i], pch = pch[i], col = col[i], cex = cex[i], bg = bg[i])
body:     invisible()
body: }
args: list(structure(c(2, 4, 2, 6, 1, 1, 2, 6, 3, 1, 6, 2, 2, 4, 2, 1, 1, 2, 3, 3, 3, 6, 2, 2, 4, 2, 1, 1, 2, 3, 3, 3, 3, 2, 2, 2, 2, 1, 1, 2, 3, 3, 3, 6, 2, 2, 2, 2, 1, 1, 2, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3), .Dim = c(11L, 6L), .Dimnames = list(NULL, c("x", "3c", "3", "3Rc", "3R", "sm"))), main = "Tukey Smoothers", ylab = "y ;  sm(y)", type = c("p", "l", "l", "l", "l", "l"), pch = 1L, lwd = c(1, 1, 4, 1, 3, 2), lty = c(0, 2, 3, 4, 5, 6))
retn: NULL

func: quote(matplot)
body: function (x, y, type = "p", lty = 1:5, lwd = 1, lend = par("lend"), pch = NULL, col = 1:6, cex = NULL, bg = NA, xlab = NULL, ylab = NULL, xlim = NULL, ylim = NULL, ..., add = FALSE, verbose = getOption("verbose")) 
body: {
body:     paste.ch <- function(chv) paste0("\"", chv, "\"", collapse = " ")
body:     str2vec <- function(string) {
body:         if (nchar(string, type = "c")[1L] > 1L) 
body:             strsplit(string[1L], NULL)[[1L]]
body:         else string
body:     }
body:     xlabel <- if (!missing(x)) 
body:         deparse(substitute(x))
body:     ylabel <- if (!missing(y)) 
body:         deparse(substitute(y))
body:     if (missing(x)) {
body:         if (missing(y)) 
body:             stop("must specify at least one of 'x' and 'y'")
body:         else x <- seq_len(NROW(y))
body:     }
body:     else if (missing(y)) {
body:         y <- x
body:         ylabel <- xlabel
body:         x <- seq_len(NROW(y))
body:         xlabel <- ""
body:     }
body:     kx <- ncol(x <- as.matrix(x))
body:     ky <- ncol(y <- as.matrix(y))
body:     n <- nrow(x)
body:     if (n != nrow(y)) 
body:         stop("'x' and 'y' must have same number of rows")
body:     if (kx > 1L && ky > 1L && kx != ky) 
body:         stop("'x' and 'y' must have only 1 or the same number of columns")
body:     if (kx == 1L) 
body:         x <- matrix(x, nrow = n, ncol = ky)
body:     if (ky == 1L) 
body:         y <- matrix(y, nrow = n, ncol = kx)
body:     k <- max(kx, ky)
body:     type <- str2vec(type)
body:     if (is.null(pch)) {
body:         pch <- c(1L:9L, 0L, letters, LETTERS)
body:         if (k > length(pch) && any(type %in% c("p", "o", "b"))) 
body:             warning("default 'pch' is smaller than number of columns and hence recycled")
body:     }
body:     else if (is.character(pch)) 
body:         pch <- str2vec(pch)
body:     if (verbose) 
body:         message("matplot: doing ", k, " plots with ", paste0(" col= (", paste.ch(col), ")"), paste0(" pch= (", paste.ch(pch), ")"), " ...\n", domain = NA)
body:     ii <- match("log", names(xargs <- list(...)), nomatch = 0L)
body:     log <- if (ii != 0) 
body:         xargs[[ii]]
body:     xy <- xy.coords(x, y, xlabel, ylabel, log = log)
body:     xlab <- if (is.null(xlab)) 
body:         xy$xlab
body:     else xlab
body:     ylab <- if (is.null(ylab)) 
body:         xy$ylab
body:     else ylab
body:     xlim <- if (is.null(xlim)) 
body:         range(xy$x[is.finite(xy$x)])
body:     else xlim
body:     ylim <- if (is.null(ylim)) 
body:         range(xy$y[is.finite(xy$y)])
body:     else ylim
body:     if (length(type) < k) 
body:         type <- rep_len(type, k)
body:     if (length(lty) < k) 
body:         lty <- rep_len(lty, k)
body:     if (length(lend) < k) 
body:         lend <- rep_len(lend, k)
body:     if (length(lwd) < k && !is.null(lwd)) 
body:         lwd <- rep_len(lwd, k)
body:     if (length(pch) < k) 
body:         pch <- rep_len(pch, k)
body:     if (length(col) < k) 
body:         col <- rep_len(col, k)
body:     if (length(bg) < k) 
body:         bg <- rep_len(bg, k)
body:     if (is.null(cex)) 
body:         cex <- 1
body:     if (length(cex) < k) 
body:         cex <- rep_len(cex, k)
body:     ii <- seq_len(k)
body:     dev.hold()
body:     on.exit(dev.flush())
body:     if (!add) {
body:         ii <- ii[-1L]
body:         plot(x[, 1L], y[, 1L], type = type[1L], xlab = xlab, ylab = ylab, xlim = xlim, ylim = ylim, lty = lty[1L], lwd = lwd[1L], lend = lend[1L], pch = pch[1L], col = col[1L], cex = cex[1L], bg = bg[1L], ...)
body:     }
body:     for (i in ii) lines(x[, i], y[, i], type = type[i], lty = lty[i], lwd = lwd[i], lend = lend[i], pch = pch[i], col = col[i], cex = cex[i], bg = bg[i])
body:     invisible()
body: }
args: list(structure(c(4, 1, 3, 6, 6, 4, 1, 6, 2, 4, 2, 4, 3, 3, 6, 6, 4, 4, 2, 4, 2, 2, 3, 3, 3, 6, 6, 4, 4, 2, 4, 2, 2, 4, 3, 3, 6, 6, 4, 4, 4, 2, 2, 2, 3, 3, 3, 6, 6, 4, 4, 4, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 2, 2, 2), .Dim = c(11L, 6L), .Dimnames = list(NULL, c("x", "3c", "3", "3Rc", "3R", "sm"))), main = "Tukey Smoothers", ylab = "y ;  sm(y)", type = c("p", "l", "l", "l", "l", "l"), pch = 1L, lwd = c(1, 1, 4, 1, 3, 2), lty = c(0, 2, 3, 4, 5, 6))
retn: NULL

