func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: list(structure(function (e1, e2) 
args: standardGeneric("!=", .Primitive("!=")), generic = structure("!=", package = "base"), package = "base", group = list("Compare"), valueClass = character(0), signature = c("e1", "e2"), default = .Primitive("!="), skeleton = quote(.Primitive("!=")(e1, e2)), class = structure("standardGeneric", package = "methods")), "function")
retn: TRUE

func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: list(structure(function (x, name) 
args: standardGeneric("$", .Primitive("$")), generic = structure("$", package = "base"), package = "base", group = list(), valueClass = character(0), signature = "x", default = .Primitive("$"), skeleton = quote(.Primitive("$")(x, name)), class = structure("standardGeneric", package = "methods")), "function")
retn: TRUE

func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: list(structure(function (x, name, value) 
args: standardGeneric("$<-", .Primitive("$<-")), generic = structure("$<-", package = "base"), package = "base", group = list(), valueClass = character(0), signature = c("x", "value"), default = .Primitive("$<-"), skeleton = quote(.Primitive("$<-")(x, name, value)), class = structure("standardGeneric", package = "methods")), "function")
retn: TRUE

func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: list(structure(function (e1, e2) 
args: standardGeneric("%%", .Primitive("%%")), generic = structure("%%", package = "base"), package = "base", group = list("Arith"), valueClass = character(0), signature = c("e1", "e2"), default = .Primitive("%%"), skeleton = quote(.Primitive("%%")(e1, e2)), class = structure("standardGeneric", package = "methods")), "function")
retn: TRUE

func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: list(structure(function (e1, e2) 
args: standardGeneric("%/%", .Primitive("%/%")), generic = structure("%/%", package = "base"), package = "base", group = list("Arith"), valueClass = character(0), signature = c("e1", "e2"), default = .Primitive("%/%"), skeleton = quote(.Primitive("%/%")(e1, e2)), class = structure("standardGeneric", package = "methods")), "function")
retn: TRUE

func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: list(structure(function (e1, e2) 
args: standardGeneric("&", .Primitive("&")), generic = structure("&", package = "base"), package = "base", group = list("Logic"), valueClass = character(0), signature = c("e1", "e2"), default = .Primitive("&"), skeleton = quote(.Primitive("&")(e1, e2)), class = structure("standardGeneric", package = "methods")), "function")
retn: TRUE

func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: list(structure(function (e1, e2) 
args: standardGeneric("*", .Primitive("*")), generic = structure("*", package = "base"), package = "base", group = list("Arith"), valueClass = character(0), signature = c("e1", "e2"), default = .Primitive("*"), skeleton = quote(.Primitive("*")(e1, e2)), class = structure("standardGeneric", package = "methods")), "function")
retn: TRUE

func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: list(structure(function (e1, e2) 
args: standardGeneric("+", .Primitive("+")), generic = structure("+", package = "base"), package = "base", group = list("Arith"), valueClass = character(0), signature = c("e1", "e2"), default = .Primitive("+"), skeleton = quote(.Primitive("+")(e1, e2)), class = structure("standardGeneric", package = "methods")), "function")
retn: TRUE

func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: list(structure(function (e1, e2) 
args: standardGeneric("-", .Primitive("-")), generic = structure("-", package = "base"), package = "base", group = list("Arith"), valueClass = character(0), signature = c("e1", "e2"), default = .Primitive("-"), skeleton = quote(.Primitive("-")(e1, e2)), class = structure("standardGeneric", package = "methods")), "function")
retn: TRUE

func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: list(structure(function (e1, e2) 
args: standardGeneric("/", .Primitive("/")), generic = structure("/", package = "base"), package = "base", group = list("Arith"), valueClass = character(0), signature = c("e1", "e2"), default = .Primitive("/"), skeleton = quote(.Primitive("/")(e1, e2)), class = structure("standardGeneric", package = "methods")), "function")
retn: TRUE

func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: list(structure(function (e1, e2) 
args: standardGeneric("<", .Primitive("<")), generic = structure("<", package = "base"), package = "base", group = list("Compare"), valueClass = character(0), signature = c("e1", "e2"), default = .Primitive("<"), skeleton = quote(.Primitive("<")(e1, e2)), class = structure("standardGeneric", package = "methods")), "function")
retn: TRUE

func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: list(structure(function (e1, e2) 
args: standardGeneric("<=", .Primitive("<=")), generic = structure("<=", package = "base"), package = "base", group = list("Compare"), valueClass = character(0), signature = c("e1", "e2"), default = .Primitive("<="), skeleton = quote(.Primitive("<=")(e1, e2)), class = structure("standardGeneric", package = "methods")), "function")
retn: TRUE

func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: list(structure(function (e1, e2) 
args: standardGeneric("==", .Primitive("==")), generic = structure("==", package = "base"), package = "base", group = list("Compare"), valueClass = character(0), signature = c("e1", "e2"), default = .Primitive("=="), skeleton = quote(.Primitive("==")(e1, e2)), class = structure("standardGeneric", package = "methods")), "function")
retn: TRUE

func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: list(structure(function (e1, e2) 
args: standardGeneric(">", .Primitive(">")), generic = structure(">", package = "base"), package = "base", group = list("Compare"), valueClass = character(0), signature = c("e1", "e2"), default = .Primitive(">"), skeleton = quote(.Primitive(">")(e1, e2)), class = structure("standardGeneric", package = "methods")), "function")
retn: TRUE

func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: list(structure(function (e1, e2) 
args: standardGeneric(">=", .Primitive(">=")), generic = structure(">=", package = "base"), package = "base", group = list("Compare"), valueClass = character(0), signature = c("e1", "e2"), default = .Primitive(">="), skeleton = quote(.Primitive(">=")(e1, e2)), class = structure("standardGeneric", package = "methods")), "function")
retn: TRUE

func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: list(structure(function (e1, e2) 
args: standardGeneric("Arith"), generic = structure("Arith", package = "base"), package = "base", group = list("Ops"), valueClass = character(0), signature = c("e1", "e2"), default = quote(`\001NULL\001`), skeleton = quote((function (e1, e2) 
args: stop("invalid call in method dispatch to 'Arith' (no default method)", domain = NA))(e1, e2)), groupMembers = list("+", "-", "*", "^", "%%", "%/%", "/"), class = structure("groupGenericFunction", package = "methods")), "function")
retn: TRUE

func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: list(structure(function (e1, e2) 
args: standardGeneric("Compare"), generic = structure("Compare", package = "methods"), package = "methods", group = list("Ops"), valueClass = character(0), signature = c("e1", "e2"), default = quote(`\001NULL\001`), skeleton = quote((function (e1, e2) 
args: stop("invalid call in method dispatch to 'Compare' (no default method)", domain = NA))(e1, e2)), groupMembers = list("==", ">", "<", "!=", "<=", ">="), class = structure("groupGenericFunction", package = "methods")), "function")
retn: TRUE

func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: list(structure(function (z) 
args: standardGeneric("Complex"), generic = structure("Complex", package = "base"), package = "base", group = list(), valueClass = character(0), signature = "z", default = quote(`\001NULL\001`), skeleton = quote((function (z) 
args: stop("invalid call in method dispatch to 'Complex' (no default method)", domain = NA))(z)), groupMembers = list("Arg", "Conj", "Im", "Mod", "Re"), class = structure("groupGenericFunction", package = "methods")), "function")
retn: TRUE

func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: list(structure(function (e1, e2) 
args: standardGeneric("Logic"), generic = structure("Logic", package = "base"), package = "base", group = list("Ops"), valueClass = character(0), signature = c("e1", "e2"), default = quote(`\001NULL\001`), skeleton = quote((function (e1, e2) 
args: stop("invalid call in method dispatch to 'Logic' (no default method)", domain = NA))(e1, e2)), groupMembers = list("&", "|"), class = structure("groupGenericFunction", package = "methods")), "function")
retn: TRUE

func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: list(structure(function (x) 
args: standardGeneric("Math"), generic = structure("Math", package = "base"), package = "base", group = list(), valueClass = character(0), signature = "x", default = quote(`\001NULL\001`), skeleton = quote((function (x) 
args: stop("invalid call in method dispatch to 'Math' (no default method)", domain = NA))(x)), groupMembers = list("abs", "sign", "sqrt", "ceiling", "floor", "trunc", "cummax", "cummin", "cumprod", "cumsum", "exp", "expm1", "log", "log10", "log2", "log1p", "cos", "cosh", "sin", "sinh", "tan", "tanh", "acos", "acosh", "asin", "asinh", "atan", "atanh", "gamma", "lgamma", "digamma", "trigamma"), class = structure("groupGenericFunction", package = "methods")), "function")
retn: TRUE

func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: list(structure(function (x, digits) 
args: standardGeneric("Math2"), generic = structure("Math2", package = "methods"), package = "methods", group = list(), valueClass = character(0), signature = c("x", "digits"), default = quote(`\001NULL\001`), skeleton = quote((function (x, digits) 
args: stop("invalid call in method dispatch to 'Math2' (no default method)", domain = NA))(x, digits)), groupMembers = list("round", "signif"), class = structure("groupGenericFunction", package = "methods")), "function")
retn: TRUE

func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: list(structure(function (e1, e2) 
args: standardGeneric("Ops"), generic = structure("Ops", package = "base"), package = "base", group = list(), valueClass = character(0), signature = c("e1", "e2"), default = quote(`\001NULL\001`), skeleton = quote((function (e1, e2) 
args: stop("invalid call in method dispatch to 'Ops' (no default method)", domain = NA))(e1, e2)), groupMembers = list("Arith", "Compare", "Logic"), class = structure("groupGenericFunction", package = "methods")), "function")
retn: TRUE

func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: list(structure(function (x, ..., na.rm = FALSE) 
args: standardGeneric("Summary"), generic = structure("Summary", package = "base"), package = "base", group = list(), valueClass = character(0), signature = c("x", "na.rm"), default = quote(`\001NULL\001`), skeleton = quote((function (x, ..., na.rm = FALSE) 
args: stop("invalid call in method dispatch to 'Summary' (no default method)", domain = NA))(x, ..., na.rm = na.rm)), groupMembers = list("max", "min", "range", "prod", "sum", "any", "all"), class = structure("groupGenericFunction", package = "methods")), "function")
retn: TRUE

func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: list(structure(function (x, i, j, ..., drop = TRUE) 
args: standardGeneric("[", .Primitive("[")), generic = structure("[", package = "base"), package = "base", group = list(), valueClass = character(0), signature = c("x", "i", "j", "drop"), default = .Primitive("["), skeleton = quote(.Primitive("[")(x, i, j, ..., drop = drop)), class = structure("standardGeneric", package = "methods")), "function")
retn: TRUE

func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: list(structure(function (e1, e2) 
args: standardGeneric("^", .Primitive("^")), generic = structure("^", package = "base"), package = "base", group = list("Arith"), valueClass = character(0), signature = c("e1", "e2"), default = .Primitive("^"), skeleton = quote(.Primitive("^")(e1, e2)), class = structure("standardGeneric", package = "methods")), "function")
retn: TRUE

func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: list(structure(function (x) 
args: standardGeneric("abs", .Primitive("abs")), generic = structure("abs", package = "base"), package = "base", group = list("Math"), valueClass = character(0), signature = "x", default = .Primitive("abs"), skeleton = quote(.Primitive("abs")(x)), class = structure("standardGeneric", package = "methods")), "function")
retn: TRUE

func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: list(structure(function (x) 
args: standardGeneric("acos", .Primitive("acos")), generic = structure("acos", package = "base"), package = "base", group = list("Math"), valueClass = character(0), signature = "x", default = .Primitive("acos"), skeleton = quote(.Primitive("acos")(x)), class = structure("standardGeneric", package = "methods")), "function")
retn: TRUE

func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: list(structure(function (x) 
args: standardGeneric("acosh", .Primitive("acosh")), generic = structure("acosh", package = "base"), package = "base", group = list("Math"), valueClass = character(0), signature = "x", default = .Primitive("acosh"), skeleton = quote(.Primitive("acosh")(x)), class = structure("standardGeneric", package = "methods")), "function")
retn: TRUE

func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: list(structure(function (method, f = "<unknown>", mlist, optional = FALSE, envir) 
args: standardGeneric("addNextMethod"), generic = structure("addNextMethod", package = "methods"), package = "methods", group = list(), valueClass = character(0), signature = c("method", "f", "mlist", "optional", "envir"), default = quote(`\001NULL\001`), skeleton = quote((function (method, f = "<unknown>", mlist, optional = FALSE, envir) 
args: stop("invalid call in method dispatch to 'addNextMethod' (no default method)", domain = NA))(method, f, mlist, optional, envir)), class = structure("standardGeneric", package = "methods")), "function")
retn: TRUE

func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: list(structure(function (x) 
args: standardGeneric("asin", .Primitive("asin")), generic = structure("asin", package = "base"), package = "base", group = list("Math"), valueClass = character(0), signature = "x", default = .Primitive("asin"), skeleton = quote(.Primitive("asin")(x)), class = structure("standardGeneric", package = "methods")), "function")
retn: TRUE

func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: list(structure(function (x) 
args: standardGeneric("asinh", .Primitive("asinh")), generic = structure("asinh", package = "base"), package = "base", group = list("Math"), valueClass = character(0), signature = "x", default = .Primitive("asinh"), skeleton = quote(.Primitive("asinh")(x)), class = structure("standardGeneric", package = "methods")), "function")
retn: TRUE

func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: list(structure(function (x) 
args: standardGeneric("atan", .Primitive("atan")), generic = structure("atan", package = "base"), package = "base", group = list("Math"), valueClass = character(0), signature = "x", default = .Primitive("atan"), skeleton = quote(.Primitive("atan")(x)), class = structure("standardGeneric", package = "methods")), "function")
retn: TRUE

func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: list(structure(function (x) 
args: standardGeneric("atanh", .Primitive("atanh")), generic = structure("atanh", package = "base"), package = "base", group = list("Math"), valueClass = character(0), signature = "x", default = .Primitive("atanh"), skeleton = quote(.Primitive("atanh")(x)), class = structure("standardGeneric", package = "methods")), "function")
retn: TRUE

func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: <arguments too long, ignored>
retn: TRUE

func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: list(structure(function (x, y, ...) 
args: standardGeneric("cbind2"), generic = structure("cbind2", package = "methods"), package = "methods", group = list(), valueClass = character(0), signature = c("x", "y"), default = quote(`\001NULL\001`), skeleton = quote((function (x, y, ...) 
args: stop("invalid call in method dispatch to 'cbind2' (no default method)", domain = NA))(x, y, ...)), class = structure("standardGeneric", package = "methods")), "function")
retn: TRUE

func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: list(structure(function (x) 
args: standardGeneric("ceiling", .Primitive("ceiling")), generic = structure("ceiling", package = "base"), package = "base", group = list("Math"), valueClass = character(0), signature = "x", default = .Primitive("ceiling"), skeleton = quote(.Primitive("ceiling")(x)), class = structure("standardGeneric", package = "methods")), "function")
retn: TRUE

func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: list(structure(function (from, to, strict = TRUE) 
args: {
args:     if (TRUE) {
args:         warning("direct use of coerce() is deprecated:  use as(from, class(to)) instead", domain = NA)
args:         return(as(from, class(to), strict = strict))
args:     }
args:     standardGeneric("coerce")
args: }, class = structure("nonstandardGenericFunction", package = "methods"), generic = structure("coerce", package = "methods"), group = list(), valueClass = character(0), package = "methods", signature = c("from", "to", "strict"), default = quote(`\001NULL\001`), skeleton = quote((function (from, to, strict = TRUE) 
args: stop("invalid call in method dispatch to 'coerce' (no default method)", domain = NA))(from, to, strict))), "function")
retn: TRUE

func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: list(structure(function (from, to, value) 
args: {
args:     if (TRUE) {
args:         warning("direct use of coerce() is deprecated:  use as(from, class(to)) <- value instead", domain = NA)
args:         return(`as<-`(from, class(to), value))
args:     }
args:     standardGeneric("coerce<-")
args: }, class = structure("nonstandardGenericFunction", package = "methods"), generic = structure("coerce<-", package = "methods"), group = list(), valueClass = character(0), package = "methods", signature = c("from", "to", "value"), default = quote(`\001NULL\001`), skeleton = quote((function (from, to, value) 
args: stop("invalid call in method dispatch to 'coerce<-' (no default method)", domain = NA))(from, to, value))), "function")
retn: TRUE

func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: list(structure(function (x) 
args: standardGeneric("cos", .Primitive("cos")), generic = structure("cos", package = "base"), package = "base", group = list("Math"), valueClass = character(0), signature = "x", default = .Primitive("cos"), skeleton = quote(.Primitive("cos")(x)), class = structure("standardGeneric", package = "methods")), "function")
retn: TRUE

func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: list(structure(function (x) 
args: standardGeneric("cosh", .Primitive("cosh")), generic = structure("cosh", package = "base"), package = "base", group = list("Math"), valueClass = character(0), signature = "x", default = .Primitive("cosh"), skeleton = quote(.Primitive("cosh")(x)), class = structure("standardGeneric", package = "methods")), "function")
retn: TRUE

func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: list(structure(function (x) 
args: standardGeneric("cummax", .Primitive("cummax")), generic = structure("cummax", package = "base"), package = "base", group = list("Math"), valueClass = character(0), signature = "x", default = .Primitive("cummax"), skeleton = quote(.Primitive("cummax")(x)), class = structure("standardGeneric", package = "methods")), "function")
retn: TRUE

func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: list(structure(function (x) 
args: standardGeneric("cummin", .Primitive("cummin")), generic = structure("cummin", package = "base"), package = "base", group = list("Math"), valueClass = character(0), signature = "x", default = .Primitive("cummin"), skeleton = quote(.Primitive("cummin")(x)), class = structure("standardGeneric", package = "methods")), "function")
retn: TRUE

func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: list(structure(function (x) 
args: standardGeneric("cumprod", .Primitive("cumprod")), generic = structure("cumprod", package = "base"), package = "base", group = list("Math"), valueClass = character(0), signature = "x", default = .Primitive("cumprod"), skeleton = quote(.Primitive("cumprod")(x)), class = structure("standardGeneric", package = "methods")), "function")
retn: TRUE

func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: list(structure(function (x) 
args: standardGeneric("cumsum", .Primitive("cumsum")), generic = structure("cumsum", package = "base"), package = "base", group = list("Math"), valueClass = character(0), signature = "x", default = .Primitive("cumsum"), skeleton = quote(.Primitive("cumsum")(x)), class = structure("standardGeneric", package = "methods")), "function")
retn: TRUE

func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: list(structure(function (x) 
args: standardGeneric("digamma", .Primitive("digamma")), generic = structure("digamma", package = "base"), package = "base", group = list("Math"), valueClass = character(0), signature = "x", default = .Primitive("digamma"), skeleton = quote(.Primitive("digamma")(x)), class = structure("standardGeneric", package = "methods")), "function")
retn: TRUE

func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: list(structure(function (x) 
args: standardGeneric("exp", .Primitive("exp")), generic = structure("exp", package = "base"), package = "base", group = list("Math"), valueClass = character(0), signature = "x", default = .Primitive("exp"), skeleton = quote(.Primitive("exp")(x)), class = structure("standardGeneric", package = "methods")), "function")
retn: TRUE

func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: list(structure(function (x) 
args: standardGeneric("expm1", .Primitive("expm1")), generic = structure("expm1", package = "base"), package = "base", group = list("Math"), valueClass = character(0), signature = "x", default = .Primitive("expm1"), skeleton = quote(.Primitive("expm1")(x)), class = structure("standardGeneric", package = "methods")), "function")
retn: TRUE

func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: list(structure(function (x) 
args: standardGeneric("floor", .Primitive("floor")), generic = structure("floor", package = "base"), package = "base", group = list("Math"), valueClass = character(0), signature = "x", default = .Primitive("floor"), skeleton = quote(.Primitive("floor")(x)), class = structure("standardGeneric", package = "methods")), "function")
retn: TRUE

func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: list(structure(function (x) 
args: standardGeneric("gamma", .Primitive("gamma")), generic = structure("gamma", package = "base"), package = "base", group = list("Math"), valueClass = character(0), signature = "x", default = .Primitive("gamma"), skeleton = quote(.Primitive("gamma")(x)), class = structure("standardGeneric", package = "methods")), "function")
retn: TRUE

func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: list(structure(function (x) 
args: standardGeneric("lgamma", .Primitive("lgamma")), generic = structure("lgamma", package = "base"), package = "base", group = list("Math"), valueClass = character(0), signature = "x", default = .Primitive("lgamma"), skeleton = quote(.Primitive("lgamma")(x)), class = structure("standardGeneric", package = "methods")), "function")
retn: TRUE

func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: list(structure(function (method, fname, envir) 
args: standardGeneric("loadMethod"), generic = structure("loadMethod", package = "methods"), package = "methods", group = list(), valueClass = character(0), signature = c("method", "fname", "envir"), default = structure(function (method, fname, envir) 
args: method, target = structure("ANY", class = structure("signature", package = "methods"), .Names = "method", package = "methods"), defined = structure("ANY", class = structure("signature", package = "methods"), .Names = "method", package = "methods"), generic = structure("loadMethod", package = "methods"), class = structure("derivedDefaultMethod", package = "methods")), skeleton = quote((function (method, fname, envir) 
args: method)(method, fname, envir)), class = structure("standardGeneric", package = "methods")), "function")
retn: TRUE

func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: list(structure(function (x, ...) 
args: standardGeneric("log", .Primitive("log")), generic = structure("log", package = "base"), package = "base", group = list("Math"), valueClass = character(0), signature = "x", default = .Primitive("log"), skeleton = quote(.Primitive("log")(x, ...)), class = structure("standardGeneric", package = "methods")), "function")
retn: TRUE

func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: list(structure(function (x) 
args: standardGeneric("log10", .Primitive("log10")), generic = structure("log10", package = "base"), package = "base", group = list("Math"), valueClass = character(0), signature = "x", default = .Primitive("log10"), skeleton = quote(.Primitive("log10")(x)), class = structure("standardGeneric", package = "methods")), "function")
retn: TRUE

func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: list(structure(function (x) 
args: standardGeneric("log1p", .Primitive("log1p")), generic = structure("log1p", package = "base"), package = "base", group = list("Math"), valueClass = character(0), signature = "x", default = .Primitive("log1p"), skeleton = quote(.Primitive("log1p")(x)), class = structure("standardGeneric", package = "methods")), "function")
retn: TRUE

func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: list(structure(function (x) 
args: standardGeneric("log2", .Primitive("log2")), generic = structure("log2", package = "base"), package = "base", group = list("Math"), valueClass = character(0), signature = "x", default = .Primitive("log2"), skeleton = quote(.Primitive("log2")(x)), class = structure("standardGeneric", package = "methods")), "function")
retn: TRUE

func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: list(structure(function (x, y, ...) 
args: standardGeneric("rbind2"), generic = structure("rbind2", package = "methods"), package = "methods", group = list(), valueClass = character(0), signature = c("x", "y"), default = quote(`\001NULL\001`), skeleton = quote((function (x, y, ...) 
args: stop("invalid call in method dispatch to 'rbind2' (no default method)", domain = NA))(x, y, ...)), class = structure("standardGeneric", package = "methods")), "function")
retn: TRUE

func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: list(structure(function (x, digits = 0) 
args: standardGeneric("round", .Primitive("round")), generic = structure("round", package = "base"), package = "base", group = list("Math2"), valueClass = character(0), signature = c("x", "digits"), default = .Primitive("round"), skeleton = quote(.Primitive("round")(x, digits)), class = structure("standardGeneric", package = "methods")), "function")
retn: TRUE

func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: list(structure(function (object) 
args: standardGeneric("show"), generic = structure("show", package = "methods"), package = "methods", group = list(), valueClass = character(0), signature = structure("object", simpleOnly = TRUE), default = structure(function (object) 
args: showDefault(object, FALSE), target = structure("ANY", class = structure("signature", package = "methods"), .Names = "object", package = "methods"), defined = structure("ANY", class = structure("signature", package = "methods"), .Names = "object", package = "methods"), generic = structure("show", package = "methods"), class = structure("derivedDefaultMethod", package = "methods")), skeleton = quote((function (object) 
args: showDefault(object, FALSE))(object)), class = structure("standardGeneric", package = "methods")), "function")
retn: TRUE

func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: list(structure(function (x) 
args: standardGeneric("sign", .Primitive("sign")), generic = structure("sign", package = "base"), package = "base", group = list("Math"), valueClass = character(0), signature = "x", default = .Primitive("sign"), skeleton = quote(.Primitive("sign")(x)), class = structure("standardGeneric", package = "methods")), "function")
retn: TRUE

func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: list(structure(function (x, digits = 6) 
args: standardGeneric("signif", .Primitive("signif")), generic = structure("signif", package = "base"), package = "base", group = list("Math2"), valueClass = character(0), signature = c("x", "digits"), default = .Primitive("signif"), skeleton = quote(.Primitive("signif")(x, digits)), class = structure("standardGeneric", package = "methods")), "function")
retn: TRUE

func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: list(structure(function (x) 
args: standardGeneric("sin", .Primitive("sin")), generic = structure("sin", package = "base"), package = "base", group = list("Math"), valueClass = character(0), signature = "x", default = .Primitive("sin"), skeleton = quote(.Primitive("sin")(x)), class = structure("standardGeneric", package = "methods")), "function")
retn: TRUE

func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: list(structure(function (x) 
args: standardGeneric("sinh", .Primitive("sinh")), generic = structure("sinh", package = "base"), package = "base", group = list("Math"), valueClass = character(0), signature = "x", default = .Primitive("sinh"), skeleton = quote(.Primitive("sinh")(x)), class = structure("standardGeneric", package = "methods")), "function")
retn: TRUE

func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: list(structure(function (object) 
args: standardGeneric("slotsFromS3"), generic = structure("slotsFromS3", package = "methods"), package = "methods", group = list(), valueClass = character(0), signature = "object", default = structure(function (object) 
args: {
args:     list()
args: }, target = structure("ANY", class = structure("signature", package = "methods"), .Names = "object", package = "methods"), defined = structure("ANY", class = structure("signature", package = "methods"), .Names = "object", package = "methods"), generic = structure("slotsFromS3", package = "methods"), class = structure("derivedDefaultMethod", package = "methods")), skeleton = quote((function (object) 
args: {
args:     list()
args: })(object)), class = structure("standardGeneric", package = "methods")), "function")
retn: TRUE

func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: list(structure(function (x) 
args: standardGeneric("sqrt", .Primitive("sqrt")), generic = structure("sqrt", package = "base"), package = "base", group = list("Math"), valueClass = character(0), signature = "x", default = .Primitive("sqrt"), skeleton = quote(.Primitive("sqrt")(x)), class = structure("standardGeneric", package = "methods")), "function")
retn: TRUE

func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: list(structure(function (x) 
args: standardGeneric("tan", .Primitive("tan")), generic = structure("tan", package = "base"), package = "base", group = list("Math"), valueClass = character(0), signature = "x", default = .Primitive("tan"), skeleton = quote(.Primitive("tan")(x)), class = structure("standardGeneric", package = "methods")), "function")
retn: TRUE

func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: list(structure(function (x) 
args: standardGeneric("tanh", .Primitive("tanh")), generic = structure("tanh", package = "base"), package = "base", group = list("Math"), valueClass = character(0), signature = "x", default = .Primitive("tanh"), skeleton = quote(.Primitive("tanh")(x)), class = structure("standardGeneric", package = "methods")), "function")
retn: TRUE

func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: list(structure(function (x) 
args: standardGeneric("trigamma", .Primitive("trigamma")), generic = structure("trigamma", package = "base"), package = "base", group = list("Math"), valueClass = character(0), signature = "x", default = .Primitive("trigamma"), skeleton = quote(.Primitive("trigamma")(x)), class = structure("standardGeneric", package = "methods")), "function")
retn: TRUE

func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: list(structure(function (x, ...) 
args: standardGeneric("trunc", .Primitive("trunc")), generic = structure("trunc", package = "base"), package = "base", group = list("Math"), valueClass = character(0), signature = "x", default = .Primitive("trunc"), skeleton = quote(.Primitive("trunc")(x, ...)), class = structure("standardGeneric", package = "methods")), "function")
retn: TRUE

func: quote(is)
body: function (object, class2) 
body: {
body:     cl <- class(object)
body:     S3Case <- length(cl) > 1L
body:     if (S3Case) 
body:         cl <- cl[[1L]]
body:     if (missing(class2)) 
body:         return(extends(cl))
body:     class1Def <- getClassDef(cl)
body:     if (is.null(class1Def)) 
body:         return(inherits(object, class2))
body:     if (is.character(class2)) 
body:         class2Def <- getClassDef(class2, .classDefEnv(class1Def))
body:     else {
body:         class2Def <- class2
body:         class2 <- class2Def@className
body:     }
body:     S3Case <- S3Case || (is.object(object) && !isS4(object))
body:     S3Case <- S3Case && (is.null(class2Def) || class2 %in% .BasicClasses || extends(class2Def, "oldClass"))
body:     if (S3Case) 
body:         return(inherits(object, class2))
body:     if (.identC(cl, class2) || .identC(class2, "ANY")) 
body:         return(TRUE)
body:     ext <- possibleExtends(cl, class2, class1Def, class2Def)
body:     if (is.logical(ext)) 
body:         ext
body:     else if (ext@simple) 
body:         TRUE
body:     else ext@test(object)
body: }
args: list(structure(function (e1, e2) 
args: standardGeneric("|", .Primitive("|")), generic = structure("|", package = "base"), package = "base", group = list("Logic"), valueClass = character(0), signature = c("e1", "e2"), default = .Primitive("|"), skeleton = quote(.Primitive("|")(e1, e2)), class = structure("standardGeneric", package = "methods")), "function")
retn: TRUE

