func: quote(.nextMethod)
body: structure(function (.Object, ...) 
body: {
body:     args <- list(...)
body:     if (length(args)) {
body:         Class <- class(.Object)
body:         if (!is.na(match(Class, .BasicClasses))) 
body:             return(newBasic(Class, ...))
body:         ClassDef <- getClass(Class)
body:         snames <- allNames(args)
body:         which <- nzchar(snames)
body:         elements <- args[which]
body:         supers <- args[!which]
body:         thisExtends <- names(ClassDef@contains)
body:         slotDefs <- ClassDef@slots
body:         dataPart <- elNamed(slotDefs, ".Data")
body:         if (is.null(dataPart)) 
body:             dataPart <- "missing"
body:         if (length(supers)) {
body:             for (i in rev(seq_along(supers))) {
body:                 obj <- el(supers, i)
body:                 Classi <- class(obj)
body:                 if (length(Classi) > 1L) 
body:                   Classi <- Classi[[1L]]
body:                 if (.identC(Classi, Class)) 
body:                   .Object <- obj
body:                 else if (extends(Classi, Class)) 
body:                   .Object <- as(obj, Class, strict = FALSE)
body:                 else if (extends(Class, Classi)) 
body:                   as(.Object, Classi) <- obj
body:                 else if (extends(Classi, dataPart)) 
body:                   .Object@.Data <- obj
body:                 else {
body:                   extendsi <- extends(Classi)[-1L]
body:                   which <- match(thisExtends, extendsi)
body:                   which <- seq_along(which)[!is.na(which)]
body:                   if (length(which)) {
body:                     Classi <- thisExtends[which[1L]]
body:                     as(.Object, Classi) <- obj
body:                   }
body:                   else stop(gettextf("cannot use object of class %s in new():  class %s does not extend that class", dQuote(Classi), dQuote(Class)), domain = NA)
body:                 }
body:             }
body:         }
body:         if (length(elements)) {
body:             snames <- names(elements)
body:             if (anyDuplicated(snames)) 
body:                 stop(gettextf("duplicated slot names: %s", paste(sQuote(snames[duplicated(snames)]), collapse = ", ")), domain = NA)
body:             which <- match(snames, names(slotDefs))
body:             if (any(is.na(which))) 
body:                 stop(sprintf(ngettext(sum(is.na(which)), "invalid name for slot of class %s: %s", "invalid names for slots of class %s: %s"), dQuote(Class), paste(snames[is.na(which)], collapse = ", ")), domain = NA)
body:             firstTime <- TRUE
body:             for (i in seq_along(snames)) {
body:                 slotName <- el(snames, i)
body:                 slotClass <- elNamed(slotDefs, slotName)
body:                 slotClassDef <- getClassDef(slotClass, package = ClassDef@package)
body:                 slotVal <- el(elements, i)
body:                 if (!.identC(class(slotVal), slotClass) && !is.null(slotClassDef)) {
body:                   valClass <- class(slotVal)
body:                   valClassDef <- getClassDef(valClass, package = ClassDef@package)
body:                   if (!identical(possibleExtends(valClass, slotClass, valClassDef, slotClassDef), FALSE)) 
body:                     slotVal <- as(slotVal, slotClass, strict = FALSE)
body:                 }
body:                 if (firstTime) {
body:                   slot(.Object, slotName, check = FALSE) <- slotVal
body:                   firstTime <- FALSE
body:                 }
body:                 else {
body:                   `slot<-`(.Object, slotName, check = FALSE, slotVal)
body:                 }
body:             }
body:         }
body:         validObject(.Object)
body:     }
body:     .Object
body: }, target = structure("MethodsList", class = structure("signature", package = "methods"), .Names = ".Object", package = "methods"), defined = structure("ANY", class = structure("signature", package = "methods"), .Names = ".Object", package = "methods"), generic = structure("initialize", package = "methods"), class = structure("derivedDefaultMethod", package = "methods"))
args: list(.Object = <S4 object of class structure("MethodsList", package = "methods")>)
retn: <S4 object of class structure("MethodsList", package = "methods")>

func: quote(.nextMethod)
body: structure(function (method, fname, envir) 
body: {
body:     assign(".target", method@target, envir = envir)
body:     assign(".defined", method@defined, envir = envir)
body:     assign(".Method", method, envir = envir)
body:     method
body: }, target = structure("MethodWithNext", class = structure("signature", package = "methods"), .Names = "method", package = "methods"), defined = structure("MethodDefinition", .Names = "method", package = "methods", class = structure("signature", package = "methods")), generic = structure("loadMethod", package = "methods"), class = structure("MethodDefinition", package = "methods"))
args: <arguments too long, ignored>
retn: <arguments too long, ignored>

func: quote(.nextMethod)
body: structure(function (.Object, ...) 
body: {
body:     args <- list(...)
body:     if (length(args)) {
body:         Class <- class(.Object)
body:         if (!is.na(match(Class, .BasicClasses))) 
body:             return(newBasic(Class, ...))
body:         ClassDef <- getClass(Class)
body:         snames <- allNames(args)
body:         which <- nzchar(snames)
body:         elements <- args[which]
body:         supers <- args[!which]
body:         thisExtends <- names(ClassDef@contains)
body:         slotDefs <- ClassDef@slots
body:         dataPart <- elNamed(slotDefs, ".Data")
body:         if (is.null(dataPart)) 
body:             dataPart <- "missing"
body:         if (length(supers)) {
body:             for (i in rev(seq_along(supers))) {
body:                 obj <- el(supers, i)
body:                 Classi <- class(obj)
body:                 if (length(Classi) > 1L) 
body:                   Classi <- Classi[[1L]]
body:                 if (.identC(Classi, Class)) 
body:                   .Object <- obj
body:                 else if (extends(Classi, Class)) 
body:                   .Object <- as(obj, Class, strict = FALSE)
body:                 else if (extends(Class, Classi)) 
body:                   as(.Object, Classi) <- obj
body:                 else if (extends(Classi, dataPart)) 
body:                   .Object@.Data <- obj
body:                 else {
body:                   extendsi <- extends(Classi)[-1L]
body:                   which <- match(thisExtends, extendsi)
body:                   which <- seq_along(which)[!is.na(which)]
body:                   if (length(which)) {
body:                     Classi <- thisExtends[which[1L]]
body:                     as(.Object, Classi) <- obj
body:                   }
body:                   else stop(gettextf("cannot use object of class %s in new():  class %s does not extend that class", dQuote(Classi), dQuote(Class)), domain = NA)
body:                 }
body:             }
body:         }
body:         if (length(elements)) {
body:             snames <- names(elements)
body:             if (anyDuplicated(snames)) 
body:                 stop(gettextf("duplicated slot names: %s", paste(sQuote(snames[duplicated(snames)]), collapse = ", ")), domain = NA)
body:             which <- match(snames, names(slotDefs))
body:             if (any(is.na(which))) 
body:                 stop(sprintf(ngettext(sum(is.na(which)), "invalid name for slot of class %s: %s", "invalid names for slots of class %s: %s"), dQuote(Class), paste(snames[is.na(which)], collapse = ", ")), domain = NA)
body:             firstTime <- TRUE
body:             for (i in seq_along(snames)) {
body:                 slotName <- el(snames, i)
body:                 slotClass <- elNamed(slotDefs, slotName)
body:                 slotClassDef <- getClassDef(slotClass, package = ClassDef@package)
body:                 slotVal <- el(elements, i)
body:                 if (!.identC(class(slotVal), slotClass) && !is.null(slotClassDef)) {
body:                   valClass <- class(slotVal)
body:                   valClassDef <- getClassDef(valClass, package = ClassDef@package)
body:                   if (!identical(possibleExtends(valClass, slotClass, valClassDef, slotClassDef), FALSE)) 
body:                     slotVal <- as(slotVal, slotClass, strict = FALSE)
body:                 }
body:                 if (firstTime) {
body:                   slot(.Object, slotName, check = FALSE) <- slotVal
body:                   firstTime <- FALSE
body:                 }
body:                 else {
body:                   `slot<-`(.Object, slotName, check = FALSE, slotVal)
body:                 }
body:             }
body:         }
body:         validObject(.Object)
body:     }
body:     .Object
body: }, target = structure(".environment", class = structure("signature", package = "methods"), .Names = ".Object", package = "methods"), defined = structure("ANY", class = structure("signature", package = "methods"), .Names = ".Object", package = "methods"), generic = structure("initialize", package = "methods"), class = structure("derivedDefaultMethod", package = "methods"))
args: list(<S4 object of class structure("sourceEnvironment", package = "methods")>, packageName = "", sourceFile = "")
retn: <S4 object of class structure("sourceEnvironment", package = "methods")>

