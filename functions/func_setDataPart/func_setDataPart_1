func: quote(setDataPart)
body: function (object, value, check = TRUE) 
body: {
body:     if (check || identical(typeof(object), "S4")) {
body:         classDef <- getClass(class(object))
body:         slots <- getSlots(classDef)
body:         dataSlot <- .dataSlot(names(slots))
body:         if (length(dataSlot) == 1) 
body:             dataClass <- elNamed(slots, dataSlot)
body:         else if (check) 
body:             stop(gettextf("class %s does not have a data part (a .Data slot) defined", dQuote(class(object))), domain = NA)
body:         else return(.mergeAttrs(value, object))
body:         value <- as(value, dataClass)
body:         if (identical(typeof(object), "S4")) {
body:             if (is.null(value)) 
body:                 value <- .pseudoNULL
body:             attr(object, dataSlot) <- value
body:             return(object)
body:         }
body:     }
body:     .mergeAttrs(value, object)
body: }
args: list(structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), c("MethodWithNext", "MethodDefinition"))
retn: structure(c("MethodWithNext", "MethodDefinition"), .Names = c(NA_character_, NA_character_), package = character(0), class = structure("signature", package = "methods"))

func: quote(setDataPart)
body: function (object, value, check = TRUE) 
body: {
body:     if (check || identical(typeof(object), "S4")) {
body:         classDef <- getClass(class(object))
body:         slots <- getSlots(classDef)
body:         dataSlot <- .dataSlot(names(slots))
body:         if (length(dataSlot) == 1) 
body:             dataClass <- elNamed(slots, dataSlot)
body:         else if (check) 
body:             stop(gettextf("class %s does not have a data part (a .Data slot) defined", dQuote(class(object))), domain = NA)
body:         else return(.mergeAttrs(value, object))
body:         value <- as(value, dataClass)
body:         if (identical(typeof(object), "S4")) {
body:             if (is.null(value)) 
body:                 value <- .pseudoNULL
body:             attr(object, dataSlot) <- value
body:             return(object)
body:         }
body:     }
body:     .mergeAttrs(value, object)
body: }
args: list(structure(function () 
args: NULL, target = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), defined = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), generic = character(0), class = structure("MethodDefinition", package = "methods")), function (from, to = "MethodDefinition", value) 
args: {
args:     for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
args:     from
args: })
retn: structure(function (from, to = "MethodDefinition", value) 
retn: {
retn:     for (what in c(".Data", "target", "defined", "generic")) slot(from, what) <- slot(value, what)
retn:     from
retn: }, target = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), defined = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), generic = character(0), class = structure("MethodDefinition", package = "methods"))

func: quote(setDataPart)
body: function (object, value, check = TRUE) 
body: {
body:     if (check || identical(typeof(object), "S4")) {
body:         classDef <- getClass(class(object))
body:         slots <- getSlots(classDef)
body:         dataSlot <- .dataSlot(names(slots))
body:         if (length(dataSlot) == 1) 
body:             dataClass <- elNamed(slots, dataSlot)
body:         else if (check) 
body:             stop(gettextf("class %s does not have a data part (a .Data slot) defined", dQuote(class(object))), domain = NA)
body:         else return(.mergeAttrs(value, object))
body:         value <- as(value, dataClass)
body:         if (identical(typeof(object), "S4")) {
body:             if (is.null(value)) 
body:                 value <- .pseudoNULL
body:             attr(object, dataSlot) <- value
body:             return(object)
body:         }
body:     }
body:     .mergeAttrs(value, object)
body: }
args: list(structure(function () 
args: NULL, target = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), defined = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), generic = character(0), nextMethod = function () 
args: NULL, excluded = list(), class = structure("MethodWithNext", package = "methods")), function (.Object, ...) 
args: {
args:     .MlistDeprecated()
args:     callNextMethod()
args: })
retn: structure(function (.Object, ...) 
retn: {
retn:     .MlistDeprecated()
retn:     callNextMethod()
retn: }, target = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), defined = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), generic = character(0), nextMethod = function () 
retn: NULL, excluded = list(), class = structure("MethodWithNext", package = "methods"))

func: quote(setDataPart)
body: function (object, value, check = TRUE) 
body: {
body:     if (check || identical(typeof(object), "S4")) {
body:         classDef <- getClass(class(object))
body:         slots <- getSlots(classDef)
body:         dataSlot <- .dataSlot(names(slots))
body:         if (length(dataSlot) == 1) 
body:             dataClass <- elNamed(slots, dataSlot)
body:         else if (check) 
body:             stop(gettextf("class %s does not have a data part (a .Data slot) defined", dQuote(class(object))), domain = NA)
body:         else return(.mergeAttrs(value, object))
body:         value <- as(value, dataClass)
body:         if (identical(typeof(object), "S4")) {
body:             if (is.null(value)) 
body:                 value <- .pseudoNULL
body:             attr(object, dataSlot) <- value
body:             return(object)
body:         }
body:     }
body:     .mergeAttrs(value, object)
body: }
args: list(structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), c("derivedDefaultMethod", "PossibleMethod"))
retn: structure(c("derivedDefaultMethod", "PossibleMethod"), .Names = c(NA_character_, NA_character_), package = character(0), class = structure("signature", package = "methods"))

func: quote(setDataPart)
body: function (object, value, check = TRUE) 
body: {
body:     if (check || identical(typeof(object), "S4")) {
body:         classDef <- getClass(class(object))
body:         slots <- getSlots(classDef)
body:         dataSlot <- .dataSlot(names(slots))
body:         if (length(dataSlot) == 1) 
body:             dataClass <- elNamed(slots, dataSlot)
body:         else if (check) 
body:             stop(gettextf("class %s does not have a data part (a .Data slot) defined", dQuote(class(object))), domain = NA)
body:         else return(.mergeAttrs(value, object))
body:         value <- as(value, dataClass)
body:         if (identical(typeof(object), "S4")) {
body:             if (is.null(value)) 
body:                 value <- .pseudoNULL
body:             attr(object, dataSlot) <- value
body:             return(object)
body:         }
body:     }
body:     .mergeAttrs(value, object)
body: }
args: list(structure(function () 
args: NULL, target = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), defined = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), generic = character(0), class = structure("MethodDefinition", package = "methods")), function (from, to = "PossibleMethod", strict = TRUE) 
args: if (strict) {
args:     if (strict) from <- from@.Data
args:     from
args: } else from)
retn: structure(function (from, to = "PossibleMethod", strict = TRUE) 
retn: if (strict) {
retn:     if (strict) 
retn:         from <- from@.Data
retn:     from
retn: } else from, target = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), defined = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), generic = character(0), class = structure("MethodDefinition", package = "methods"))

func: quote(setDataPart)
body: function (object, value, check = TRUE) 
body: {
body:     if (check || identical(typeof(object), "S4")) {
body:         classDef <- getClass(class(object))
body:         slots <- getSlots(classDef)
body:         dataSlot <- .dataSlot(names(slots))
body:         if (length(dataSlot) == 1) 
body:             dataClass <- elNamed(slots, dataSlot)
body:         else if (check) 
body:             stop(gettextf("class %s does not have a data part (a .Data slot) defined", dQuote(class(object))), domain = NA)
body:         else return(.mergeAttrs(value, object))
body:         value <- as(value, dataClass)
body:         if (identical(typeof(object), "S4")) {
body:             if (is.null(value)) 
body:                 value <- .pseudoNULL
body:             attr(object, dataSlot) <- value
body:             return(object)
body:         }
body:     }
body:     .mergeAttrs(value, object)
body: }
args: list(structure(function () 
args: NULL, target = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), defined = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), generic = character(0), nextMethod = function () 
args: NULL, excluded = list(), class = structure("MethodWithNext", package = "methods")), function (method, fname, envir) 
args: {
args:     callNextMethod()
args:     assign(".nextMethod", method@nextMethod, envir = envir)
args:     method
args: })
retn: structure(function (method, fname, envir) 
retn: {
retn:     callNextMethod()
retn:     assign(".nextMethod", method@nextMethod, envir = envir)
retn:     method
retn: }, target = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), defined = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), generic = character(0), nextMethod = function () 
retn: NULL, excluded = list(), class = structure("MethodWithNext", package = "methods"))

func: quote(setDataPart)
body: function (object, value, check = TRUE) 
body: {
body:     if (check || identical(typeof(object), "S4")) {
body:         classDef <- getClass(class(object))
body:         slots <- getSlots(classDef)
body:         dataSlot <- .dataSlot(names(slots))
body:         if (length(dataSlot) == 1) 
body:             dataClass <- elNamed(slots, dataSlot)
body:         else if (check) 
body:             stop(gettextf("class %s does not have a data part (a .Data slot) defined", dQuote(class(object))), domain = NA)
body:         else return(.mergeAttrs(value, object))
body:         value <- as(value, dataClass)
body:         if (identical(typeof(object), "S4")) {
body:             if (is.null(value)) 
body:                 value <- .pseudoNULL
body:             attr(object, dataSlot) <- value
body:             return(object)
body:         }
body:     }
body:     .mergeAttrs(value, object)
body: }
args: list(structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), c("MethodDefinition", "PossibleMethod"))
retn: structure(c("MethodDefinition", "PossibleMethod"), .Names = c(NA_character_, NA_character_), package = character(0), class = structure("signature", package = "methods"))

func: quote(setDataPart)
body: function (object, value, check = TRUE) 
body: {
body:     if (check || identical(typeof(object), "S4")) {
body:         classDef <- getClass(class(object))
body:         slots <- getSlots(classDef)
body:         dataSlot <- .dataSlot(names(slots))
body:         if (length(dataSlot) == 1) 
body:             dataClass <- elNamed(slots, dataSlot)
body:         else if (check) 
body:             stop(gettextf("class %s does not have a data part (a .Data slot) defined", dQuote(class(object))), domain = NA)
body:         else return(.mergeAttrs(value, object))
body:         value <- as(value, dataClass)
body:         if (identical(typeof(object), "S4")) {
body:             if (is.null(value)) 
body:                 value <- .pseudoNULL
body:             attr(object, dataSlot) <- value
body:             return(object)
body:         }
body:     }
body:     .mergeAttrs(value, object)
body: }
args: list(structure(function () 
args: NULL, target = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), defined = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), generic = character(0), class = structure("MethodDefinition", package = "methods")), function (from, to = "PossibleMethod", strict = TRUE) 
args: from)
retn: structure(function (from, to = "PossibleMethod", strict = TRUE) 
retn: from, target = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), defined = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), generic = character(0), class = structure("MethodDefinition", package = "methods"))

func: quote(setDataPart)
body: function (object, value, check = TRUE) 
body: {
body:     if (check || identical(typeof(object), "S4")) {
body:         classDef <- getClass(class(object))
body:         slots <- getSlots(classDef)
body:         dataSlot <- .dataSlot(names(slots))
body:         if (length(dataSlot) == 1) 
body:             dataClass <- elNamed(slots, dataSlot)
body:         else if (check) 
body:             stop(gettextf("class %s does not have a data part (a .Data slot) defined", dQuote(class(object))), domain = NA)
body:         else return(.mergeAttrs(value, object))
body:         value <- as(value, dataClass)
body:         if (identical(typeof(object), "S4")) {
body:             if (is.null(value)) 
body:                 value <- .pseudoNULL
body:             attr(object, dataSlot) <- value
body:             return(object)
body:         }
body:     }
body:     .mergeAttrs(value, object)
body: }
args: <arguments too long, ignored>
retn: <arguments too long, ignored>

func: quote(setDataPart)
body: function (object, value, check = TRUE) 
body: {
body:     if (check || identical(typeof(object), "S4")) {
body:         classDef <- getClass(class(object))
body:         slots <- getSlots(classDef)
body:         dataSlot <- .dataSlot(names(slots))
body:         if (length(dataSlot) == 1) 
body:             dataClass <- elNamed(slots, dataSlot)
body:         else if (check) 
body:             stop(gettextf("class %s does not have a data part (a .Data slot) defined", dQuote(class(object))), domain = NA)
body:         else return(.mergeAttrs(value, object))
body:         value <- as(value, dataClass)
body:         if (identical(typeof(object), "S4")) {
body:             if (is.null(value)) 
body:                 value <- .pseudoNULL
body:             attr(object, dataSlot) <- value
body:             return(object)
body:         }
body:     }
body:     .mergeAttrs(value, object)
body: }
args: list(structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), c("ObjectsWithPackage", "character"))
retn: structure(c("ObjectsWithPackage", "character"), .Names = c(NA_character_, NA_character_), package = character(0), class = structure("signature", package = "methods"))

func: quote(setDataPart)
body: function (object, value, check = TRUE) 
body: {
body:     if (check || identical(typeof(object), "S4")) {
body:         classDef <- getClass(class(object))
body:         slots <- getSlots(classDef)
body:         dataSlot <- .dataSlot(names(slots))
body:         if (length(dataSlot) == 1) 
body:             dataClass <- elNamed(slots, dataSlot)
body:         else if (check) 
body:             stop(gettextf("class %s does not have a data part (a .Data slot) defined", dQuote(class(object))), domain = NA)
body:         else return(.mergeAttrs(value, object))
body:         value <- as(value, dataClass)
body:         if (identical(typeof(object), "S4")) {
body:             if (is.null(value)) 
body:                 value <- .pseudoNULL
body:             attr(object, dataSlot) <- value
body:             return(object)
body:         }
body:     }
body:     .mergeAttrs(value, object)
body: }
args: list(structure(function () 
args: NULL, target = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), defined = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), generic = character(0), class = structure("MethodDefinition", package = "methods")), function (from, to = "character", value) 
args: {
args:     from@.Data <- as(value, "character", strict = FALSE)
args:     from
args: })
retn: structure(function (from, to = "character", value) 
retn: {
retn:     from@.Data <- as(value, "character", strict = FALSE)
retn:     from
retn: }, target = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), defined = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), generic = character(0), class = structure("MethodDefinition", package = "methods"))

func: quote(setDataPart)
body: function (object, value, check = TRUE) 
body: {
body:     if (check || identical(typeof(object), "S4")) {
body:         classDef <- getClass(class(object))
body:         slots <- getSlots(classDef)
body:         dataSlot <- .dataSlot(names(slots))
body:         if (length(dataSlot) == 1) 
body:             dataClass <- elNamed(slots, dataSlot)
body:         else if (check) 
body:             stop(gettextf("class %s does not have a data part (a .Data slot) defined", dQuote(class(object))), domain = NA)
body:         else return(.mergeAttrs(value, object))
body:         value <- as(value, dataClass)
body:         if (identical(typeof(object), "S4")) {
body:             if (is.null(value)) 
body:                 value <- .pseudoNULL
body:             attr(object, dataSlot) <- value
body:             return(object)
body:         }
body:     }
body:     .mergeAttrs(value, object)
body: }
args: list(structure(character(0), package = character(0), class = structure("ObjectsWithPackage", package = "methods")), c("!=", "$", "$<-", "%%", "%/%", "&", "*", "+", "-", "/", "<", "<=", "==", ">", ">=", "Arith", "Compare", "Complex", "Logic", "Math", "Math2", "Ops", "Summary", "[", "^", "abs", "acos", "acosh", "addNextMethod", "asin", "asinh", "atan", "atanh", "body<-", "cbind2", "ceiling", "coerce", "coerce<-", "cos", "cosh", "cummax", "cummin", "cumprod", "cumsum", "digamma", "exp", "expm1", "floor", 
args: "gamma", "initialize", "kronecker", "lgamma", "loadMethod", "log", "log10", "log1p", "log2", "rbind2", "round", "show", "sign", "signif", "sin", "sinh", "slotsFromS3", "sqrt", "tan", "tanh", "trigamma", "trunc", "|"))
retn: structure(c("!=", "$", "$<-", "%%", "%/%", "&", "*", "+", "-", "/", "<", "<=", "==", ">", ">=", "Arith", "Compare", "Complex", "Logic", "Math", "Math2", "Ops", "Summary", "[", "^", "abs", "acos", "acosh", "addNextMethod", "asin", "asinh", "atan", "atanh", "body<-", "cbind2", "ceiling", "coerce", "coerce<-", "cos", "cosh", "cummax", "cummin", "cumprod", "cumsum", "digamma", "exp", "expm1", "floor", "gamma", "initialize", "kronecker", "lgamma", "loadMethod", "log", "log10", "log1p", "log2", "rbind2", 
retn: "round", "show", "sign", "signif", "sin", "sinh", "slotsFromS3", "sqrt", "tan", "tanh", "trigamma", "trunc", "|"), package = character(0), class = structure("ObjectsWithPackage", package = "methods"))

func: quote(setDataPart)
body: function (object, value, check = TRUE) 
body: {
body:     if (check || identical(typeof(object), "S4")) {
body:         classDef <- getClass(class(object))
body:         slots <- getSlots(classDef)
body:         dataSlot <- .dataSlot(names(slots))
body:         if (length(dataSlot) == 1) 
body:             dataClass <- elNamed(slots, dataSlot)
body:         else if (check) 
body:             stop(gettextf("class %s does not have a data part (a .Data slot) defined", dQuote(class(object))), domain = NA)
body:         else return(.mergeAttrs(value, object))
body:         value <- as(value, dataClass)
body:         if (identical(typeof(object), "S4")) {
body:             if (is.null(value)) 
body:                 value <- .pseudoNULL
body:             attr(object, dataSlot) <- value
body:             return(object)
body:         }
body:     }
body:     .mergeAttrs(value, object)
body: }
args: list(structure(function () 
args: NULL, target = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), defined = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), generic = character(0), class = structure("MethodDefinition", package = "methods")), function (from, to = "character", strict = TRUE) 
args: if (strict) {
args:     attributes(from) <- NULL
args:     from
args: } else from)
retn: structure(function (from, to = "character", strict = TRUE) 
retn: if (strict) {
retn:     attributes(from) <- NULL
retn:     from
retn: } else from, target = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), defined = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), generic = character(0), class = structure("MethodDefinition", package = "methods"))

func: quote(setDataPart)
body: function (object, value, check = TRUE) 
body: {
body:     if (check || identical(typeof(object), "S4")) {
body:         classDef <- getClass(class(object))
body:         slots <- getSlots(classDef)
body:         dataSlot <- .dataSlot(names(slots))
body:         if (length(dataSlot) == 1) 
body:             dataClass <- elNamed(slots, dataSlot)
body:         else if (check) 
body:             stop(gettextf("class %s does not have a data part (a .Data slot) defined", dQuote(class(object))), domain = NA)
body:         else return(.mergeAttrs(value, object))
body:         value <- as(value, dataClass)
body:         if (identical(typeof(object), "S4")) {
body:             if (is.null(value)) 
body:                 value <- .pseudoNULL
body:             attr(object, dataSlot) <- value
body:             return(object)
body:         }
body:     }
body:     .mergeAttrs(value, object)
body: }
args: list(structure(character(0), package = character(0), class = structure("ObjectsWithPackage", package = "methods")), character(0))
retn: structure(character(0), package = character(0), class = structure("ObjectsWithPackage", package = "methods"))

func: quote(setDataPart)
body: function (object, value, check = TRUE) 
body: {
body:     if (check || identical(typeof(object), "S4")) {
body:         classDef <- getClass(class(object))
body:         slots <- getSlots(classDef)
body:         dataSlot <- .dataSlot(names(slots))
body:         if (length(dataSlot) == 1) 
body:             dataClass <- elNamed(slots, dataSlot)
body:         else if (check) 
body:             stop(gettextf("class %s does not have a data part (a .Data slot) defined", dQuote(class(object))), domain = NA)
body:         else return(.mergeAttrs(value, object))
body:         value <- as(value, dataClass)
body:         if (identical(typeof(object), "S4")) {
body:             if (is.null(value)) 
body:                 value <- .pseudoNULL
body:             attr(object, dataSlot) <- value
body:             return(object)
body:         }
body:     }
body:     .mergeAttrs(value, object)
body: }
args: list(structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), structure("ANY", .Names = "e1"))
retn: structure("ANY", .Names = "e1", package = character(0), class = structure("signature", package = "methods"))

func: quote(setDataPart)
body: function (object, value, check = TRUE) 
body: {
body:     if (check || identical(typeof(object), "S4")) {
body:         classDef <- getClass(class(object))
body:         slots <- getSlots(classDef)
body:         dataSlot <- .dataSlot(names(slots))
body:         if (length(dataSlot) == 1) 
body:             dataClass <- elNamed(slots, dataSlot)
body:         else if (check) 
body:             stop(gettextf("class %s does not have a data part (a .Data slot) defined", dQuote(class(object))), domain = NA)
body:         else return(.mergeAttrs(value, object))
body:         value <- as(value, dataClass)
body:         if (identical(typeof(object), "S4")) {
body:             if (is.null(value)) 
body:                 value <- .pseudoNULL
body:             attr(object, dataSlot) <- value
body:             return(object)
body:         }
body:     }
body:     .mergeAttrs(value, object)
body: }
args: list(structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), structure("ANY", .Names = "x"))
retn: structure("ANY", .Names = "x", package = character(0), class = structure("signature", package = "methods"))

func: quote(setDataPart)
body: function (object, value, check = TRUE) 
body: {
body:     if (check || identical(typeof(object), "S4")) {
body:         classDef <- getClass(class(object))
body:         slots <- getSlots(classDef)
body:         dataSlot <- .dataSlot(names(slots))
body:         if (length(dataSlot) == 1) 
body:             dataClass <- elNamed(slots, dataSlot)
body:         else if (check) 
body:             stop(gettextf("class %s does not have a data part (a .Data slot) defined", dQuote(class(object))), domain = NA)
body:         else return(.mergeAttrs(value, object))
body:         value <- as(value, dataClass)
body:         if (identical(typeof(object), "S4")) {
body:             if (is.null(value)) 
body:                 value <- .pseudoNULL
body:             attr(object, dataSlot) <- value
body:             return(object)
body:         }
body:     }
body:     .mergeAttrs(value, object)
body: }
args: list(structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), structure("ANY", .Names = "z"))
retn: structure("ANY", .Names = "z", package = character(0), class = structure("signature", package = "methods"))

func: quote(setDataPart)
body: function (object, value, check = TRUE) 
body: {
body:     if (check || identical(typeof(object), "S4")) {
body:         classDef <- getClass(class(object))
body:         slots <- getSlots(classDef)
body:         dataSlot <- .dataSlot(names(slots))
body:         if (length(dataSlot) == 1) 
body:             dataClass <- elNamed(slots, dataSlot)
body:         else if (check) 
body:             stop(gettextf("class %s does not have a data part (a .Data slot) defined", dQuote(class(object))), domain = NA)
body:         else return(.mergeAttrs(value, object))
body:         value <- as(value, dataClass)
body:         if (identical(typeof(object), "S4")) {
body:             if (is.null(value)) 
body:                 value <- .pseudoNULL
body:             attr(object, dataSlot) <- value
body:             return(object)
body:         }
body:     }
body:     .mergeAttrs(value, object)
body: }
args: list(structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), structure("ANY", .Names = "method"))
retn: structure("ANY", .Names = "method", package = character(0), class = structure("signature", package = "methods"))

func: quote(setDataPart)
body: function (object, value, check = TRUE) 
body: {
body:     if (check || identical(typeof(object), "S4")) {
body:         classDef <- getClass(class(object))
body:         slots <- getSlots(classDef)
body:         dataSlot <- .dataSlot(names(slots))
body:         if (length(dataSlot) == 1) 
body:             dataClass <- elNamed(slots, dataSlot)
body:         else if (check) 
body:             stop(gettextf("class %s does not have a data part (a .Data slot) defined", dQuote(class(object))), domain = NA)
body:         else return(.mergeAttrs(value, object))
body:         value <- as(value, dataClass)
body:         if (identical(typeof(object), "S4")) {
body:             if (is.null(value)) 
body:                 value <- .pseudoNULL
body:             attr(object, dataSlot) <- value
body:             return(object)
body:         }
body:     }
body:     .mergeAttrs(value, object)
body: }
args: list(structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), structure("ANY", .Names = "fun"))
retn: structure("ANY", .Names = "fun", package = character(0), class = structure("signature", package = "methods"))

func: quote(setDataPart)
body: function (object, value, check = TRUE) 
body: {
body:     if (check || identical(typeof(object), "S4")) {
body:         classDef <- getClass(class(object))
body:         slots <- getSlots(classDef)
body:         dataSlot <- .dataSlot(names(slots))
body:         if (length(dataSlot) == 1) 
body:             dataClass <- elNamed(slots, dataSlot)
body:         else if (check) 
body:             stop(gettextf("class %s does not have a data part (a .Data slot) defined", dQuote(class(object))), domain = NA)
body:         else return(.mergeAttrs(value, object))
body:         value <- as(value, dataClass)
body:         if (identical(typeof(object), "S4")) {
body:             if (is.null(value)) 
body:                 value <- .pseudoNULL
body:             attr(object, dataSlot) <- value
body:             return(object)
body:         }
body:     }
body:     .mergeAttrs(value, object)
body: }
args: list(structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), structure("ANY", .Names = "from"))
retn: structure("ANY", .Names = "from", package = character(0), class = structure("signature", package = "methods"))

func: quote(setDataPart)
body: function (object, value, check = TRUE) 
body: {
body:     if (check || identical(typeof(object), "S4")) {
body:         classDef <- getClass(class(object))
body:         slots <- getSlots(classDef)
body:         dataSlot <- .dataSlot(names(slots))
body:         if (length(dataSlot) == 1) 
body:             dataClass <- elNamed(slots, dataSlot)
body:         else if (check) 
body:             stop(gettextf("class %s does not have a data part (a .Data slot) defined", dQuote(class(object))), domain = NA)
body:         else return(.mergeAttrs(value, object))
body:         value <- as(value, dataClass)
body:         if (identical(typeof(object), "S4")) {
body:             if (is.null(value)) 
body:                 value <- .pseudoNULL
body:             attr(object, dataSlot) <- value
body:             return(object)
body:         }
body:     }
body:     .mergeAttrs(value, object)
body: }
args: list(structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), structure("ANY", .Names = ".Object"))
retn: structure("ANY", .Names = ".Object", package = character(0), class = structure("signature", package = "methods"))

func: quote(setDataPart)
body: function (object, value, check = TRUE) 
body: {
body:     if (check || identical(typeof(object), "S4")) {
body:         classDef <- getClass(class(object))
body:         slots <- getSlots(classDef)
body:         dataSlot <- .dataSlot(names(slots))
body:         if (length(dataSlot) == 1) 
body:             dataClass <- elNamed(slots, dataSlot)
body:         else if (check) 
body:             stop(gettextf("class %s does not have a data part (a .Data slot) defined", dQuote(class(object))), domain = NA)
body:         else return(.mergeAttrs(value, object))
body:         value <- as(value, dataClass)
body:         if (identical(typeof(object), "S4")) {
body:             if (is.null(value)) 
body:                 value <- .pseudoNULL
body:             attr(object, dataSlot) <- value
body:             return(object)
body:         }
body:     }
body:     .mergeAttrs(value, object)
body: }
args: list(structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), structure("ANY", .Names = "X"))
retn: structure("ANY", .Names = "X", package = character(0), class = structure("signature", package = "methods"))

func: quote(setDataPart)
body: function (object, value, check = TRUE) 
body: {
body:     if (check || identical(typeof(object), "S4")) {
body:         classDef <- getClass(class(object))
body:         slots <- getSlots(classDef)
body:         dataSlot <- .dataSlot(names(slots))
body:         if (length(dataSlot) == 1) 
body:             dataClass <- elNamed(slots, dataSlot)
body:         else if (check) 
body:             stop(gettextf("class %s does not have a data part (a .Data slot) defined", dQuote(class(object))), domain = NA)
body:         else return(.mergeAttrs(value, object))
body:         value <- as(value, dataClass)
body:         if (identical(typeof(object), "S4")) {
body:             if (is.null(value)) 
body:                 value <- .pseudoNULL
body:             attr(object, dataSlot) <- value
body:             return(object)
body:         }
body:     }
body:     .mergeAttrs(value, object)
body: }
args: list(structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), structure("ANY", .Names = "object"))
retn: structure("ANY", .Names = "object", package = character(0), class = structure("signature", package = "methods"))

func: quote(setDataPart)
body: function (object, value, check = TRUE) 
body: {
body:     if (check || identical(typeof(object), "S4")) {
body:         classDef <- getClass(class(object))
body:         slots <- getSlots(classDef)
body:         dataSlot <- .dataSlot(names(slots))
body:         if (length(dataSlot) == 1) 
body:             dataClass <- elNamed(slots, dataSlot)
body:         else if (check) 
body:             stop(gettextf("class %s does not have a data part (a .Data slot) defined", dQuote(class(object))), domain = NA)
body:         else return(.mergeAttrs(value, object))
body:         value <- as(value, dataClass)
body:         if (identical(typeof(object), "S4")) {
body:             if (is.null(value)) 
body:                 value <- .pseudoNULL
body:             attr(object, dataSlot) <- value
body:             return(object)
body:         }
body:     }
body:     .mergeAttrs(value, object)
body: }
args: list(structure(function () 
args: NULL, target = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), defined = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), generic = character(0), class = structure("derivedDefaultMethod", package = "methods")), function (object, ..., k = 2) 
args: UseMethod("AIC"))
retn: structure(function (object, ..., k = 2) 
retn: UseMethod("AIC"), target = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), defined = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), generic = character(0), class = structure("derivedDefaultMethod", package = "methods"))

func: quote(setDataPart)
body: function (object, value, check = TRUE) 
body: {
body:     if (check || identical(typeof(object), "S4")) {
body:         classDef <- getClass(class(object))
body:         slots <- getSlots(classDef)
body:         dataSlot <- .dataSlot(names(slots))
body:         if (length(dataSlot) == 1) 
body:             dataClass <- elNamed(slots, dataSlot)
body:         else if (check) 
body:             stop(gettextf("class %s does not have a data part (a .Data slot) defined", dQuote(class(object))), domain = NA)
body:         else return(.mergeAttrs(value, object))
body:         value <- as(value, dataClass)
body:         if (identical(typeof(object), "S4")) {
body:             if (is.null(value)) 
body:                 value <- .pseudoNULL
body:             attr(object, dataSlot) <- value
body:             return(object)
body:         }
body:     }
body:     .mergeAttrs(value, object)
body: }
args: list(structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), c("derivedDefaultMethod", "function"))
retn: structure(c("derivedDefaultMethod", "function"), .Names = c(NA_character_, NA_character_), package = character(0), class = structure("signature", package = "methods"))

func: quote(setDataPart)
body: function (object, value, check = TRUE) 
body: {
body:     if (check || identical(typeof(object), "S4")) {
body:         classDef <- getClass(class(object))
body:         slots <- getSlots(classDef)
body:         dataSlot <- .dataSlot(names(slots))
body:         if (length(dataSlot) == 1) 
body:             dataClass <- elNamed(slots, dataSlot)
body:         else if (check) 
body:             stop(gettextf("class %s does not have a data part (a .Data slot) defined", dQuote(class(object))), domain = NA)
body:         else return(.mergeAttrs(value, object))
body:         value <- as(value, dataClass)
body:         if (identical(typeof(object), "S4")) {
body:             if (is.null(value)) 
body:                 value <- .pseudoNULL
body:             attr(object, dataSlot) <- value
body:             return(object)
body:         }
body:     }
body:     .mergeAttrs(value, object)
body: }
args: list(structure(function () 
args: NULL, target = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), defined = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), generic = character(0), class = structure("MethodDefinition", package = "methods")), function (from, to = "function", strict = TRUE) 
args: if (strict) {
args:     from <- {
args:         class(from) <- "MethodDefinition"
args:         from
args:     }
args:     if (strict) from@.Data
args: } else from)
retn: structure(function (from, to = "function", strict = TRUE) 
retn: if (strict) {
retn:     from <- {
retn:         class(from) <- "MethodDefinition"
retn:         from
retn:     }
retn:     if (strict) 
retn:         from@.Data
retn: } else from, target = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), defined = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), generic = character(0), class = structure("MethodDefinition", package = "methods"))

func: quote(setDataPart)
body: function (object, value, check = TRUE) 
body: {
body:     if (check || identical(typeof(object), "S4")) {
body:         classDef <- getClass(class(object))
body:         slots <- getSlots(classDef)
body:         dataSlot <- .dataSlot(names(slots))
body:         if (length(dataSlot) == 1) 
body:             dataClass <- elNamed(slots, dataSlot)
body:         else if (check) 
body:             stop(gettextf("class %s does not have a data part (a .Data slot) defined", dQuote(class(object))), domain = NA)
body:         else return(.mergeAttrs(value, object))
body:         value <- as(value, dataClass)
body:         if (identical(typeof(object), "S4")) {
body:             if (is.null(value)) 
body:                 value <- .pseudoNULL
body:             attr(object, dataSlot) <- value
body:             return(object)
body:         }
body:     }
body:     .mergeAttrs(value, object)
body: }
args: list(structure(function (object, ..., k = 2) 
args: UseMethod("AIC"), target = structure("ANY", class = structure("signature", package = "methods"), .Names = "object", package = "methods"), defined = structure("ANY", class = structure("signature", package = "methods"), .Names = "object", package = "methods"), generic = character(0), class = structure("derivedDefaultMethod", package = "methods")), function (object, ..., k = 2) 
args: standardGeneric("AIC"))
retn: structure(function (object, ..., k = 2) 
retn: standardGeneric("AIC"), target = structure("ANY", class = structure("signature", package = "methods"), .Names = "object", package = "methods"), defined = structure("ANY", class = structure("signature", package = "methods"), .Names = "object", package = "methods"), generic = character(0), class = structure("derivedDefaultMethod", package = "methods"))

func: quote(setDataPart)
body: function (object, value, check = TRUE) 
body: {
body:     if (check || identical(typeof(object), "S4")) {
body:         classDef <- getClass(class(object))
body:         slots <- getSlots(classDef)
body:         dataSlot <- .dataSlot(names(slots))
body:         if (length(dataSlot) == 1) 
body:             dataClass <- elNamed(slots, dataSlot)
body:         else if (check) 
body:             stop(gettextf("class %s does not have a data part (a .Data slot) defined", dQuote(class(object))), domain = NA)
body:         else return(.mergeAttrs(value, object))
body:         value <- as(value, dataClass)
body:         if (identical(typeof(object), "S4")) {
body:             if (is.null(value)) 
body:                 value <- .pseudoNULL
body:             attr(object, dataSlot) <- value
body:             return(object)
body:         }
body:     }
body:     .mergeAttrs(value, object)
body: }
args: list(structure(function () 
args: NULL, generic = character(0), package = character(0), group = list(), valueClass = character(0), signature = character(0), default = quote(`\001NULL\001`), skeleton = quote(`<undef>`()), class = structure("standardGeneric", package = "methods")), structure(function (object, ..., k = 2) 
args: standardGeneric("AIC"), target = structure("ANY", class = structure("signature", package = "methods"), .Names = "object", package = "methods"), defined = structure("ANY", class = structure("signature", package = "methods"), .Names = "object", package = "methods"), generic = character(0), class = structure("derivedDefaultMethod", package = "methods")))
retn: structure(function (object, ..., k = 2) 
retn: standardGeneric("AIC"), generic = character(0), package = character(0), group = list(), valueClass = character(0), signature = character(0), default = quote(`\001NULL\001`), skeleton = quote(`<undef>`()), class = structure("standardGeneric", package = "methods"))

func: quote(setDataPart)
body: function (object, value, check = TRUE) 
body: {
body:     if (check || identical(typeof(object), "S4")) {
body:         classDef <- getClass(class(object))
body:         slots <- getSlots(classDef)
body:         dataSlot <- .dataSlot(names(slots))
body:         if (length(dataSlot) == 1) 
body:             dataClass <- elNamed(slots, dataSlot)
body:         else if (check) 
body:             stop(gettextf("class %s does not have a data part (a .Data slot) defined", dQuote(class(object))), domain = NA)
body:         else return(.mergeAttrs(value, object))
body:         value <- as(value, dataClass)
body:         if (identical(typeof(object), "S4")) {
body:             if (is.null(value)) 
body:                 value <- .pseudoNULL
body:             attr(object, dataSlot) <- value
body:             return(object)
body:         }
body:     }
body:     .mergeAttrs(value, object)
body: }
args: list(structure(function () 
args: NULL, target = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), defined = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), generic = character(0), class = structure("derivedDefaultMethod", package = "methods")), function (object, ...) 
args: UseMethod("BIC"))
retn: structure(function (object, ...) 
retn: UseMethod("BIC"), target = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), defined = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), generic = character(0), class = structure("derivedDefaultMethod", package = "methods"))

func: quote(setDataPart)
body: function (object, value, check = TRUE) 
body: {
body:     if (check || identical(typeof(object), "S4")) {
body:         classDef <- getClass(class(object))
body:         slots <- getSlots(classDef)
body:         dataSlot <- .dataSlot(names(slots))
body:         if (length(dataSlot) == 1) 
body:             dataClass <- elNamed(slots, dataSlot)
body:         else if (check) 
body:             stop(gettextf("class %s does not have a data part (a .Data slot) defined", dQuote(class(object))), domain = NA)
body:         else return(.mergeAttrs(value, object))
body:         value <- as(value, dataClass)
body:         if (identical(typeof(object), "S4")) {
body:             if (is.null(value)) 
body:                 value <- .pseudoNULL
body:             attr(object, dataSlot) <- value
body:             return(object)
body:         }
body:     }
body:     .mergeAttrs(value, object)
body: }
args: list(structure(function (object, ...) 
args: UseMethod("BIC"), target = structure("ANY", class = structure("signature", package = "methods"), .Names = "object", package = "methods"), defined = structure("ANY", class = structure("signature", package = "methods"), .Names = "object", package = "methods"), generic = character(0), class = structure("derivedDefaultMethod", package = "methods")), function (object, ...) 
args: standardGeneric("BIC"))
retn: structure(function (object, ...) 
retn: standardGeneric("BIC"), target = structure("ANY", class = structure("signature", package = "methods"), .Names = "object", package = "methods"), defined = structure("ANY", class = structure("signature", package = "methods"), .Names = "object", package = "methods"), generic = character(0), class = structure("derivedDefaultMethod", package = "methods"))

func: quote(setDataPart)
body: function (object, value, check = TRUE) 
body: {
body:     if (check || identical(typeof(object), "S4")) {
body:         classDef <- getClass(class(object))
body:         slots <- getSlots(classDef)
body:         dataSlot <- .dataSlot(names(slots))
body:         if (length(dataSlot) == 1) 
body:             dataClass <- elNamed(slots, dataSlot)
body:         else if (check) 
body:             stop(gettextf("class %s does not have a data part (a .Data slot) defined", dQuote(class(object))), domain = NA)
body:         else return(.mergeAttrs(value, object))
body:         value <- as(value, dataClass)
body:         if (identical(typeof(object), "S4")) {
body:             if (is.null(value)) 
body:                 value <- .pseudoNULL
body:             attr(object, dataSlot) <- value
body:             return(object)
body:         }
body:     }
body:     .mergeAttrs(value, object)
body: }
args: list(structure(function () 
args: NULL, generic = character(0), package = character(0), group = list(), valueClass = character(0), signature = character(0), default = quote(`\001NULL\001`), skeleton = quote(`<undef>`()), class = structure("standardGeneric", package = "methods")), structure(function (object, ...) 
args: standardGeneric("BIC"), target = structure("ANY", class = structure("signature", package = "methods"), .Names = "object", package = "methods"), defined = structure("ANY", class = structure("signature", package = "methods"), .Names = "object", package = "methods"), generic = character(0), class = structure("derivedDefaultMethod", package = "methods")))
retn: structure(function (object, ...) 
retn: standardGeneric("BIC"), generic = character(0), package = character(0), group = list(), valueClass = character(0), signature = character(0), default = quote(`\001NULL\001`), skeleton = quote(`<undef>`()), class = structure("standardGeneric", package = "methods"))

func: quote(setDataPart)
body: function (object, value, check = TRUE) 
body: {
body:     if (check || identical(typeof(object), "S4")) {
body:         classDef <- getClass(class(object))
body:         slots <- getSlots(classDef)
body:         dataSlot <- .dataSlot(names(slots))
body:         if (length(dataSlot) == 1) 
body:             dataClass <- elNamed(slots, dataSlot)
body:         else if (check) 
body:             stop(gettextf("class %s does not have a data part (a .Data slot) defined", dQuote(class(object))), domain = NA)
body:         else return(.mergeAttrs(value, object))
body:         value <- as(value, dataClass)
body:         if (identical(typeof(object), "S4")) {
body:             if (is.null(value)) 
body:                 value <- .pseudoNULL
body:             attr(object, dataSlot) <- value
body:             return(object)
body:         }
body:     }
body:     .mergeAttrs(value, object)
body: }
args: list(structure(function () 
args: NULL, target = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), defined = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), generic = character(0), class = structure("derivedDefaultMethod", package = "methods")), function (object, ...) 
args: UseMethod("coef"))
retn: structure(function (object, ...) 
retn: UseMethod("coef"), target = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), defined = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), generic = character(0), class = structure("derivedDefaultMethod", package = "methods"))

func: quote(setDataPart)
body: function (object, value, check = TRUE) 
body: {
body:     if (check || identical(typeof(object), "S4")) {
body:         classDef <- getClass(class(object))
body:         slots <- getSlots(classDef)
body:         dataSlot <- .dataSlot(names(slots))
body:         if (length(dataSlot) == 1) 
body:             dataClass <- elNamed(slots, dataSlot)
body:         else if (check) 
body:             stop(gettextf("class %s does not have a data part (a .Data slot) defined", dQuote(class(object))), domain = NA)
body:         else return(.mergeAttrs(value, object))
body:         value <- as(value, dataClass)
body:         if (identical(typeof(object), "S4")) {
body:             if (is.null(value)) 
body:                 value <- .pseudoNULL
body:             attr(object, dataSlot) <- value
body:             return(object)
body:         }
body:     }
body:     .mergeAttrs(value, object)
body: }
args: list(structure(function (object, ...) 
args: UseMethod("coef"), target = structure("ANY", class = structure("signature", package = "methods"), .Names = "object", package = "methods"), defined = structure("ANY", class = structure("signature", package = "methods"), .Names = "object", package = "methods"), generic = character(0), class = structure("derivedDefaultMethod", package = "methods")), function (object, ...) 
args: standardGeneric("coef"))
retn: structure(function (object, ...) 
retn: standardGeneric("coef"), target = structure("ANY", class = structure("signature", package = "methods"), .Names = "object", package = "methods"), defined = structure("ANY", class = structure("signature", package = "methods"), .Names = "object", package = "methods"), generic = character(0), class = structure("derivedDefaultMethod", package = "methods"))

func: quote(setDataPart)
body: function (object, value, check = TRUE) 
body: {
body:     if (check || identical(typeof(object), "S4")) {
body:         classDef <- getClass(class(object))
body:         slots <- getSlots(classDef)
body:         dataSlot <- .dataSlot(names(slots))
body:         if (length(dataSlot) == 1) 
body:             dataClass <- elNamed(slots, dataSlot)
body:         else if (check) 
body:             stop(gettextf("class %s does not have a data part (a .Data slot) defined", dQuote(class(object))), domain = NA)
body:         else return(.mergeAttrs(value, object))
body:         value <- as(value, dataClass)
body:         if (identical(typeof(object), "S4")) {
body:             if (is.null(value)) 
body:                 value <- .pseudoNULL
body:             attr(object, dataSlot) <- value
body:             return(object)
body:         }
body:     }
body:     .mergeAttrs(value, object)
body: }
args: list(structure(function () 
args: NULL, generic = character(0), package = character(0), group = list(), valueClass = character(0), signature = character(0), default = quote(`\001NULL\001`), skeleton = quote(`<undef>`()), class = structure("standardGeneric", package = "methods")), structure(function (object, ...) 
args: standardGeneric("coef"), target = structure("ANY", class = structure("signature", package = "methods"), .Names = "object", package = "methods"), defined = structure("ANY", class = structure("signature", package = "methods"), .Names = "object", package = "methods"), generic = character(0), class = structure("derivedDefaultMethod", package = "methods")))
retn: structure(function (object, ...) 
retn: standardGeneric("coef"), generic = character(0), package = character(0), group = list(), valueClass = character(0), signature = character(0), default = quote(`\001NULL\001`), skeleton = quote(`<undef>`()), class = structure("standardGeneric", package = "methods"))

func: quote(setDataPart)
body: function (object, value, check = TRUE) 
body: {
body:     if (check || identical(typeof(object), "S4")) {
body:         classDef <- getClass(class(object))
body:         slots <- getSlots(classDef)
body:         dataSlot <- .dataSlot(names(slots))
body:         if (length(dataSlot) == 1) 
body:             dataClass <- elNamed(slots, dataSlot)
body:         else if (check) 
body:             stop(gettextf("class %s does not have a data part (a .Data slot) defined", dQuote(class(object))), domain = NA)
body:         else return(.mergeAttrs(value, object))
body:         value <- as(value, dataClass)
body:         if (identical(typeof(object), "S4")) {
body:             if (is.null(value)) 
body:                 value <- .pseudoNULL
body:             attr(object, dataSlot) <- value
body:             return(object)
body:         }
body:     }
body:     .mergeAttrs(value, object)
body: }
args: list(structure(function () 
args: NULL, target = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), defined = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), generic = character(0), class = structure("derivedDefaultMethod", package = "methods")), function (object, parm, level = 0.95, ...) 
args: UseMethod("confint"))
retn: structure(function (object, parm, level = 0.95, ...) 
retn: UseMethod("confint"), target = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), defined = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), generic = character(0), class = structure("derivedDefaultMethod", package = "methods"))

func: quote(setDataPart)
body: function (object, value, check = TRUE) 
body: {
body:     if (check || identical(typeof(object), "S4")) {
body:         classDef <- getClass(class(object))
body:         slots <- getSlots(classDef)
body:         dataSlot <- .dataSlot(names(slots))
body:         if (length(dataSlot) == 1) 
body:             dataClass <- elNamed(slots, dataSlot)
body:         else if (check) 
body:             stop(gettextf("class %s does not have a data part (a .Data slot) defined", dQuote(class(object))), domain = NA)
body:         else return(.mergeAttrs(value, object))
body:         value <- as(value, dataClass)
body:         if (identical(typeof(object), "S4")) {
body:             if (is.null(value)) 
body:                 value <- .pseudoNULL
body:             attr(object, dataSlot) <- value
body:             return(object)
body:         }
body:     }
body:     .mergeAttrs(value, object)
body: }
args: list(structure(function (object, parm, level = 0.95, ...) 
args: UseMethod("confint"), target = structure("ANY", class = structure("signature", package = "methods"), .Names = "object", package = "methods"), defined = structure("ANY", class = structure("signature", package = "methods"), .Names = "object", package = "methods"), generic = character(0), class = structure("derivedDefaultMethod", package = "methods")), function (object, parm, level = 0.95, ...) 
args: standardGeneric("confint"))
retn: structure(function (object, parm, level = 0.95, ...) 
retn: standardGeneric("confint"), target = structure("ANY", class = structure("signature", package = "methods"), .Names = "object", package = "methods"), defined = structure("ANY", class = structure("signature", package = "methods"), .Names = "object", package = "methods"), generic = character(0), class = structure("derivedDefaultMethod", package = "methods"))

func: quote(setDataPart)
body: function (object, value, check = TRUE) 
body: {
body:     if (check || identical(typeof(object), "S4")) {
body:         classDef <- getClass(class(object))
body:         slots <- getSlots(classDef)
body:         dataSlot <- .dataSlot(names(slots))
body:         if (length(dataSlot) == 1) 
body:             dataClass <- elNamed(slots, dataSlot)
body:         else if (check) 
body:             stop(gettextf("class %s does not have a data part (a .Data slot) defined", dQuote(class(object))), domain = NA)
body:         else return(.mergeAttrs(value, object))
body:         value <- as(value, dataClass)
body:         if (identical(typeof(object), "S4")) {
body:             if (is.null(value)) 
body:                 value <- .pseudoNULL
body:             attr(object, dataSlot) <- value
body:             return(object)
body:         }
body:     }
body:     .mergeAttrs(value, object)
body: }
args: list(structure(function () 
args: NULL, generic = character(0), package = character(0), group = list(), valueClass = character(0), signature = character(0), default = quote(`\001NULL\001`), skeleton = quote(`<undef>`()), class = structure("standardGeneric", package = "methods")), structure(function (object, parm, level = 0.95, ...) 
args: standardGeneric("confint"), target = structure("ANY", class = structure("signature", package = "methods"), .Names = "object", package = "methods"), defined = structure("ANY", class = structure("signature", package = "methods"), .Names = "object", package = "methods"), generic = character(0), class = structure("derivedDefaultMethod", package = "methods")))
retn: structure(function (object, parm, level = 0.95, ...) 
retn: standardGeneric("confint"), generic = character(0), package = character(0), group = list(), valueClass = character(0), signature = character(0), default = quote(`\001NULL\001`), skeleton = quote(`<undef>`()), class = structure("standardGeneric", package = "methods"))

func: quote(setDataPart)
body: function (object, value, check = TRUE) 
body: {
body:     if (check || identical(typeof(object), "S4")) {
body:         classDef <- getClass(class(object))
body:         slots <- getSlots(classDef)
body:         dataSlot <- .dataSlot(names(slots))
body:         if (length(dataSlot) == 1) 
body:             dataClass <- elNamed(slots, dataSlot)
body:         else if (check) 
body:             stop(gettextf("class %s does not have a data part (a .Data slot) defined", dQuote(class(object))), domain = NA)
body:         else return(.mergeAttrs(value, object))
body:         value <- as(value, dataClass)
body:         if (identical(typeof(object), "S4")) {
body:             if (is.null(value)) 
body:                 value <- .pseudoNULL
body:             attr(object, dataSlot) <- value
body:             return(object)
body:         }
body:     }
body:     .mergeAttrs(value, object)
body: }
args: list(structure(function () 
args: NULL, target = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), defined = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), generic = character(0), class = structure("derivedDefaultMethod", package = "methods")), function (object, ...) 
args: UseMethod("logLik"))
retn: structure(function (object, ...) 
retn: UseMethod("logLik"), target = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), defined = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), generic = character(0), class = structure("derivedDefaultMethod", package = "methods"))

func: quote(setDataPart)
body: function (object, value, check = TRUE) 
body: {
body:     if (check || identical(typeof(object), "S4")) {
body:         classDef <- getClass(class(object))
body:         slots <- getSlots(classDef)
body:         dataSlot <- .dataSlot(names(slots))
body:         if (length(dataSlot) == 1) 
body:             dataClass <- elNamed(slots, dataSlot)
body:         else if (check) 
body:             stop(gettextf("class %s does not have a data part (a .Data slot) defined", dQuote(class(object))), domain = NA)
body:         else return(.mergeAttrs(value, object))
body:         value <- as(value, dataClass)
body:         if (identical(typeof(object), "S4")) {
body:             if (is.null(value)) 
body:                 value <- .pseudoNULL
body:             attr(object, dataSlot) <- value
body:             return(object)
body:         }
body:     }
body:     .mergeAttrs(value, object)
body: }
args: list(structure(function (object, ...) 
args: UseMethod("logLik"), target = structure("ANY", class = structure("signature", package = "methods"), .Names = "object", package = "methods"), defined = structure("ANY", class = structure("signature", package = "methods"), .Names = "object", package = "methods"), generic = character(0), class = structure("derivedDefaultMethod", package = "methods")), function (object, ...) 
args: standardGeneric("logLik"))
retn: structure(function (object, ...) 
retn: standardGeneric("logLik"), target = structure("ANY", class = structure("signature", package = "methods"), .Names = "object", package = "methods"), defined = structure("ANY", class = structure("signature", package = "methods"), .Names = "object", package = "methods"), generic = character(0), class = structure("derivedDefaultMethod", package = "methods"))

func: quote(setDataPart)
body: function (object, value, check = TRUE) 
body: {
body:     if (check || identical(typeof(object), "S4")) {
body:         classDef <- getClass(class(object))
body:         slots <- getSlots(classDef)
body:         dataSlot <- .dataSlot(names(slots))
body:         if (length(dataSlot) == 1) 
body:             dataClass <- elNamed(slots, dataSlot)
body:         else if (check) 
body:             stop(gettextf("class %s does not have a data part (a .Data slot) defined", dQuote(class(object))), domain = NA)
body:         else return(.mergeAttrs(value, object))
body:         value <- as(value, dataClass)
body:         if (identical(typeof(object), "S4")) {
body:             if (is.null(value)) 
body:                 value <- .pseudoNULL
body:             attr(object, dataSlot) <- value
body:             return(object)
body:         }
body:     }
body:     .mergeAttrs(value, object)
body: }
args: list(structure(function () 
args: NULL, generic = character(0), package = character(0), group = list(), valueClass = character(0), signature = character(0), default = quote(`\001NULL\001`), skeleton = quote(`<undef>`()), class = structure("standardGeneric", package = "methods")), structure(function (object, ...) 
args: standardGeneric("logLik"), target = structure("ANY", class = structure("signature", package = "methods"), .Names = "object", package = "methods"), defined = structure("ANY", class = structure("signature", package = "methods"), .Names = "object", package = "methods"), generic = character(0), class = structure("derivedDefaultMethod", package = "methods")))
retn: structure(function (object, ...) 
retn: standardGeneric("logLik"), generic = character(0), package = character(0), group = list(), valueClass = character(0), signature = character(0), default = quote(`\001NULL\001`), skeleton = quote(`<undef>`()), class = structure("standardGeneric", package = "methods"))

func: quote(setDataPart)
body: function (object, value, check = TRUE) 
body: {
body:     if (check || identical(typeof(object), "S4")) {
body:         classDef <- getClass(class(object))
body:         slots <- getSlots(classDef)
body:         dataSlot <- .dataSlot(names(slots))
body:         if (length(dataSlot) == 1) 
body:             dataClass <- elNamed(slots, dataSlot)
body:         else if (check) 
body:             stop(gettextf("class %s does not have a data part (a .Data slot) defined", dQuote(class(object))), domain = NA)
body:         else return(.mergeAttrs(value, object))
body:         value <- as(value, dataClass)
body:         if (identical(typeof(object), "S4")) {
body:             if (is.null(value)) 
body:                 value <- .pseudoNULL
body:             attr(object, dataSlot) <- value
body:             return(object)
body:         }
body:     }
body:     .mergeAttrs(value, object)
body: }
args: list(structure(function () 
args: NULL, target = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), defined = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), generic = character(0), class = structure("derivedDefaultMethod", package = "methods")), function (object, ...) 
args: UseMethod("nobs"))
retn: structure(function (object, ...) 
retn: UseMethod("nobs"), target = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), defined = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), generic = character(0), class = structure("derivedDefaultMethod", package = "methods"))

func: quote(setDataPart)
body: function (object, value, check = TRUE) 
body: {
body:     if (check || identical(typeof(object), "S4")) {
body:         classDef <- getClass(class(object))
body:         slots <- getSlots(classDef)
body:         dataSlot <- .dataSlot(names(slots))
body:         if (length(dataSlot) == 1) 
body:             dataClass <- elNamed(slots, dataSlot)
body:         else if (check) 
body:             stop(gettextf("class %s does not have a data part (a .Data slot) defined", dQuote(class(object))), domain = NA)
body:         else return(.mergeAttrs(value, object))
body:         value <- as(value, dataClass)
body:         if (identical(typeof(object), "S4")) {
body:             if (is.null(value)) 
body:                 value <- .pseudoNULL
body:             attr(object, dataSlot) <- value
body:             return(object)
body:         }
body:     }
body:     .mergeAttrs(value, object)
body: }
args: list(structure(function (object, ...) 
args: UseMethod("nobs"), target = structure("ANY", class = structure("signature", package = "methods"), .Names = "object", package = "methods"), defined = structure("ANY", class = structure("signature", package = "methods"), .Names = "object", package = "methods"), generic = character(0), class = structure("derivedDefaultMethod", package = "methods")), function (object, ...) 
args: standardGeneric("nobs"))
retn: structure(function (object, ...) 
retn: standardGeneric("nobs"), target = structure("ANY", class = structure("signature", package = "methods"), .Names = "object", package = "methods"), defined = structure("ANY", class = structure("signature", package = "methods"), .Names = "object", package = "methods"), generic = character(0), class = structure("derivedDefaultMethod", package = "methods"))

func: quote(setDataPart)
body: function (object, value, check = TRUE) 
body: {
body:     if (check || identical(typeof(object), "S4")) {
body:         classDef <- getClass(class(object))
body:         slots <- getSlots(classDef)
body:         dataSlot <- .dataSlot(names(slots))
body:         if (length(dataSlot) == 1) 
body:             dataClass <- elNamed(slots, dataSlot)
body:         else if (check) 
body:             stop(gettextf("class %s does not have a data part (a .Data slot) defined", dQuote(class(object))), domain = NA)
body:         else return(.mergeAttrs(value, object))
body:         value <- as(value, dataClass)
body:         if (identical(typeof(object), "S4")) {
body:             if (is.null(value)) 
body:                 value <- .pseudoNULL
body:             attr(object, dataSlot) <- value
body:             return(object)
body:         }
body:     }
body:     .mergeAttrs(value, object)
body: }
args: list(structure(function () 
args: NULL, generic = character(0), package = character(0), group = list(), valueClass = character(0), signature = character(0), default = quote(`\001NULL\001`), skeleton = quote(`<undef>`()), class = structure("standardGeneric", package = "methods")), structure(function (object, ...) 
args: standardGeneric("nobs"), target = structure("ANY", class = structure("signature", package = "methods"), .Names = "object", package = "methods"), defined = structure("ANY", class = structure("signature", package = "methods"), .Names = "object", package = "methods"), generic = character(0), class = structure("derivedDefaultMethod", package = "methods")))
retn: structure(function (object, ...) 
retn: standardGeneric("nobs"), generic = character(0), package = character(0), group = list(), valueClass = character(0), signature = character(0), default = quote(`\001NULL\001`), skeleton = quote(`<undef>`()), class = structure("standardGeneric", package = "methods"))

func: quote(setDataPart)
body: function (object, value, check = TRUE) 
body: {
body:     if (check || identical(typeof(object), "S4")) {
body:         classDef <- getClass(class(object))
body:         slots <- getSlots(classDef)
body:         dataSlot <- .dataSlot(names(slots))
body:         if (length(dataSlot) == 1) 
body:             dataClass <- elNamed(slots, dataSlot)
body:         else if (check) 
body:             stop(gettextf("class %s does not have a data part (a .Data slot) defined", dQuote(class(object))), domain = NA)
body:         else return(.mergeAttrs(value, object))
body:         value <- as(value, dataClass)
body:         if (identical(typeof(object), "S4")) {
body:             if (is.null(value)) 
body:                 value <- .pseudoNULL
body:             attr(object, dataSlot) <- value
body:             return(object)
body:         }
body:     }
body:     .mergeAttrs(value, object)
body: }
args: list(structure(function () 
args: NULL, target = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), defined = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), generic = character(0), class = structure("derivedDefaultMethod", package = "methods")), function (x, y, ...) 
args: UseMethod("plot"))
retn: structure(function (x, y, ...) 
retn: UseMethod("plot"), target = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), defined = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), generic = character(0), class = structure("derivedDefaultMethod", package = "methods"))

func: quote(setDataPart)
body: function (object, value, check = TRUE) 
body: {
body:     if (check || identical(typeof(object), "S4")) {
body:         classDef <- getClass(class(object))
body:         slots <- getSlots(classDef)
body:         dataSlot <- .dataSlot(names(slots))
body:         if (length(dataSlot) == 1) 
body:             dataClass <- elNamed(slots, dataSlot)
body:         else if (check) 
body:             stop(gettextf("class %s does not have a data part (a .Data slot) defined", dQuote(class(object))), domain = NA)
body:         else return(.mergeAttrs(value, object))
body:         value <- as(value, dataClass)
body:         if (identical(typeof(object), "S4")) {
body:             if (is.null(value)) 
body:                 value <- .pseudoNULL
body:             attr(object, dataSlot) <- value
body:             return(object)
body:         }
body:     }
body:     .mergeAttrs(value, object)
body: }
args: list(structure(function (x, y, ...) 
args: UseMethod("plot"), target = structure("ANY", class = structure("signature", package = "methods"), .Names = "x", package = "methods"), defined = structure("ANY", class = structure("signature", package = "methods"), .Names = "x", package = "methods"), generic = character(0), class = structure("derivedDefaultMethod", package = "methods")), function (x, y, ...) 
args: standardGeneric("plot"))
retn: structure(function (x, y, ...) 
retn: standardGeneric("plot"), target = structure("ANY", class = structure("signature", package = "methods"), .Names = "x", package = "methods"), defined = structure("ANY", class = structure("signature", package = "methods"), .Names = "x", package = "methods"), generic = character(0), class = structure("derivedDefaultMethod", package = "methods"))

func: quote(setDataPart)
body: function (object, value, check = TRUE) 
body: {
body:     if (check || identical(typeof(object), "S4")) {
body:         classDef <- getClass(class(object))
body:         slots <- getSlots(classDef)
body:         dataSlot <- .dataSlot(names(slots))
body:         if (length(dataSlot) == 1) 
body:             dataClass <- elNamed(slots, dataSlot)
body:         else if (check) 
body:             stop(gettextf("class %s does not have a data part (a .Data slot) defined", dQuote(class(object))), domain = NA)
body:         else return(.mergeAttrs(value, object))
body:         value <- as(value, dataClass)
body:         if (identical(typeof(object), "S4")) {
body:             if (is.null(value)) 
body:                 value <- .pseudoNULL
body:             attr(object, dataSlot) <- value
body:             return(object)
body:         }
body:     }
body:     .mergeAttrs(value, object)
body: }
args: list(structure(function () 
args: NULL, generic = character(0), package = character(0), group = list(), valueClass = character(0), signature = character(0), default = quote(`\001NULL\001`), skeleton = quote(`<undef>`()), class = structure("standardGeneric", package = "methods")), structure(function (x, y, ...) 
args: standardGeneric("plot"), target = structure("ANY", class = structure("signature", package = "methods"), .Names = "x", package = "methods"), defined = structure("ANY", class = structure("signature", package = "methods"), .Names = "x", package = "methods"), generic = character(0), class = structure("derivedDefaultMethod", package = "methods")))
retn: structure(function (x, y, ...) 
retn: standardGeneric("plot"), generic = character(0), package = character(0), group = list(), valueClass = character(0), signature = character(0), default = quote(`\001NULL\001`), skeleton = quote(`<undef>`()), class = structure("standardGeneric", package = "methods"))

func: quote(setDataPart)
body: function (object, value, check = TRUE) 
body: {
body:     if (check || identical(typeof(object), "S4")) {
body:         classDef <- getClass(class(object))
body:         slots <- getSlots(classDef)
body:         dataSlot <- .dataSlot(names(slots))
body:         if (length(dataSlot) == 1) 
body:             dataClass <- elNamed(slots, dataSlot)
body:         else if (check) 
body:             stop(gettextf("class %s does not have a data part (a .Data slot) defined", dQuote(class(object))), domain = NA)
body:         else return(.mergeAttrs(value, object))
body:         value <- as(value, dataClass)
body:         if (identical(typeof(object), "S4")) {
body:             if (is.null(value)) 
body:                 value <- .pseudoNULL
body:             attr(object, dataSlot) <- value
body:             return(object)
body:         }
body:     }
body:     .mergeAttrs(value, object)
body: }
args: list(structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), c("ANY", "ANY"))
retn: structure(c("ANY", "ANY"), .Names = c(NA_character_, NA_character_), package = character(0), class = structure("signature", package = "methods"))

func: quote(setDataPart)
body: function (object, value, check = TRUE) 
body: {
body:     if (check || identical(typeof(object), "S4")) {
body:         classDef <- getClass(class(object))
body:         slots <- getSlots(classDef)
body:         dataSlot <- .dataSlot(names(slots))
body:         if (length(dataSlot) == 1) 
body:             dataClass <- elNamed(slots, dataSlot)
body:         else if (check) 
body:             stop(gettextf("class %s does not have a data part (a .Data slot) defined", dQuote(class(object))), domain = NA)
body:         else return(.mergeAttrs(value, object))
body:         value <- as(value, dataClass)
body:         if (identical(typeof(object), "S4")) {
body:             if (is.null(value)) 
body:                 value <- .pseudoNULL
body:             attr(object, dataSlot) <- value
body:             return(object)
body:         }
body:     }
body:     .mergeAttrs(value, object)
body: }
args: list(structure(function () 
args: NULL, target = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), defined = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), generic = character(0), class = structure("derivedDefaultMethod", package = "methods")), function (fitted, ...) 
args: UseMethod("profile"))
retn: structure(function (fitted, ...) 
retn: UseMethod("profile"), target = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), defined = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), generic = character(0), class = structure("derivedDefaultMethod", package = "methods"))

func: quote(setDataPart)
body: function (object, value, check = TRUE) 
body: {
body:     if (check || identical(typeof(object), "S4")) {
body:         classDef <- getClass(class(object))
body:         slots <- getSlots(classDef)
body:         dataSlot <- .dataSlot(names(slots))
body:         if (length(dataSlot) == 1) 
body:             dataClass <- elNamed(slots, dataSlot)
body:         else if (check) 
body:             stop(gettextf("class %s does not have a data part (a .Data slot) defined", dQuote(class(object))), domain = NA)
body:         else return(.mergeAttrs(value, object))
body:         value <- as(value, dataClass)
body:         if (identical(typeof(object), "S4")) {
body:             if (is.null(value)) 
body:                 value <- .pseudoNULL
body:             attr(object, dataSlot) <- value
body:             return(object)
body:         }
body:     }
body:     .mergeAttrs(value, object)
body: }
args: list(structure(function (fitted, ...) 
args: UseMethod("profile"), target = structure("ANY", class = structure("signature", package = "methods"), .Names = "fitted", package = "methods"), defined = structure("ANY", class = structure("signature", package = "methods"), .Names = "fitted", package = "methods"), generic = character(0), class = structure("derivedDefaultMethod", package = "methods")), function (fitted, ...) 
args: standardGeneric("profile"))
retn: structure(function (fitted, ...) 
retn: standardGeneric("profile"), target = structure("ANY", class = structure("signature", package = "methods"), .Names = "fitted", package = "methods"), defined = structure("ANY", class = structure("signature", package = "methods"), .Names = "fitted", package = "methods"), generic = character(0), class = structure("derivedDefaultMethod", package = "methods"))

func: quote(setDataPart)
body: function (object, value, check = TRUE) 
body: {
body:     if (check || identical(typeof(object), "S4")) {
body:         classDef <- getClass(class(object))
body:         slots <- getSlots(classDef)
body:         dataSlot <- .dataSlot(names(slots))
body:         if (length(dataSlot) == 1) 
body:             dataClass <- elNamed(slots, dataSlot)
body:         else if (check) 
body:             stop(gettextf("class %s does not have a data part (a .Data slot) defined", dQuote(class(object))), domain = NA)
body:         else return(.mergeAttrs(value, object))
body:         value <- as(value, dataClass)
body:         if (identical(typeof(object), "S4")) {
body:             if (is.null(value)) 
body:                 value <- .pseudoNULL
body:             attr(object, dataSlot) <- value
body:             return(object)
body:         }
body:     }
body:     .mergeAttrs(value, object)
body: }
args: list(structure(function () 
args: NULL, generic = character(0), package = character(0), group = list(), valueClass = character(0), signature = character(0), default = quote(`\001NULL\001`), skeleton = quote(`<undef>`()), class = structure("standardGeneric", package = "methods")), structure(function (fitted, ...) 
args: standardGeneric("profile"), target = structure("ANY", class = structure("signature", package = "methods"), .Names = "fitted", package = "methods"), defined = structure("ANY", class = structure("signature", package = "methods"), .Names = "fitted", package = "methods"), generic = character(0), class = structure("derivedDefaultMethod", package = "methods")))
retn: structure(function (fitted, ...) 
retn: standardGeneric("profile"), generic = character(0), package = character(0), group = list(), valueClass = character(0), signature = character(0), default = quote(`\001NULL\001`), skeleton = quote(`<undef>`()), class = structure("standardGeneric", package = "methods"))

func: quote(setDataPart)
body: function (object, value, check = TRUE) 
body: {
body:     if (check || identical(typeof(object), "S4")) {
body:         classDef <- getClass(class(object))
body:         slots <- getSlots(classDef)
body:         dataSlot <- .dataSlot(names(slots))
body:         if (length(dataSlot) == 1) 
body:             dataClass <- elNamed(slots, dataSlot)
body:         else if (check) 
body:             stop(gettextf("class %s does not have a data part (a .Data slot) defined", dQuote(class(object))), domain = NA)
body:         else return(.mergeAttrs(value, object))
body:         value <- as(value, dataClass)
body:         if (identical(typeof(object), "S4")) {
body:             if (is.null(value)) 
body:                 value <- .pseudoNULL
body:             attr(object, dataSlot) <- value
body:             return(object)
body:         }
body:     }
body:     .mergeAttrs(value, object)
body: }
args: list(structure(function () 
args: NULL, target = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), defined = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), generic = character(0), class = structure("derivedDefaultMethod", package = "methods")), function (object, ...) 
args: UseMethod("summary"))
retn: structure(function (object, ...) 
retn: UseMethod("summary"), target = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), defined = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), generic = character(0), class = structure("derivedDefaultMethod", package = "methods"))

func: quote(setDataPart)
body: function (object, value, check = TRUE) 
body: {
body:     if (check || identical(typeof(object), "S4")) {
body:         classDef <- getClass(class(object))
body:         slots <- getSlots(classDef)
body:         dataSlot <- .dataSlot(names(slots))
body:         if (length(dataSlot) == 1) 
body:             dataClass <- elNamed(slots, dataSlot)
body:         else if (check) 
body:             stop(gettextf("class %s does not have a data part (a .Data slot) defined", dQuote(class(object))), domain = NA)
body:         else return(.mergeAttrs(value, object))
body:         value <- as(value, dataClass)
body:         if (identical(typeof(object), "S4")) {
body:             if (is.null(value)) 
body:                 value <- .pseudoNULL
body:             attr(object, dataSlot) <- value
body:             return(object)
body:         }
body:     }
body:     .mergeAttrs(value, object)
body: }
args: list(structure(function (object, ...) 
args: UseMethod("summary"), target = structure("ANY", class = structure("signature", package = "methods"), .Names = "object", package = "methods"), defined = structure("ANY", class = structure("signature", package = "methods"), .Names = "object", package = "methods"), generic = character(0), class = structure("derivedDefaultMethod", package = "methods")), function (object, ...) 
args: standardGeneric("summary"))
retn: structure(function (object, ...) 
retn: standardGeneric("summary"), target = structure("ANY", class = structure("signature", package = "methods"), .Names = "object", package = "methods"), defined = structure("ANY", class = structure("signature", package = "methods"), .Names = "object", package = "methods"), generic = character(0), class = structure("derivedDefaultMethod", package = "methods"))

func: quote(setDataPart)
body: function (object, value, check = TRUE) 
body: {
body:     if (check || identical(typeof(object), "S4")) {
body:         classDef <- getClass(class(object))
body:         slots <- getSlots(classDef)
body:         dataSlot <- .dataSlot(names(slots))
body:         if (length(dataSlot) == 1) 
body:             dataClass <- elNamed(slots, dataSlot)
body:         else if (check) 
body:             stop(gettextf("class %s does not have a data part (a .Data slot) defined", dQuote(class(object))), domain = NA)
body:         else return(.mergeAttrs(value, object))
body:         value <- as(value, dataClass)
body:         if (identical(typeof(object), "S4")) {
body:             if (is.null(value)) 
body:                 value <- .pseudoNULL
body:             attr(object, dataSlot) <- value
body:             return(object)
body:         }
body:     }
body:     .mergeAttrs(value, object)
body: }
args: list(structure(function () 
args: NULL, generic = character(0), package = character(0), group = list(), valueClass = character(0), signature = character(0), default = quote(`\001NULL\001`), skeleton = quote(`<undef>`()), class = structure("standardGeneric", package = "methods")), structure(function (object, ...) 
args: standardGeneric("summary"), target = structure("ANY", class = structure("signature", package = "methods"), .Names = "object", package = "methods"), defined = structure("ANY", class = structure("signature", package = "methods"), .Names = "object", package = "methods"), generic = character(0), class = structure("derivedDefaultMethod", package = "methods")))
retn: structure(function (object, ...) 
retn: standardGeneric("summary"), generic = character(0), package = character(0), group = list(), valueClass = character(0), signature = character(0), default = quote(`\001NULL\001`), skeleton = quote(`<undef>`()), class = structure("standardGeneric", package = "methods"))

func: quote(setDataPart)
body: function (object, value, check = TRUE) 
body: {
body:     if (check || identical(typeof(object), "S4")) {
body:         classDef <- getClass(class(object))
body:         slots <- getSlots(classDef)
body:         dataSlot <- .dataSlot(names(slots))
body:         if (length(dataSlot) == 1) 
body:             dataClass <- elNamed(slots, dataSlot)
body:         else if (check) 
body:             stop(gettextf("class %s does not have a data part (a .Data slot) defined", dQuote(class(object))), domain = NA)
body:         else return(.mergeAttrs(value, object))
body:         value <- as(value, dataClass)
body:         if (identical(typeof(object), "S4")) {
body:             if (is.null(value)) 
body:                 value <- .pseudoNULL
body:             attr(object, dataSlot) <- value
body:             return(object)
body:         }
body:     }
body:     .mergeAttrs(value, object)
body: }
args: list(structure(function () 
args: NULL, target = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), defined = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), generic = character(0), class = structure("derivedDefaultMethod", package = "methods")), function (object, ...) 
args: UseMethod("update"))
retn: structure(function (object, ...) 
retn: UseMethod("update"), target = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), defined = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), generic = character(0), class = structure("derivedDefaultMethod", package = "methods"))

func: quote(setDataPart)
body: function (object, value, check = TRUE) 
body: {
body:     if (check || identical(typeof(object), "S4")) {
body:         classDef <- getClass(class(object))
body:         slots <- getSlots(classDef)
body:         dataSlot <- .dataSlot(names(slots))
body:         if (length(dataSlot) == 1) 
body:             dataClass <- elNamed(slots, dataSlot)
body:         else if (check) 
body:             stop(gettextf("class %s does not have a data part (a .Data slot) defined", dQuote(class(object))), domain = NA)
body:         else return(.mergeAttrs(value, object))
body:         value <- as(value, dataClass)
body:         if (identical(typeof(object), "S4")) {
body:             if (is.null(value)) 
body:                 value <- .pseudoNULL
body:             attr(object, dataSlot) <- value
body:             return(object)
body:         }
body:     }
body:     .mergeAttrs(value, object)
body: }
args: list(structure(function (object, ...) 
args: UseMethod("update"), target = structure("ANY", class = structure("signature", package = "methods"), .Names = "object", package = "methods"), defined = structure("ANY", class = structure("signature", package = "methods"), .Names = "object", package = "methods"), generic = character(0), class = structure("derivedDefaultMethod", package = "methods")), function (object, ...) 
args: standardGeneric("update"))
retn: structure(function (object, ...) 
retn: standardGeneric("update"), target = structure("ANY", class = structure("signature", package = "methods"), .Names = "object", package = "methods"), defined = structure("ANY", class = structure("signature", package = "methods"), .Names = "object", package = "methods"), generic = character(0), class = structure("derivedDefaultMethod", package = "methods"))

func: quote(setDataPart)
body: function (object, value, check = TRUE) 
body: {
body:     if (check || identical(typeof(object), "S4")) {
body:         classDef <- getClass(class(object))
body:         slots <- getSlots(classDef)
body:         dataSlot <- .dataSlot(names(slots))
body:         if (length(dataSlot) == 1) 
body:             dataClass <- elNamed(slots, dataSlot)
body:         else if (check) 
body:             stop(gettextf("class %s does not have a data part (a .Data slot) defined", dQuote(class(object))), domain = NA)
body:         else return(.mergeAttrs(value, object))
body:         value <- as(value, dataClass)
body:         if (identical(typeof(object), "S4")) {
body:             if (is.null(value)) 
body:                 value <- .pseudoNULL
body:             attr(object, dataSlot) <- value
body:             return(object)
body:         }
body:     }
body:     .mergeAttrs(value, object)
body: }
args: list(structure(function () 
args: NULL, generic = character(0), package = character(0), group = list(), valueClass = character(0), signature = character(0), default = quote(`\001NULL\001`), skeleton = quote(`<undef>`()), class = structure("standardGeneric", package = "methods")), structure(function (object, ...) 
args: standardGeneric("update"), target = structure("ANY", class = structure("signature", package = "methods"), .Names = "object", package = "methods"), defined = structure("ANY", class = structure("signature", package = "methods"), .Names = "object", package = "methods"), generic = character(0), class = structure("derivedDefaultMethod", package = "methods")))
retn: structure(function (object, ...) 
retn: standardGeneric("update"), generic = character(0), package = character(0), group = list(), valueClass = character(0), signature = character(0), default = quote(`\001NULL\001`), skeleton = quote(`<undef>`()), class = structure("standardGeneric", package = "methods"))

func: quote(setDataPart)
body: function (object, value, check = TRUE) 
body: {
body:     if (check || identical(typeof(object), "S4")) {
body:         classDef <- getClass(class(object))
body:         slots <- getSlots(classDef)
body:         dataSlot <- .dataSlot(names(slots))
body:         if (length(dataSlot) == 1) 
body:             dataClass <- elNamed(slots, dataSlot)
body:         else if (check) 
body:             stop(gettextf("class %s does not have a data part (a .Data slot) defined", dQuote(class(object))), domain = NA)
body:         else return(.mergeAttrs(value, object))
body:         value <- as(value, dataClass)
body:         if (identical(typeof(object), "S4")) {
body:             if (is.null(value)) 
body:                 value <- .pseudoNULL
body:             attr(object, dataSlot) <- value
body:             return(object)
body:         }
body:     }
body:     .mergeAttrs(value, object)
body: }
args: list(structure(function () 
args: NULL, target = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), defined = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), generic = character(0), class = structure("derivedDefaultMethod", package = "methods")), function (object, ...) 
args: UseMethod("vcov"))
retn: structure(function (object, ...) 
retn: UseMethod("vcov"), target = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), defined = structure(character(0), .Names = character(0), package = character(0), class = structure("signature", package = "methods")), generic = character(0), class = structure("derivedDefaultMethod", package = "methods"))

func: quote(setDataPart)
body: function (object, value, check = TRUE) 
body: {
body:     if (check || identical(typeof(object), "S4")) {
body:         classDef <- getClass(class(object))
body:         slots <- getSlots(classDef)
body:         dataSlot <- .dataSlot(names(slots))
body:         if (length(dataSlot) == 1) 
body:             dataClass <- elNamed(slots, dataSlot)
body:         else if (check) 
body:             stop(gettextf("class %s does not have a data part (a .Data slot) defined", dQuote(class(object))), domain = NA)
body:         else return(.mergeAttrs(value, object))
body:         value <- as(value, dataClass)
body:         if (identical(typeof(object), "S4")) {
body:             if (is.null(value)) 
body:                 value <- .pseudoNULL
body:             attr(object, dataSlot) <- value
body:             return(object)
body:         }
body:     }
body:     .mergeAttrs(value, object)
body: }
args: list(structure(function (object, ...) 
args: UseMethod("vcov"), target = structure("ANY", class = structure("signature", package = "methods"), .Names = "object", package = "methods"), defined = structure("ANY", class = structure("signature", package = "methods"), .Names = "object", package = "methods"), generic = character(0), class = structure("derivedDefaultMethod", package = "methods")), function (object, ...) 
args: standardGeneric("vcov"))
retn: structure(function (object, ...) 
retn: standardGeneric("vcov"), target = structure("ANY", class = structure("signature", package = "methods"), .Names = "object", package = "methods"), defined = structure("ANY", class = structure("signature", package = "methods"), .Names = "object", package = "methods"), generic = character(0), class = structure("derivedDefaultMethod", package = "methods"))

func: quote(setDataPart)
body: function (object, value, check = TRUE) 
body: {
body:     if (check || identical(typeof(object), "S4")) {
body:         classDef <- getClass(class(object))
body:         slots <- getSlots(classDef)
body:         dataSlot <- .dataSlot(names(slots))
body:         if (length(dataSlot) == 1) 
body:             dataClass <- elNamed(slots, dataSlot)
body:         else if (check) 
body:             stop(gettextf("class %s does not have a data part (a .Data slot) defined", dQuote(class(object))), domain = NA)
body:         else return(.mergeAttrs(value, object))
body:         value <- as(value, dataClass)
body:         if (identical(typeof(object), "S4")) {
body:             if (is.null(value)) 
body:                 value <- .pseudoNULL
body:             attr(object, dataSlot) <- value
body:             return(object)
body:         }
body:     }
body:     .mergeAttrs(value, object)
body: }
args: list(structure(function () 
args: NULL, generic = character(0), package = character(0), group = list(), valueClass = character(0), signature = character(0), default = quote(`\001NULL\001`), skeleton = quote(`<undef>`()), class = structure("standardGeneric", package = "methods")), structure(function (object, ...) 
args: standardGeneric("vcov"), target = structure("ANY", class = structure("signature", package = "methods"), .Names = "object", package = "methods"), defined = structure("ANY", class = structure("signature", package = "methods"), .Names = "object", package = "methods"), generic = character(0), class = structure("derivedDefaultMethod", package = "methods")))
retn: structure(function (object, ...) 
retn: standardGeneric("vcov"), generic = character(0), package = character(0), group = list(), valueClass = character(0), signature = character(0), default = quote(`\001NULL\001`), skeleton = quote(`<undef>`()), class = structure("standardGeneric", package = "methods"))

