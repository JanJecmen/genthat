func: quote(data.frame)
body: function (..., row.names = NULL, check.rows = FALSE, check.names = TRUE, stringsAsFactors = default.stringsAsFactors()) 
body: {
body:     data.row.names <- if (check.rows && is.null(row.names)) 
body:         function(current, new, i) {
body:             if (is.character(current)) 
body:                 new <- as.character(new)
body:             if (is.character(new)) 
body:                 current <- as.character(current)
body:             if (anyDuplicated(new)) 
body:                 return(current)
body:             if (is.null(current)) 
body:                 return(new)
body:             if (all(current == new) || all(current == "")) 
body:                 return(new)
body:             stop(gettextf("mismatch of row names in arguments of 'data.frame', item %d", i), domain = NA)
body:         }
body:     else function(current, new, i) {
body:         if (is.null(current)) {
body:             if (anyDuplicated(new)) {
body:                 warning(gettextf("some row.names duplicated: %s --> row.names NOT used", paste(which(duplicated(new)), collapse = ",")), domain = NA)
body:                 current
body:             }
body:             else new
body:         }
body:         else current
body:     }
body:     object <- as.list(substitute(list(...)))[-1L]
body:     mirn <- missing(row.names)
body:     mrn <- is.null(row.names)
body:     x <- list(...)
body:     n <- length(x)
body:     if (n < 1L) {
body:         if (!mrn) {
body:             if (is.object(row.names) || !is.integer(row.names)) 
body:                 row.names <- as.character(row.names)
body:             if (any(is.na(row.names))) 
body:                 stop("row names contain missing values")
body:             if (anyDuplicated(row.names)) 
body:                 stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:         }
body:         else row.names <- integer()
body:         return(structure(list(), names = character(), row.names = row.names, class = "data.frame"))
body:     }
body:     vnames <- names(x)
body:     if (length(vnames) != n) 
body:         vnames <- character(n)
body:     no.vn <- !nzchar(vnames)
body:     vlist <- vnames <- as.list(vnames)
body:     nrows <- ncols <- integer(n)
body:     for (i in seq_len(n)) {
body:         xi <- if (is.character(x[[i]]) || is.list(x[[i]])) 
body:             as.data.frame(x[[i]], optional = TRUE, stringsAsFactors = stringsAsFactors)
body:         else as.data.frame(x[[i]], optional = TRUE)
body:         nrows[i] <- .row_names_info(xi)
body:         ncols[i] <- length(xi)
body:         namesi <- names(xi)
body:         if (ncols[i] > 1L) {
body:             if (length(namesi) == 0L) 
body:                 namesi <- seq_len(ncols[i])
body:             if (no.vn[i]) 
body:                 vnames[[i]] <- namesi
body:             else vnames[[i]] <- paste(vnames[[i]], namesi, sep = ".")
body:         }
body:         else {
body:             if (length(namesi)) 
body:                 vnames[[i]] <- namesi
body:             else if (no.vn[[i]]) {
body:                 tmpname <- deparse(object[[i]])[1L]
body:                 if (substr(tmpname, 1L, 2L) == "I(") {
body:                   ntmpn <- nchar(tmpname, "c")
body:                   if (substr(tmpname, ntmpn, ntmpn) == ")") 
body:                     tmpname <- substr(tmpname, 3L, ntmpn - 1L)
body:                 }
body:                 vnames[[i]] <- tmpname
body:             }
body:         }
body:         if (mirn && nrows[i] > 0L) {
body:             rowsi <- attr(xi, "row.names")
body:             nc <- nchar(rowsi, allowNA = FALSE)
body:             nc <- nc[!is.na(nc)]
body:             if (length(nc) && any(nc)) 
body:                 row.names <- data.row.names(row.names, rowsi, i)
body:         }
body:         nrows[i] <- abs(nrows[i])
body:         vlist[[i]] <- xi
body:     }
body:     nr <- max(nrows)
body:     for (i in seq_len(n)[nrows < nr]) {
body:         xi <- vlist[[i]]
body:         if (nrows[i] > 0L && (nr%%nrows[i] == 0L)) {
body:             xi <- unclass(xi)
body:             fixed <- TRUE
body:             for (j in seq_along(xi)) {
body:                 xi1 <- xi[[j]]
body:                 if (is.vector(xi1) || is.factor(xi1)) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else if (is.character(xi1) && inherits(xi1, "AsIs")) 
body:                   xi[[j]] <- structure(rep(xi1, length.out = nr), class = class(xi1))
body:                 else if (inherits(xi1, "Date") || inherits(xi1, "POSIXct")) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else {
body:                   fixed <- FALSE
body:                   break
body:                 }
body:             }
body:             if (fixed) {
body:                 vlist[[i]] <- xi
body:                 next
body:             }
body:         }
body:         stop(gettextf("arguments imply differing number of rows: %s", paste(unique(nrows), collapse = ", ")), domain = NA)
body:     }
body:     value <- unlist(vlist, recursive = FALSE, use.names = FALSE)
body:     vnames <- unlist(vnames[ncols > 0L])
body:     noname <- !nzchar(vnames)
body:     if (any(noname)) 
body:         vnames[noname] <- paste("Var", seq_along(vnames), sep = ".")[noname]
body:     if (check.names) 
body:         vnames <- make.names(vnames, unique = TRUE)
body:     names(value) <- vnames
body:     if (!mrn) {
body:         if (length(row.names) == 1L && nr != 1L) {
body:             if (is.character(row.names)) 
body:                 row.names <- match(row.names, vnames, 0L)
body:             if (length(row.names) != 1L || row.names < 1L || row.names > length(vnames)) 
body:                 stop("'row.names' should specify one of the variables")
body:             i <- row.names
body:             row.names <- value[[i]]
body:             value <- value[-i]
body:         }
body:         else if (!is.null(row.names) && length(row.names) != nr) 
body:             stop("row names supplied are of the wrong length")
body:     }
body:     else if (!is.null(row.names) && length(row.names) != nr) {
body:         warning("row names were found from a short variable and have been discarded")
body:         row.names <- NULL
body:     }
body:     if (is.null(row.names)) 
body:         row.names <- .set_row_names(nr)
body:     else {
body:         if (is.object(row.names) || !is.integer(row.names)) 
body:             row.names <- as.character(row.names)
body:         if (any(is.na(row.names))) 
body:             stop("row names contain missing values")
body:         if (anyDuplicated(row.names)) 
body:             stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:     }
body:     attr(value, "row.names") <- row.names
body:     attr(value, "class") <- "data.frame"
body:     value
body: }
args: list(temp = c(-1, 3, 2, -2), cat = c("A", "B", "A", "B"))
retn: structure(list(temp = c(-1, 3, 2, -2), cat = structure(c(1L, 2L, 1L, 2L), .Label = c("A", "B"), class = "factor")), .Names = c("temp", "cat"), row.names = c(NA, -4L), class = "data.frame")

func: quote(data.frame)
body: function (..., row.names = NULL, check.rows = FALSE, check.names = TRUE, stringsAsFactors = default.stringsAsFactors()) 
body: {
body:     data.row.names <- if (check.rows && is.null(row.names)) 
body:         function(current, new, i) {
body:             if (is.character(current)) 
body:                 new <- as.character(new)
body:             if (is.character(new)) 
body:                 current <- as.character(current)
body:             if (anyDuplicated(new)) 
body:                 return(current)
body:             if (is.null(current)) 
body:                 return(new)
body:             if (all(current == new) || all(current == "")) 
body:                 return(new)
body:             stop(gettextf("mismatch of row names in arguments of 'data.frame', item %d", i), domain = NA)
body:         }
body:     else function(current, new, i) {
body:         if (is.null(current)) {
body:             if (anyDuplicated(new)) {
body:                 warning(gettextf("some row.names duplicated: %s --> row.names NOT used", paste(which(duplicated(new)), collapse = ",")), domain = NA)
body:                 current
body:             }
body:             else new
body:         }
body:         else current
body:     }
body:     object <- as.list(substitute(list(...)))[-1L]
body:     mirn <- missing(row.names)
body:     mrn <- is.null(row.names)
body:     x <- list(...)
body:     n <- length(x)
body:     if (n < 1L) {
body:         if (!mrn) {
body:             if (is.object(row.names) || !is.integer(row.names)) 
body:                 row.names <- as.character(row.names)
body:             if (any(is.na(row.names))) 
body:                 stop("row names contain missing values")
body:             if (anyDuplicated(row.names)) 
body:                 stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:         }
body:         else row.names <- integer()
body:         return(structure(list(), names = character(), row.names = row.names, class = "data.frame"))
body:     }
body:     vnames <- names(x)
body:     if (length(vnames) != n) 
body:         vnames <- character(n)
body:     no.vn <- !nzchar(vnames)
body:     vlist <- vnames <- as.list(vnames)
body:     nrows <- ncols <- integer(n)
body:     for (i in seq_len(n)) {
body:         xi <- if (is.character(x[[i]]) || is.list(x[[i]])) 
body:             as.data.frame(x[[i]], optional = TRUE, stringsAsFactors = stringsAsFactors)
body:         else as.data.frame(x[[i]], optional = TRUE)
body:         nrows[i] <- .row_names_info(xi)
body:         ncols[i] <- length(xi)
body:         namesi <- names(xi)
body:         if (ncols[i] > 1L) {
body:             if (length(namesi) == 0L) 
body:                 namesi <- seq_len(ncols[i])
body:             if (no.vn[i]) 
body:                 vnames[[i]] <- namesi
body:             else vnames[[i]] <- paste(vnames[[i]], namesi, sep = ".")
body:         }
body:         else {
body:             if (length(namesi)) 
body:                 vnames[[i]] <- namesi
body:             else if (no.vn[[i]]) {
body:                 tmpname <- deparse(object[[i]])[1L]
body:                 if (substr(tmpname, 1L, 2L) == "I(") {
body:                   ntmpn <- nchar(tmpname, "c")
body:                   if (substr(tmpname, ntmpn, ntmpn) == ")") 
body:                     tmpname <- substr(tmpname, 3L, ntmpn - 1L)
body:                 }
body:                 vnames[[i]] <- tmpname
body:             }
body:         }
body:         if (mirn && nrows[i] > 0L) {
body:             rowsi <- attr(xi, "row.names")
body:             nc <- nchar(rowsi, allowNA = FALSE)
body:             nc <- nc[!is.na(nc)]
body:             if (length(nc) && any(nc)) 
body:                 row.names <- data.row.names(row.names, rowsi, i)
body:         }
body:         nrows[i] <- abs(nrows[i])
body:         vlist[[i]] <- xi
body:     }
body:     nr <- max(nrows)
body:     for (i in seq_len(n)[nrows < nr]) {
body:         xi <- vlist[[i]]
body:         if (nrows[i] > 0L && (nr%%nrows[i] == 0L)) {
body:             xi <- unclass(xi)
body:             fixed <- TRUE
body:             for (j in seq_along(xi)) {
body:                 xi1 <- xi[[j]]
body:                 if (is.vector(xi1) || is.factor(xi1)) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else if (is.character(xi1) && inherits(xi1, "AsIs")) 
body:                   xi[[j]] <- structure(rep(xi1, length.out = nr), class = class(xi1))
body:                 else if (inherits(xi1, "Date") || inherits(xi1, "POSIXct")) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else {
body:                   fixed <- FALSE
body:                   break
body:                 }
body:             }
body:             if (fixed) {
body:                 vlist[[i]] <- xi
body:                 next
body:             }
body:         }
body:         stop(gettextf("arguments imply differing number of rows: %s", paste(unique(nrows), collapse = ", ")), domain = NA)
body:     }
body:     value <- unlist(vlist, recursive = FALSE, use.names = FALSE)
body:     vnames <- unlist(vnames[ncols > 0L])
body:     noname <- !nzchar(vnames)
body:     if (any(noname)) 
body:         vnames[noname] <- paste("Var", seq_along(vnames), sep = ".")[noname]
body:     if (check.names) 
body:         vnames <- make.names(vnames, unique = TRUE)
body:     names(value) <- vnames
body:     if (!mrn) {
body:         if (length(row.names) == 1L && nr != 1L) {
body:             if (is.character(row.names)) 
body:                 row.names <- match(row.names, vnames, 0L)
body:             if (length(row.names) != 1L || row.names < 1L || row.names > length(vnames)) 
body:                 stop("'row.names' should specify one of the variables")
body:             i <- row.names
body:             row.names <- value[[i]]
body:             value <- value[-i]
body:         }
body:         else if (!is.null(row.names) && length(row.names) != nr) 
body:             stop("row names supplied are of the wrong length")
body:     }
body:     else if (!is.null(row.names) && length(row.names) != nr) {
body:         warning("row names were found from a short variable and have been discarded")
body:         row.names <- NULL
body:     }
body:     if (is.null(row.names)) 
body:         row.names <- .set_row_names(nr)
body:     else {
body:         if (is.object(row.names) || !is.integer(row.names)) 
body:             row.names <- as.character(row.names)
body:         if (any(is.na(row.names))) 
body:             stop("row names contain missing values")
body:         if (anyDuplicated(row.names)) 
body:             stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:     }
body:     attr(value, "row.names") <- row.names
body:     attr(value, "class") <- "data.frame"
body:     value
body: }
args: list(temp = structure(c("-1", " 3", " 2", "-2"), class = "AsIs"), cat = structure(c("A", "B", "A", "B"), class = "AsIs"), check.names = FALSE, row.names = c("1", "2", "3", "4"))
retn: structure(list(temp = structure(c("-1", " 3", " 2", "-2"), class = "AsIs"), cat = structure(c("A", "B", "A", "B"), class = "AsIs")), .Names = c("temp", "cat"), row.names = c("1", "2", "3", "4"), class = "data.frame")

func: quote(data.frame)
body: function (..., row.names = NULL, check.rows = FALSE, check.names = TRUE, stringsAsFactors = default.stringsAsFactors()) 
body: {
body:     data.row.names <- if (check.rows && is.null(row.names)) 
body:         function(current, new, i) {
body:             if (is.character(current)) 
body:                 new <- as.character(new)
body:             if (is.character(new)) 
body:                 current <- as.character(current)
body:             if (anyDuplicated(new)) 
body:                 return(current)
body:             if (is.null(current)) 
body:                 return(new)
body:             if (all(current == new) || all(current == "")) 
body:                 return(new)
body:             stop(gettextf("mismatch of row names in arguments of 'data.frame', item %d", i), domain = NA)
body:         }
body:     else function(current, new, i) {
body:         if (is.null(current)) {
body:             if (anyDuplicated(new)) {
body:                 warning(gettextf("some row.names duplicated: %s --> row.names NOT used", paste(which(duplicated(new)), collapse = ",")), domain = NA)
body:                 current
body:             }
body:             else new
body:         }
body:         else current
body:     }
body:     object <- as.list(substitute(list(...)))[-1L]
body:     mirn <- missing(row.names)
body:     mrn <- is.null(row.names)
body:     x <- list(...)
body:     n <- length(x)
body:     if (n < 1L) {
body:         if (!mrn) {
body:             if (is.object(row.names) || !is.integer(row.names)) 
body:                 row.names <- as.character(row.names)
body:             if (any(is.na(row.names))) 
body:                 stop("row names contain missing values")
body:             if (anyDuplicated(row.names)) 
body:                 stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:         }
body:         else row.names <- integer()
body:         return(structure(list(), names = character(), row.names = row.names, class = "data.frame"))
body:     }
body:     vnames <- names(x)
body:     if (length(vnames) != n) 
body:         vnames <- character(n)
body:     no.vn <- !nzchar(vnames)
body:     vlist <- vnames <- as.list(vnames)
body:     nrows <- ncols <- integer(n)
body:     for (i in seq_len(n)) {
body:         xi <- if (is.character(x[[i]]) || is.list(x[[i]])) 
body:             as.data.frame(x[[i]], optional = TRUE, stringsAsFactors = stringsAsFactors)
body:         else as.data.frame(x[[i]], optional = TRUE)
body:         nrows[i] <- .row_names_info(xi)
body:         ncols[i] <- length(xi)
body:         namesi <- names(xi)
body:         if (ncols[i] > 1L) {
body:             if (length(namesi) == 0L) 
body:                 namesi <- seq_len(ncols[i])
body:             if (no.vn[i]) 
body:                 vnames[[i]] <- namesi
body:             else vnames[[i]] <- paste(vnames[[i]], namesi, sep = ".")
body:         }
body:         else {
body:             if (length(namesi)) 
body:                 vnames[[i]] <- namesi
body:             else if (no.vn[[i]]) {
body:                 tmpname <- deparse(object[[i]])[1L]
body:                 if (substr(tmpname, 1L, 2L) == "I(") {
body:                   ntmpn <- nchar(tmpname, "c")
body:                   if (substr(tmpname, ntmpn, ntmpn) == ")") 
body:                     tmpname <- substr(tmpname, 3L, ntmpn - 1L)
body:                 }
body:                 vnames[[i]] <- tmpname
body:             }
body:         }
body:         if (mirn && nrows[i] > 0L) {
body:             rowsi <- attr(xi, "row.names")
body:             nc <- nchar(rowsi, allowNA = FALSE)
body:             nc <- nc[!is.na(nc)]
body:             if (length(nc) && any(nc)) 
body:                 row.names <- data.row.names(row.names, rowsi, i)
body:         }
body:         nrows[i] <- abs(nrows[i])
body:         vlist[[i]] <- xi
body:     }
body:     nr <- max(nrows)
body:     for (i in seq_len(n)[nrows < nr]) {
body:         xi <- vlist[[i]]
body:         if (nrows[i] > 0L && (nr%%nrows[i] == 0L)) {
body:             xi <- unclass(xi)
body:             fixed <- TRUE
body:             for (j in seq_along(xi)) {
body:                 xi1 <- xi[[j]]
body:                 if (is.vector(xi1) || is.factor(xi1)) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else if (is.character(xi1) && inherits(xi1, "AsIs")) 
body:                   xi[[j]] <- structure(rep(xi1, length.out = nr), class = class(xi1))
body:                 else if (inherits(xi1, "Date") || inherits(xi1, "POSIXct")) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else {
body:                   fixed <- FALSE
body:                   break
body:                 }
body:             }
body:             if (fixed) {
body:                 vlist[[i]] <- xi
body:                 next
body:             }
body:         }
body:         stop(gettextf("arguments imply differing number of rows: %s", paste(unique(nrows), collapse = ", ")), domain = NA)
body:     }
body:     value <- unlist(vlist, recursive = FALSE, use.names = FALSE)
body:     vnames <- unlist(vnames[ncols > 0L])
body:     noname <- !nzchar(vnames)
body:     if (any(noname)) 
body:         vnames[noname] <- paste("Var", seq_along(vnames), sep = ".")[noname]
body:     if (check.names) 
body:         vnames <- make.names(vnames, unique = TRUE)
body:     names(value) <- vnames
body:     if (!mrn) {
body:         if (length(row.names) == 1L && nr != 1L) {
body:             if (is.character(row.names)) 
body:                 row.names <- match(row.names, vnames, 0L)
body:             if (length(row.names) != 1L || row.names < 1L || row.names > length(vnames)) 
body:                 stop("'row.names' should specify one of the variables")
body:             i <- row.names
body:             row.names <- value[[i]]
body:             value <- value[-i]
body:         }
body:         else if (!is.null(row.names) && length(row.names) != nr) 
body:             stop("row names supplied are of the wrong length")
body:     }
body:     else if (!is.null(row.names) && length(row.names) != nr) {
body:         warning("row names were found from a short variable and have been discarded")
body:         row.names <- NULL
body:     }
body:     if (is.null(row.names)) 
body:         row.names <- .set_row_names(nr)
body:     else {
body:         if (is.object(row.names) || !is.integer(row.names)) 
body:             row.names <- as.character(row.names)
body:         if (any(is.na(row.names))) 
body:             stop("row names contain missing values")
body:         if (anyDuplicated(row.names)) 
body:             stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:     }
body:     attr(value, "row.names") <- row.names
body:     attr(value, "class") <- "data.frame"
body:     value
body: }
args: list(home = structure(c(6L, 5L, 4L, 2L, 2L, 3L, 8L, 8L, 4L, 7L, 2L, 7L, 4L, 4L, 5L, 6L, 5L, 3L, 8L, 7L, 4L, 2L, 2L, 8L, 5L, 1L, 2L, 7L, 7L, 1L), .Label = c("act", "nsw", "nt", "qld", "sa", "tas", "vic", "wa"), class = "factor"), loot = c(60, 49, 40, 61, 64, 60, 59, 54, 62, 69, 70, 42, 56, 61, 61, 61, 58, 51, 48, 65, 49, 49, 41, 48, 52, 46, 59, 46, 58, 43), shot = structure(c(3L, 2L, 1L, 3L, 3L, 3L, 3L, 2L, 3L, 4L, 4L, 1L, 3L, 3L, 3L, 3L, 3L, 2L, 2L, 3L, 2L, 2L, 1L, 2L, 2L, 2L, 3L, 2L, 3L, 1L), .Label = c("(35,45]", 
args: "(45,55]", "(55,65]", "(65,75]"), class = "factor"))
retn: structure(list(home = structure(c(6L, 5L, 4L, 2L, 2L, 3L, 8L, 8L, 4L, 7L, 2L, 7L, 4L, 4L, 5L, 6L, 5L, 3L, 8L, 7L, 4L, 2L, 2L, 8L, 5L, 1L, 2L, 7L, 7L, 1L), .Label = c("act", "nsw", "nt", "qld", "sa", "tas", "vic", "wa"), class = "factor"), loot = c(60, 49, 40, 61, 64, 60, 59, 54, 62, 69, 70, 42, 56, 61, 61, 61, 58, 51, 48, 65, 49, 49, 41, 48, 52, 46, 59, 46, 58, 43), shot = structure(c(3L, 2L, 1L, 3L, 3L, 3L, 3L, 2L, 3L, 4L, 4L, 1L, 3L, 3L, 3L, 3L, 3L, 2L, 2L, 3L, 2L, 2L, 1L, 2L, 2L, 2L, 3L, 2L, 3L, 
retn: 1L), .Label = c("(35,45]", "(45,55]", "(55,65]", "(65,75]"), class = "factor")), .Names = c("home", "loot", "shot"), row.names = c(NA, -30L), class = "data.frame")

func: quote(data.frame)
body: function (..., row.names = NULL, check.rows = FALSE, check.names = TRUE, stringsAsFactors = default.stringsAsFactors()) 
body: {
body:     data.row.names <- if (check.rows && is.null(row.names)) 
body:         function(current, new, i) {
body:             if (is.character(current)) 
body:                 new <- as.character(new)
body:             if (is.character(new)) 
body:                 current <- as.character(current)
body:             if (anyDuplicated(new)) 
body:                 return(current)
body:             if (is.null(current)) 
body:                 return(new)
body:             if (all(current == new) || all(current == "")) 
body:                 return(new)
body:             stop(gettextf("mismatch of row names in arguments of 'data.frame', item %d", i), domain = NA)
body:         }
body:     else function(current, new, i) {
body:         if (is.null(current)) {
body:             if (anyDuplicated(new)) {
body:                 warning(gettextf("some row.names duplicated: %s --> row.names NOT used", paste(which(duplicated(new)), collapse = ",")), domain = NA)
body:                 current
body:             }
body:             else new
body:         }
body:         else current
body:     }
body:     object <- as.list(substitute(list(...)))[-1L]
body:     mirn <- missing(row.names)
body:     mrn <- is.null(row.names)
body:     x <- list(...)
body:     n <- length(x)
body:     if (n < 1L) {
body:         if (!mrn) {
body:             if (is.object(row.names) || !is.integer(row.names)) 
body:                 row.names <- as.character(row.names)
body:             if (any(is.na(row.names))) 
body:                 stop("row names contain missing values")
body:             if (anyDuplicated(row.names)) 
body:                 stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:         }
body:         else row.names <- integer()
body:         return(structure(list(), names = character(), row.names = row.names, class = "data.frame"))
body:     }
body:     vnames <- names(x)
body:     if (length(vnames) != n) 
body:         vnames <- character(n)
body:     no.vn <- !nzchar(vnames)
body:     vlist <- vnames <- as.list(vnames)
body:     nrows <- ncols <- integer(n)
body:     for (i in seq_len(n)) {
body:         xi <- if (is.character(x[[i]]) || is.list(x[[i]])) 
body:             as.data.frame(x[[i]], optional = TRUE, stringsAsFactors = stringsAsFactors)
body:         else as.data.frame(x[[i]], optional = TRUE)
body:         nrows[i] <- .row_names_info(xi)
body:         ncols[i] <- length(xi)
body:         namesi <- names(xi)
body:         if (ncols[i] > 1L) {
body:             if (length(namesi) == 0L) 
body:                 namesi <- seq_len(ncols[i])
body:             if (no.vn[i]) 
body:                 vnames[[i]] <- namesi
body:             else vnames[[i]] <- paste(vnames[[i]], namesi, sep = ".")
body:         }
body:         else {
body:             if (length(namesi)) 
body:                 vnames[[i]] <- namesi
body:             else if (no.vn[[i]]) {
body:                 tmpname <- deparse(object[[i]])[1L]
body:                 if (substr(tmpname, 1L, 2L) == "I(") {
body:                   ntmpn <- nchar(tmpname, "c")
body:                   if (substr(tmpname, ntmpn, ntmpn) == ")") 
body:                     tmpname <- substr(tmpname, 3L, ntmpn - 1L)
body:                 }
body:                 vnames[[i]] <- tmpname
body:             }
body:         }
body:         if (mirn && nrows[i] > 0L) {
body:             rowsi <- attr(xi, "row.names")
body:             nc <- nchar(rowsi, allowNA = FALSE)
body:             nc <- nc[!is.na(nc)]
body:             if (length(nc) && any(nc)) 
body:                 row.names <- data.row.names(row.names, rowsi, i)
body:         }
body:         nrows[i] <- abs(nrows[i])
body:         vlist[[i]] <- xi
body:     }
body:     nr <- max(nrows)
body:     for (i in seq_len(n)[nrows < nr]) {
body:         xi <- vlist[[i]]
body:         if (nrows[i] > 0L && (nr%%nrows[i] == 0L)) {
body:             xi <- unclass(xi)
body:             fixed <- TRUE
body:             for (j in seq_along(xi)) {
body:                 xi1 <- xi[[j]]
body:                 if (is.vector(xi1) || is.factor(xi1)) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else if (is.character(xi1) && inherits(xi1, "AsIs")) 
body:                   xi[[j]] <- structure(rep(xi1, length.out = nr), class = class(xi1))
body:                 else if (inherits(xi1, "Date") || inherits(xi1, "POSIXct")) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else {
body:                   fixed <- FALSE
body:                   break
body:                 }
body:             }
body:             if (fixed) {
body:                 vlist[[i]] <- xi
body:                 next
body:             }
body:         }
body:         stop(gettextf("arguments imply differing number of rows: %s", paste(unique(nrows), collapse = ", ")), domain = NA)
body:     }
body:     value <- unlist(vlist, recursive = FALSE, use.names = FALSE)
body:     vnames <- unlist(vnames[ncols > 0L])
body:     noname <- !nzchar(vnames)
body:     if (any(noname)) 
body:         vnames[noname] <- paste("Var", seq_along(vnames), sep = ".")[noname]
body:     if (check.names) 
body:         vnames <- make.names(vnames, unique = TRUE)
body:     names(value) <- vnames
body:     if (!mrn) {
body:         if (length(row.names) == 1L && nr != 1L) {
body:             if (is.character(row.names)) 
body:                 row.names <- match(row.names, vnames, 0L)
body:             if (length(row.names) != 1L || row.names < 1L || row.names > length(vnames)) 
body:                 stop("'row.names' should specify one of the variables")
body:             i <- row.names
body:             row.names <- value[[i]]
body:             value <- value[-i]
body:         }
body:         else if (!is.null(row.names) && length(row.names) != nr) 
body:             stop("row names supplied are of the wrong length")
body:     }
body:     else if (!is.null(row.names) && length(row.names) != nr) {
body:         warning("row names were found from a short variable and have been discarded")
body:         row.names <- NULL
body:     }
body:     if (is.null(row.names)) 
body:         row.names <- .set_row_names(nr)
body:     else {
body:         if (is.object(row.names) || !is.integer(row.names)) 
body:             row.names <- as.character(row.names)
body:         if (any(is.na(row.names))) 
body:             stop("row names contain missing values")
body:         if (anyDuplicated(row.names)) 
body:             stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:     }
body:     attr(value, "row.names") <- row.names
body:     attr(value, "class") <- "data.frame"
body:     value
body: }
args: list(home = structure(c("tas", "sa", "qld", "nsw", "nsw", "nt", "wa", "wa", "qld", "vic", "nsw", "vic", "qld", "qld", "sa", "tas", "sa", "nt", "wa", "vic", "qld", "nsw", "nsw", "wa", "sa", "act", "nsw", "vic", "vic", "act"), class = "AsIs"), loot = structure(c("60", "49", "40", "61", "64", "60", "59", "54", "62", "69", "70", "42", "56", "61", "61", "61", "58", "51", "48", "65", "49", "49", "41", "48", "52", "46", "59", "46", "58", "43"), class = "AsIs"), shot = structure(c("(55,65]", "(45,55]", "(35,45]", 
args: "(55,65]", "(55,65]", "(55,65]", "(55,65]", "(45,55]", "(55,65]", "(65,75]", "(65,75]", "(35,45]", "(55,65]", "(55,65]", "(55,65]", "(55,65]", "(55,65]", "(45,55]", "(45,55]", "(55,65]", "(45,55]", "(45,55]", "(35,45]", "(45,55]", "(45,55]", "(45,55]", "(55,65]", "(45,55]", "(55,65]", "(35,45]"), class = "AsIs"), check.names = FALSE, row.names = c("1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23", "24", "25", "26", "27", 
args: "28", "29", "30"))
retn: structure(list(home = structure(c("tas", "sa", "qld", "nsw", "nsw", "nt", "wa", "wa", "qld", "vic", "nsw", "vic", "qld", "qld", "sa", "tas", "sa", "nt", "wa", "vic", "qld", "nsw", "nsw", "wa", "sa", "act", "nsw", "vic", "vic", "act"), class = "AsIs"), loot = structure(c("60", "49", "40", "61", "64", "60", "59", "54", "62", "69", "70", "42", "56", "61", "61", "61", "58", "51", "48", "65", "49", "49", "41", "48", "52", "46", "59", "46", "58", "43"), class = "AsIs"), shot = structure(c("(55,65]", "(45,55]", 
retn: "(35,45]", "(55,65]", "(55,65]", "(55,65]", "(55,65]", "(45,55]", "(55,65]", "(65,75]", "(65,75]", "(35,45]", "(55,65]", "(55,65]", "(55,65]", "(55,65]", "(55,65]", "(45,55]", "(45,55]", "(55,65]", "(45,55]", "(45,55]", "(35,45]", "(45,55]", "(45,55]", "(45,55]", "(55,65]", "(45,55]", "(55,65]", "(35,45]"), class = "AsIs")), .Names = c("home", "loot", "shot"), row.names = c("1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23", 
retn: "24", "25", "26", "27", "28", "29", "30"), class = "data.frame")

func: quote(data.frame)
body: function (..., row.names = NULL, check.rows = FALSE, check.names = TRUE, stringsAsFactors = default.stringsAsFactors()) 
body: {
body:     data.row.names <- if (check.rows && is.null(row.names)) 
body:         function(current, new, i) {
body:             if (is.character(current)) 
body:                 new <- as.character(new)
body:             if (is.character(new)) 
body:                 current <- as.character(current)
body:             if (anyDuplicated(new)) 
body:                 return(current)
body:             if (is.null(current)) 
body:                 return(new)
body:             if (all(current == new) || all(current == "")) 
body:                 return(new)
body:             stop(gettextf("mismatch of row names in arguments of 'data.frame', item %d", i), domain = NA)
body:         }
body:     else function(current, new, i) {
body:         if (is.null(current)) {
body:             if (anyDuplicated(new)) {
body:                 warning(gettextf("some row.names duplicated: %s --> row.names NOT used", paste(which(duplicated(new)), collapse = ",")), domain = NA)
body:                 current
body:             }
body:             else new
body:         }
body:         else current
body:     }
body:     object <- as.list(substitute(list(...)))[-1L]
body:     mirn <- missing(row.names)
body:     mrn <- is.null(row.names)
body:     x <- list(...)
body:     n <- length(x)
body:     if (n < 1L) {
body:         if (!mrn) {
body:             if (is.object(row.names) || !is.integer(row.names)) 
body:                 row.names <- as.character(row.names)
body:             if (any(is.na(row.names))) 
body:                 stop("row names contain missing values")
body:             if (anyDuplicated(row.names)) 
body:                 stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:         }
body:         else row.names <- integer()
body:         return(structure(list(), names = character(), row.names = row.names, class = "data.frame"))
body:     }
body:     vnames <- names(x)
body:     if (length(vnames) != n) 
body:         vnames <- character(n)
body:     no.vn <- !nzchar(vnames)
body:     vlist <- vnames <- as.list(vnames)
body:     nrows <- ncols <- integer(n)
body:     for (i in seq_len(n)) {
body:         xi <- if (is.character(x[[i]]) || is.list(x[[i]])) 
body:             as.data.frame(x[[i]], optional = TRUE, stringsAsFactors = stringsAsFactors)
body:         else as.data.frame(x[[i]], optional = TRUE)
body:         nrows[i] <- .row_names_info(xi)
body:         ncols[i] <- length(xi)
body:         namesi <- names(xi)
body:         if (ncols[i] > 1L) {
body:             if (length(namesi) == 0L) 
body:                 namesi <- seq_len(ncols[i])
body:             if (no.vn[i]) 
body:                 vnames[[i]] <- namesi
body:             else vnames[[i]] <- paste(vnames[[i]], namesi, sep = ".")
body:         }
body:         else {
body:             if (length(namesi)) 
body:                 vnames[[i]] <- namesi
body:             else if (no.vn[[i]]) {
body:                 tmpname <- deparse(object[[i]])[1L]
body:                 if (substr(tmpname, 1L, 2L) == "I(") {
body:                   ntmpn <- nchar(tmpname, "c")
body:                   if (substr(tmpname, ntmpn, ntmpn) == ")") 
body:                     tmpname <- substr(tmpname, 3L, ntmpn - 1L)
body:                 }
body:                 vnames[[i]] <- tmpname
body:             }
body:         }
body:         if (mirn && nrows[i] > 0L) {
body:             rowsi <- attr(xi, "row.names")
body:             nc <- nchar(rowsi, allowNA = FALSE)
body:             nc <- nc[!is.na(nc)]
body:             if (length(nc) && any(nc)) 
body:                 row.names <- data.row.names(row.names, rowsi, i)
body:         }
body:         nrows[i] <- abs(nrows[i])
body:         vlist[[i]] <- xi
body:     }
body:     nr <- max(nrows)
body:     for (i in seq_len(n)[nrows < nr]) {
body:         xi <- vlist[[i]]
body:         if (nrows[i] > 0L && (nr%%nrows[i] == 0L)) {
body:             xi <- unclass(xi)
body:             fixed <- TRUE
body:             for (j in seq_along(xi)) {
body:                 xi1 <- xi[[j]]
body:                 if (is.vector(xi1) || is.factor(xi1)) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else if (is.character(xi1) && inherits(xi1, "AsIs")) 
body:                   xi[[j]] <- structure(rep(xi1, length.out = nr), class = class(xi1))
body:                 else if (inherits(xi1, "Date") || inherits(xi1, "POSIXct")) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else {
body:                   fixed <- FALSE
body:                   break
body:                 }
body:             }
body:             if (fixed) {
body:                 vlist[[i]] <- xi
body:                 next
body:             }
body:         }
body:         stop(gettextf("arguments imply differing number of rows: %s", paste(unique(nrows), collapse = ", ")), domain = NA)
body:     }
body:     value <- unlist(vlist, recursive = FALSE, use.names = FALSE)
body:     vnames <- unlist(vnames[ncols > 0L])
body:     noname <- !nzchar(vnames)
body:     if (any(noname)) 
body:         vnames[noname] <- paste("Var", seq_along(vnames), sep = ".")[noname]
body:     if (check.names) 
body:         vnames <- make.names(vnames, unique = TRUE)
body:     names(value) <- vnames
body:     if (!mrn) {
body:         if (length(row.names) == 1L && nr != 1L) {
body:             if (is.character(row.names)) 
body:                 row.names <- match(row.names, vnames, 0L)
body:             if (length(row.names) != 1L || row.names < 1L || row.names > length(vnames)) 
body:                 stop("'row.names' should specify one of the variables")
body:             i <- row.names
body:             row.names <- value[[i]]
body:             value <- value[-i]
body:         }
body:         else if (!is.null(row.names) && length(row.names) != nr) 
body:             stop("row names supplied are of the wrong length")
body:     }
body:     else if (!is.null(row.names) && length(row.names) != nr) {
body:         warning("row names were found from a short variable and have been discarded")
body:         row.names <- NULL
body:     }
body:     if (is.null(row.names)) 
body:         row.names <- .set_row_names(nr)
body:     else {
body:         if (is.object(row.names) || !is.integer(row.names)) 
body:             row.names <- as.character(row.names)
body:         if (any(is.na(row.names))) 
body:             stop("row names contain missing values")
body:         if (anyDuplicated(row.names)) 
body:             stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:     }
body:     attr(value, "row.names") <- row.names
body:     attr(value, "class") <- "data.frame"
body:     value
body: }
args: list(name = "R-exts", path = "/home/roman/r-instrumented/tests/R-exts.so", dynamicLookup = TRUE, check.names = TRUE, stringsAsFactors = TRUE)
retn: structure(list(name = structure(1L, .Label = "R-exts", class = "factor"), path = structure(1L, .Label = "/home/roman/r-instrumented/tests/R-exts.so", class = "factor"), dynamicLookup = TRUE), .Names = c("name", "path", "dynamicLookup"), row.names = c(NA, -1L), class = "data.frame")

func: quote(data.frame)
body: function (..., row.names = NULL, check.rows = FALSE, check.names = TRUE, stringsAsFactors = default.stringsAsFactors()) 
body: {
body:     data.row.names <- if (check.rows && is.null(row.names)) 
body:         function(current, new, i) {
body:             if (is.character(current)) 
body:                 new <- as.character(new)
body:             if (is.character(new)) 
body:                 current <- as.character(current)
body:             if (anyDuplicated(new)) 
body:                 return(current)
body:             if (is.null(current)) 
body:                 return(new)
body:             if (all(current == new) || all(current == "")) 
body:                 return(new)
body:             stop(gettextf("mismatch of row names in arguments of 'data.frame', item %d", i), domain = NA)
body:         }
body:     else function(current, new, i) {
body:         if (is.null(current)) {
body:             if (anyDuplicated(new)) {
body:                 warning(gettextf("some row.names duplicated: %s --> row.names NOT used", paste(which(duplicated(new)), collapse = ",")), domain = NA)
body:                 current
body:             }
body:             else new
body:         }
body:         else current
body:     }
body:     object <- as.list(substitute(list(...)))[-1L]
body:     mirn <- missing(row.names)
body:     mrn <- is.null(row.names)
body:     x <- list(...)
body:     n <- length(x)
body:     if (n < 1L) {
body:         if (!mrn) {
body:             if (is.object(row.names) || !is.integer(row.names)) 
body:                 row.names <- as.character(row.names)
body:             if (any(is.na(row.names))) 
body:                 stop("row names contain missing values")
body:             if (anyDuplicated(row.names)) 
body:                 stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:         }
body:         else row.names <- integer()
body:         return(structure(list(), names = character(), row.names = row.names, class = "data.frame"))
body:     }
body:     vnames <- names(x)
body:     if (length(vnames) != n) 
body:         vnames <- character(n)
body:     no.vn <- !nzchar(vnames)
body:     vlist <- vnames <- as.list(vnames)
body:     nrows <- ncols <- integer(n)
body:     for (i in seq_len(n)) {
body:         xi <- if (is.character(x[[i]]) || is.list(x[[i]])) 
body:             as.data.frame(x[[i]], optional = TRUE, stringsAsFactors = stringsAsFactors)
body:         else as.data.frame(x[[i]], optional = TRUE)
body:         nrows[i] <- .row_names_info(xi)
body:         ncols[i] <- length(xi)
body:         namesi <- names(xi)
body:         if (ncols[i] > 1L) {
body:             if (length(namesi) == 0L) 
body:                 namesi <- seq_len(ncols[i])
body:             if (no.vn[i]) 
body:                 vnames[[i]] <- namesi
body:             else vnames[[i]] <- paste(vnames[[i]], namesi, sep = ".")
body:         }
body:         else {
body:             if (length(namesi)) 
body:                 vnames[[i]] <- namesi
body:             else if (no.vn[[i]]) {
body:                 tmpname <- deparse(object[[i]])[1L]
body:                 if (substr(tmpname, 1L, 2L) == "I(") {
body:                   ntmpn <- nchar(tmpname, "c")
body:                   if (substr(tmpname, ntmpn, ntmpn) == ")") 
body:                     tmpname <- substr(tmpname, 3L, ntmpn - 1L)
body:                 }
body:                 vnames[[i]] <- tmpname
body:             }
body:         }
body:         if (mirn && nrows[i] > 0L) {
body:             rowsi <- attr(xi, "row.names")
body:             nc <- nchar(rowsi, allowNA = FALSE)
body:             nc <- nc[!is.na(nc)]
body:             if (length(nc) && any(nc)) 
body:                 row.names <- data.row.names(row.names, rowsi, i)
body:         }
body:         nrows[i] <- abs(nrows[i])
body:         vlist[[i]] <- xi
body:     }
body:     nr <- max(nrows)
body:     for (i in seq_len(n)[nrows < nr]) {
body:         xi <- vlist[[i]]
body:         if (nrows[i] > 0L && (nr%%nrows[i] == 0L)) {
body:             xi <- unclass(xi)
body:             fixed <- TRUE
body:             for (j in seq_along(xi)) {
body:                 xi1 <- xi[[j]]
body:                 if (is.vector(xi1) || is.factor(xi1)) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else if (is.character(xi1) && inherits(xi1, "AsIs")) 
body:                   xi[[j]] <- structure(rep(xi1, length.out = nr), class = class(xi1))
body:                 else if (inherits(xi1, "Date") || inherits(xi1, "POSIXct")) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else {
body:                   fixed <- FALSE
body:                   break
body:                 }
body:             }
body:             if (fixed) {
body:                 vlist[[i]] <- xi
body:                 next
body:             }
body:         }
body:         stop(gettextf("arguments imply differing number of rows: %s", paste(unique(nrows), collapse = ", ")), domain = NA)
body:     }
body:     value <- unlist(vlist, recursive = FALSE, use.names = FALSE)
body:     vnames <- unlist(vnames[ncols > 0L])
body:     noname <- !nzchar(vnames)
body:     if (any(noname)) 
body:         vnames[noname] <- paste("Var", seq_along(vnames), sep = ".")[noname]
body:     if (check.names) 
body:         vnames <- make.names(vnames, unique = TRUE)
body:     names(value) <- vnames
body:     if (!mrn) {
body:         if (length(row.names) == 1L && nr != 1L) {
body:             if (is.character(row.names)) 
body:                 row.names <- match(row.names, vnames, 0L)
body:             if (length(row.names) != 1L || row.names < 1L || row.names > length(vnames)) 
body:                 stop("'row.names' should specify one of the variables")
body:             i <- row.names
body:             row.names <- value[[i]]
body:             value <- value[-i]
body:         }
body:         else if (!is.null(row.names) && length(row.names) != nr) 
body:             stop("row names supplied are of the wrong length")
body:     }
body:     else if (!is.null(row.names) && length(row.names) != nr) {
body:         warning("row names were found from a short variable and have been discarded")
body:         row.names <- NULL
body:     }
body:     if (is.null(row.names)) 
body:         row.names <- .set_row_names(nr)
body:     else {
body:         if (is.object(row.names) || !is.integer(row.names)) 
body:             row.names <- as.character(row.names)
body:         if (any(is.na(row.names))) 
body:             stop("row names contain missing values")
body:         if (anyDuplicated(row.names)) 
body:             stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:     }
body:     attr(value, "row.names") <- row.names
body:     attr(value, "class") <- "data.frame"
body:     value
body: }
args: list(check.names = TRUE, stringsAsFactors = TRUE)
retn: structure(list(), .Names = character(0), row.names = integer(0), class = "data.frame")

func: quote(data.frame)
body: function (..., row.names = NULL, check.rows = FALSE, check.names = TRUE, stringsAsFactors = default.stringsAsFactors()) 
body: {
body:     data.row.names <- if (check.rows && is.null(row.names)) 
body:         function(current, new, i) {
body:             if (is.character(current)) 
body:                 new <- as.character(new)
body:             if (is.character(new)) 
body:                 current <- as.character(current)
body:             if (anyDuplicated(new)) 
body:                 return(current)
body:             if (is.null(current)) 
body:                 return(new)
body:             if (all(current == new) || all(current == "")) 
body:                 return(new)
body:             stop(gettextf("mismatch of row names in arguments of 'data.frame', item %d", i), domain = NA)
body:         }
body:     else function(current, new, i) {
body:         if (is.null(current)) {
body:             if (anyDuplicated(new)) {
body:                 warning(gettextf("some row.names duplicated: %s --> row.names NOT used", paste(which(duplicated(new)), collapse = ",")), domain = NA)
body:                 current
body:             }
body:             else new
body:         }
body:         else current
body:     }
body:     object <- as.list(substitute(list(...)))[-1L]
body:     mirn <- missing(row.names)
body:     mrn <- is.null(row.names)
body:     x <- list(...)
body:     n <- length(x)
body:     if (n < 1L) {
body:         if (!mrn) {
body:             if (is.object(row.names) || !is.integer(row.names)) 
body:                 row.names <- as.character(row.names)
body:             if (any(is.na(row.names))) 
body:                 stop("row names contain missing values")
body:             if (anyDuplicated(row.names)) 
body:                 stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:         }
body:         else row.names <- integer()
body:         return(structure(list(), names = character(), row.names = row.names, class = "data.frame"))
body:     }
body:     vnames <- names(x)
body:     if (length(vnames) != n) 
body:         vnames <- character(n)
body:     no.vn <- !nzchar(vnames)
body:     vlist <- vnames <- as.list(vnames)
body:     nrows <- ncols <- integer(n)
body:     for (i in seq_len(n)) {
body:         xi <- if (is.character(x[[i]]) || is.list(x[[i]])) 
body:             as.data.frame(x[[i]], optional = TRUE, stringsAsFactors = stringsAsFactors)
body:         else as.data.frame(x[[i]], optional = TRUE)
body:         nrows[i] <- .row_names_info(xi)
body:         ncols[i] <- length(xi)
body:         namesi <- names(xi)
body:         if (ncols[i] > 1L) {
body:             if (length(namesi) == 0L) 
body:                 namesi <- seq_len(ncols[i])
body:             if (no.vn[i]) 
body:                 vnames[[i]] <- namesi
body:             else vnames[[i]] <- paste(vnames[[i]], namesi, sep = ".")
body:         }
body:         else {
body:             if (length(namesi)) 
body:                 vnames[[i]] <- namesi
body:             else if (no.vn[[i]]) {
body:                 tmpname <- deparse(object[[i]])[1L]
body:                 if (substr(tmpname, 1L, 2L) == "I(") {
body:                   ntmpn <- nchar(tmpname, "c")
body:                   if (substr(tmpname, ntmpn, ntmpn) == ")") 
body:                     tmpname <- substr(tmpname, 3L, ntmpn - 1L)
body:                 }
body:                 vnames[[i]] <- tmpname
body:             }
body:         }
body:         if (mirn && nrows[i] > 0L) {
body:             rowsi <- attr(xi, "row.names")
body:             nc <- nchar(rowsi, allowNA = FALSE)
body:             nc <- nc[!is.na(nc)]
body:             if (length(nc) && any(nc)) 
body:                 row.names <- data.row.names(row.names, rowsi, i)
body:         }
body:         nrows[i] <- abs(nrows[i])
body:         vlist[[i]] <- xi
body:     }
body:     nr <- max(nrows)
body:     for (i in seq_len(n)[nrows < nr]) {
body:         xi <- vlist[[i]]
body:         if (nrows[i] > 0L && (nr%%nrows[i] == 0L)) {
body:             xi <- unclass(xi)
body:             fixed <- TRUE
body:             for (j in seq_along(xi)) {
body:                 xi1 <- xi[[j]]
body:                 if (is.vector(xi1) || is.factor(xi1)) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else if (is.character(xi1) && inherits(xi1, "AsIs")) 
body:                   xi[[j]] <- structure(rep(xi1, length.out = nr), class = class(xi1))
body:                 else if (inherits(xi1, "Date") || inherits(xi1, "POSIXct")) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else {
body:                   fixed <- FALSE
body:                   break
body:                 }
body:             }
body:             if (fixed) {
body:                 vlist[[i]] <- xi
body:                 next
body:             }
body:         }
body:         stop(gettextf("arguments imply differing number of rows: %s", paste(unique(nrows), collapse = ", ")), domain = NA)
body:     }
body:     value <- unlist(vlist, recursive = FALSE, use.names = FALSE)
body:     vnames <- unlist(vnames[ncols > 0L])
body:     noname <- !nzchar(vnames)
body:     if (any(noname)) 
body:         vnames[noname] <- paste("Var", seq_along(vnames), sep = ".")[noname]
body:     if (check.names) 
body:         vnames <- make.names(vnames, unique = TRUE)
body:     names(value) <- vnames
body:     if (!mrn) {
body:         if (length(row.names) == 1L && nr != 1L) {
body:             if (is.character(row.names)) 
body:                 row.names <- match(row.names, vnames, 0L)
body:             if (length(row.names) != 1L || row.names < 1L || row.names > length(vnames)) 
body:                 stop("'row.names' should specify one of the variables")
body:             i <- row.names
body:             row.names <- value[[i]]
body:             value <- value[-i]
body:         }
body:         else if (!is.null(row.names) && length(row.names) != nr) 
body:             stop("row names supplied are of the wrong length")
body:     }
body:     else if (!is.null(row.names) && length(row.names) != nr) {
body:         warning("row names were found from a short variable and have been discarded")
body:         row.names <- NULL
body:     }
body:     if (is.null(row.names)) 
body:         row.names <- .set_row_names(nr)
body:     else {
body:         if (is.object(row.names) || !is.integer(row.names)) 
body:             row.names <- as.character(row.names)
body:         if (any(is.na(row.names))) 
body:             stop("row names contain missing values")
body:         if (anyDuplicated(row.names)) 
body:             stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:     }
body:     attr(value, "row.names") <- row.names
body:     attr(value, "class") <- "data.frame"
body:     value
body: }
args: list(a = 1, check.names = TRUE, stringsAsFactors = TRUE)
retn: structure(list(a = 1), .Names = "a", row.names = c(NA, -1L), class = "data.frame")

func: quote(data.frame)
body: function (..., row.names = NULL, check.rows = FALSE, check.names = TRUE, stringsAsFactors = default.stringsAsFactors()) 
body: {
body:     data.row.names <- if (check.rows && is.null(row.names)) 
body:         function(current, new, i) {
body:             if (is.character(current)) 
body:                 new <- as.character(new)
body:             if (is.character(new)) 
body:                 current <- as.character(current)
body:             if (anyDuplicated(new)) 
body:                 return(current)
body:             if (is.null(current)) 
body:                 return(new)
body:             if (all(current == new) || all(current == "")) 
body:                 return(new)
body:             stop(gettextf("mismatch of row names in arguments of 'data.frame', item %d", i), domain = NA)
body:         }
body:     else function(current, new, i) {
body:         if (is.null(current)) {
body:             if (anyDuplicated(new)) {
body:                 warning(gettextf("some row.names duplicated: %s --> row.names NOT used", paste(which(duplicated(new)), collapse = ",")), domain = NA)
body:                 current
body:             }
body:             else new
body:         }
body:         else current
body:     }
body:     object <- as.list(substitute(list(...)))[-1L]
body:     mirn <- missing(row.names)
body:     mrn <- is.null(row.names)
body:     x <- list(...)
body:     n <- length(x)
body:     if (n < 1L) {
body:         if (!mrn) {
body:             if (is.object(row.names) || !is.integer(row.names)) 
body:                 row.names <- as.character(row.names)
body:             if (any(is.na(row.names))) 
body:                 stop("row names contain missing values")
body:             if (anyDuplicated(row.names)) 
body:                 stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:         }
body:         else row.names <- integer()
body:         return(structure(list(), names = character(), row.names = row.names, class = "data.frame"))
body:     }
body:     vnames <- names(x)
body:     if (length(vnames) != n) 
body:         vnames <- character(n)
body:     no.vn <- !nzchar(vnames)
body:     vlist <- vnames <- as.list(vnames)
body:     nrows <- ncols <- integer(n)
body:     for (i in seq_len(n)) {
body:         xi <- if (is.character(x[[i]]) || is.list(x[[i]])) 
body:             as.data.frame(x[[i]], optional = TRUE, stringsAsFactors = stringsAsFactors)
body:         else as.data.frame(x[[i]], optional = TRUE)
body:         nrows[i] <- .row_names_info(xi)
body:         ncols[i] <- length(xi)
body:         namesi <- names(xi)
body:         if (ncols[i] > 1L) {
body:             if (length(namesi) == 0L) 
body:                 namesi <- seq_len(ncols[i])
body:             if (no.vn[i]) 
body:                 vnames[[i]] <- namesi
body:             else vnames[[i]] <- paste(vnames[[i]], namesi, sep = ".")
body:         }
body:         else {
body:             if (length(namesi)) 
body:                 vnames[[i]] <- namesi
body:             else if (no.vn[[i]]) {
body:                 tmpname <- deparse(object[[i]])[1L]
body:                 if (substr(tmpname, 1L, 2L) == "I(") {
body:                   ntmpn <- nchar(tmpname, "c")
body:                   if (substr(tmpname, ntmpn, ntmpn) == ")") 
body:                     tmpname <- substr(tmpname, 3L, ntmpn - 1L)
body:                 }
body:                 vnames[[i]] <- tmpname
body:             }
body:         }
body:         if (mirn && nrows[i] > 0L) {
body:             rowsi <- attr(xi, "row.names")
body:             nc <- nchar(rowsi, allowNA = FALSE)
body:             nc <- nc[!is.na(nc)]
body:             if (length(nc) && any(nc)) 
body:                 row.names <- data.row.names(row.names, rowsi, i)
body:         }
body:         nrows[i] <- abs(nrows[i])
body:         vlist[[i]] <- xi
body:     }
body:     nr <- max(nrows)
body:     for (i in seq_len(n)[nrows < nr]) {
body:         xi <- vlist[[i]]
body:         if (nrows[i] > 0L && (nr%%nrows[i] == 0L)) {
body:             xi <- unclass(xi)
body:             fixed <- TRUE
body:             for (j in seq_along(xi)) {
body:                 xi1 <- xi[[j]]
body:                 if (is.vector(xi1) || is.factor(xi1)) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else if (is.character(xi1) && inherits(xi1, "AsIs")) 
body:                   xi[[j]] <- structure(rep(xi1, length.out = nr), class = class(xi1))
body:                 else if (inherits(xi1, "Date") || inherits(xi1, "POSIXct")) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else {
body:                   fixed <- FALSE
body:                   break
body:                 }
body:             }
body:             if (fixed) {
body:                 vlist[[i]] <- xi
body:                 next
body:             }
body:         }
body:         stop(gettextf("arguments imply differing number of rows: %s", paste(unique(nrows), collapse = ", ")), domain = NA)
body:     }
body:     value <- unlist(vlist, recursive = FALSE, use.names = FALSE)
body:     vnames <- unlist(vnames[ncols > 0L])
body:     noname <- !nzchar(vnames)
body:     if (any(noname)) 
body:         vnames[noname] <- paste("Var", seq_along(vnames), sep = ".")[noname]
body:     if (check.names) 
body:         vnames <- make.names(vnames, unique = TRUE)
body:     names(value) <- vnames
body:     if (!mrn) {
body:         if (length(row.names) == 1L && nr != 1L) {
body:             if (is.character(row.names)) 
body:                 row.names <- match(row.names, vnames, 0L)
body:             if (length(row.names) != 1L || row.names < 1L || row.names > length(vnames)) 
body:                 stop("'row.names' should specify one of the variables")
body:             i <- row.names
body:             row.names <- value[[i]]
body:             value <- value[-i]
body:         }
body:         else if (!is.null(row.names) && length(row.names) != nr) 
body:             stop("row names supplied are of the wrong length")
body:     }
body:     else if (!is.null(row.names) && length(row.names) != nr) {
body:         warning("row names were found from a short variable and have been discarded")
body:         row.names <- NULL
body:     }
body:     if (is.null(row.names)) 
body:         row.names <- .set_row_names(nr)
body:     else {
body:         if (is.object(row.names) || !is.integer(row.names)) 
body:             row.names <- as.character(row.names)
body:         if (any(is.na(row.names))) 
body:             stop("row names contain missing values")
body:         if (anyDuplicated(row.names)) 
body:             stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:     }
body:     attr(value, "row.names") <- row.names
body:     attr(value, "class") <- "data.frame"
body:     value
body: }
args: list(c0 = logical(0), check.names = FALSE, stringsAsFactors = TRUE)
retn: structure(list(c0 = logical(0)), .Names = "c0", row.names = integer(0), class = "data.frame")

func: quote(data.frame)
body: function (..., row.names = NULL, check.rows = FALSE, check.names = TRUE, stringsAsFactors = default.stringsAsFactors()) 
body: {
body:     data.row.names <- if (check.rows && is.null(row.names)) 
body:         function(current, new, i) {
body:             if (is.character(current)) 
body:                 new <- as.character(new)
body:             if (is.character(new)) 
body:                 current <- as.character(current)
body:             if (anyDuplicated(new)) 
body:                 return(current)
body:             if (is.null(current)) 
body:                 return(new)
body:             if (all(current == new) || all(current == "")) 
body:                 return(new)
body:             stop(gettextf("mismatch of row names in arguments of 'data.frame', item %d", i), domain = NA)
body:         }
body:     else function(current, new, i) {
body:         if (is.null(current)) {
body:             if (anyDuplicated(new)) {
body:                 warning(gettextf("some row.names duplicated: %s --> row.names NOT used", paste(which(duplicated(new)), collapse = ",")), domain = NA)
body:                 current
body:             }
body:             else new
body:         }
body:         else current
body:     }
body:     object <- as.list(substitute(list(...)))[-1L]
body:     mirn <- missing(row.names)
body:     mrn <- is.null(row.names)
body:     x <- list(...)
body:     n <- length(x)
body:     if (n < 1L) {
body:         if (!mrn) {
body:             if (is.object(row.names) || !is.integer(row.names)) 
body:                 row.names <- as.character(row.names)
body:             if (any(is.na(row.names))) 
body:                 stop("row names contain missing values")
body:             if (anyDuplicated(row.names)) 
body:                 stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:         }
body:         else row.names <- integer()
body:         return(structure(list(), names = character(), row.names = row.names, class = "data.frame"))
body:     }
body:     vnames <- names(x)
body:     if (length(vnames) != n) 
body:         vnames <- character(n)
body:     no.vn <- !nzchar(vnames)
body:     vlist <- vnames <- as.list(vnames)
body:     nrows <- ncols <- integer(n)
body:     for (i in seq_len(n)) {
body:         xi <- if (is.character(x[[i]]) || is.list(x[[i]])) 
body:             as.data.frame(x[[i]], optional = TRUE, stringsAsFactors = stringsAsFactors)
body:         else as.data.frame(x[[i]], optional = TRUE)
body:         nrows[i] <- .row_names_info(xi)
body:         ncols[i] <- length(xi)
body:         namesi <- names(xi)
body:         if (ncols[i] > 1L) {
body:             if (length(namesi) == 0L) 
body:                 namesi <- seq_len(ncols[i])
body:             if (no.vn[i]) 
body:                 vnames[[i]] <- namesi
body:             else vnames[[i]] <- paste(vnames[[i]], namesi, sep = ".")
body:         }
body:         else {
body:             if (length(namesi)) 
body:                 vnames[[i]] <- namesi
body:             else if (no.vn[[i]]) {
body:                 tmpname <- deparse(object[[i]])[1L]
body:                 if (substr(tmpname, 1L, 2L) == "I(") {
body:                   ntmpn <- nchar(tmpname, "c")
body:                   if (substr(tmpname, ntmpn, ntmpn) == ")") 
body:                     tmpname <- substr(tmpname, 3L, ntmpn - 1L)
body:                 }
body:                 vnames[[i]] <- tmpname
body:             }
body:         }
body:         if (mirn && nrows[i] > 0L) {
body:             rowsi <- attr(xi, "row.names")
body:             nc <- nchar(rowsi, allowNA = FALSE)
body:             nc <- nc[!is.na(nc)]
body:             if (length(nc) && any(nc)) 
body:                 row.names <- data.row.names(row.names, rowsi, i)
body:         }
body:         nrows[i] <- abs(nrows[i])
body:         vlist[[i]] <- xi
body:     }
body:     nr <- max(nrows)
body:     for (i in seq_len(n)[nrows < nr]) {
body:         xi <- vlist[[i]]
body:         if (nrows[i] > 0L && (nr%%nrows[i] == 0L)) {
body:             xi <- unclass(xi)
body:             fixed <- TRUE
body:             for (j in seq_along(xi)) {
body:                 xi1 <- xi[[j]]
body:                 if (is.vector(xi1) || is.factor(xi1)) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else if (is.character(xi1) && inherits(xi1, "AsIs")) 
body:                   xi[[j]] <- structure(rep(xi1, length.out = nr), class = class(xi1))
body:                 else if (inherits(xi1, "Date") || inherits(xi1, "POSIXct")) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else {
body:                   fixed <- FALSE
body:                   break
body:                 }
body:             }
body:             if (fixed) {
body:                 vlist[[i]] <- xi
body:                 next
body:             }
body:         }
body:         stop(gettextf("arguments imply differing number of rows: %s", paste(unique(nrows), collapse = ", ")), domain = NA)
body:     }
body:     value <- unlist(vlist, recursive = FALSE, use.names = FALSE)
body:     vnames <- unlist(vnames[ncols > 0L])
body:     noname <- !nzchar(vnames)
body:     if (any(noname)) 
body:         vnames[noname] <- paste("Var", seq_along(vnames), sep = ".")[noname]
body:     if (check.names) 
body:         vnames <- make.names(vnames, unique = TRUE)
body:     names(value) <- vnames
body:     if (!mrn) {
body:         if (length(row.names) == 1L && nr != 1L) {
body:             if (is.character(row.names)) 
body:                 row.names <- match(row.names, vnames, 0L)
body:             if (length(row.names) != 1L || row.names < 1L || row.names > length(vnames)) 
body:                 stop("'row.names' should specify one of the variables")
body:             i <- row.names
body:             row.names <- value[[i]]
body:             value <- value[-i]
body:         }
body:         else if (!is.null(row.names) && length(row.names) != nr) 
body:             stop("row names supplied are of the wrong length")
body:     }
body:     else if (!is.null(row.names) && length(row.names) != nr) {
body:         warning("row names were found from a short variable and have been discarded")
body:         row.names <- NULL
body:     }
body:     if (is.null(row.names)) 
body:         row.names <- .set_row_names(nr)
body:     else {
body:         if (is.object(row.names) || !is.integer(row.names)) 
body:             row.names <- as.character(row.names)
body:         if (any(is.na(row.names))) 
body:             stop("row names contain missing values")
body:         if (anyDuplicated(row.names)) 
body:             stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:     }
body:     attr(value, "row.names") <- row.names
body:     attr(value, "class") <- "data.frame"
body:     value
body: }
args: list(c0 = NA, check.names = FALSE, stringsAsFactors = TRUE)
retn: structure(list(c0 = NA), .Names = "c0", row.names = c(NA, -1L), class = "data.frame")

func: quote(data.frame)
body: function (..., row.names = NULL, check.rows = FALSE, check.names = TRUE, stringsAsFactors = default.stringsAsFactors()) 
body: {
body:     data.row.names <- if (check.rows && is.null(row.names)) 
body:         function(current, new, i) {
body:             if (is.character(current)) 
body:                 new <- as.character(new)
body:             if (is.character(new)) 
body:                 current <- as.character(current)
body:             if (anyDuplicated(new)) 
body:                 return(current)
body:             if (is.null(current)) 
body:                 return(new)
body:             if (all(current == new) || all(current == "")) 
body:                 return(new)
body:             stop(gettextf("mismatch of row names in arguments of 'data.frame', item %d", i), domain = NA)
body:         }
body:     else function(current, new, i) {
body:         if (is.null(current)) {
body:             if (anyDuplicated(new)) {
body:                 warning(gettextf("some row.names duplicated: %s --> row.names NOT used", paste(which(duplicated(new)), collapse = ",")), domain = NA)
body:                 current
body:             }
body:             else new
body:         }
body:         else current
body:     }
body:     object <- as.list(substitute(list(...)))[-1L]
body:     mirn <- missing(row.names)
body:     mrn <- is.null(row.names)
body:     x <- list(...)
body:     n <- length(x)
body:     if (n < 1L) {
body:         if (!mrn) {
body:             if (is.object(row.names) || !is.integer(row.names)) 
body:                 row.names <- as.character(row.names)
body:             if (any(is.na(row.names))) 
body:                 stop("row names contain missing values")
body:             if (anyDuplicated(row.names)) 
body:                 stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:         }
body:         else row.names <- integer()
body:         return(structure(list(), names = character(), row.names = row.names, class = "data.frame"))
body:     }
body:     vnames <- names(x)
body:     if (length(vnames) != n) 
body:         vnames <- character(n)
body:     no.vn <- !nzchar(vnames)
body:     vlist <- vnames <- as.list(vnames)
body:     nrows <- ncols <- integer(n)
body:     for (i in seq_len(n)) {
body:         xi <- if (is.character(x[[i]]) || is.list(x[[i]])) 
body:             as.data.frame(x[[i]], optional = TRUE, stringsAsFactors = stringsAsFactors)
body:         else as.data.frame(x[[i]], optional = TRUE)
body:         nrows[i] <- .row_names_info(xi)
body:         ncols[i] <- length(xi)
body:         namesi <- names(xi)
body:         if (ncols[i] > 1L) {
body:             if (length(namesi) == 0L) 
body:                 namesi <- seq_len(ncols[i])
body:             if (no.vn[i]) 
body:                 vnames[[i]] <- namesi
body:             else vnames[[i]] <- paste(vnames[[i]], namesi, sep = ".")
body:         }
body:         else {
body:             if (length(namesi)) 
body:                 vnames[[i]] <- namesi
body:             else if (no.vn[[i]]) {
body:                 tmpname <- deparse(object[[i]])[1L]
body:                 if (substr(tmpname, 1L, 2L) == "I(") {
body:                   ntmpn <- nchar(tmpname, "c")
body:                   if (substr(tmpname, ntmpn, ntmpn) == ")") 
body:                     tmpname <- substr(tmpname, 3L, ntmpn - 1L)
body:                 }
body:                 vnames[[i]] <- tmpname
body:             }
body:         }
body:         if (mirn && nrows[i] > 0L) {
body:             rowsi <- attr(xi, "row.names")
body:             nc <- nchar(rowsi, allowNA = FALSE)
body:             nc <- nc[!is.na(nc)]
body:             if (length(nc) && any(nc)) 
body:                 row.names <- data.row.names(row.names, rowsi, i)
body:         }
body:         nrows[i] <- abs(nrows[i])
body:         vlist[[i]] <- xi
body:     }
body:     nr <- max(nrows)
body:     for (i in seq_len(n)[nrows < nr]) {
body:         xi <- vlist[[i]]
body:         if (nrows[i] > 0L && (nr%%nrows[i] == 0L)) {
body:             xi <- unclass(xi)
body:             fixed <- TRUE
body:             for (j in seq_along(xi)) {
body:                 xi1 <- xi[[j]]
body:                 if (is.vector(xi1) || is.factor(xi1)) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else if (is.character(xi1) && inherits(xi1, "AsIs")) 
body:                   xi[[j]] <- structure(rep(xi1, length.out = nr), class = class(xi1))
body:                 else if (inherits(xi1, "Date") || inherits(xi1, "POSIXct")) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else {
body:                   fixed <- FALSE
body:                   break
body:                 }
body:             }
body:             if (fixed) {
body:                 vlist[[i]] <- xi
body:                 next
body:             }
body:         }
body:         stop(gettextf("arguments imply differing number of rows: %s", paste(unique(nrows), collapse = ", ")), domain = NA)
body:     }
body:     value <- unlist(vlist, recursive = FALSE, use.names = FALSE)
body:     vnames <- unlist(vnames[ncols > 0L])
body:     noname <- !nzchar(vnames)
body:     if (any(noname)) 
body:         vnames[noname] <- paste("Var", seq_along(vnames), sep = ".")[noname]
body:     if (check.names) 
body:         vnames <- make.names(vnames, unique = TRUE)
body:     names(value) <- vnames
body:     if (!mrn) {
body:         if (length(row.names) == 1L && nr != 1L) {
body:             if (is.character(row.names)) 
body:                 row.names <- match(row.names, vnames, 0L)
body:             if (length(row.names) != 1L || row.names < 1L || row.names > length(vnames)) 
body:                 stop("'row.names' should specify one of the variables")
body:             i <- row.names
body:             row.names <- value[[i]]
body:             value <- value[-i]
body:         }
body:         else if (!is.null(row.names) && length(row.names) != nr) 
body:             stop("row names supplied are of the wrong length")
body:     }
body:     else if (!is.null(row.names) && length(row.names) != nr) {
body:         warning("row names were found from a short variable and have been discarded")
body:         row.names <- NULL
body:     }
body:     if (is.null(row.names)) 
body:         row.names <- .set_row_names(nr)
body:     else {
body:         if (is.object(row.names) || !is.integer(row.names)) 
body:             row.names <- as.character(row.names)
body:         if (any(is.na(row.names))) 
body:             stop("row names contain missing values")
body:         if (anyDuplicated(row.names)) 
body:             stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:     }
body:     attr(value, "row.names") <- row.names
body:     attr(value, "class") <- "data.frame"
body:     value
body: }
args: list(c0 = structure(character(0), class = "AsIs"), check.names = FALSE, row.names = character(0))
retn: structure(list(c0 = structure(character(0), class = "AsIs")), .Names = "c0", row.names = character(0), class = "data.frame")

func: quote(data.frame)
body: function (..., row.names = NULL, check.rows = FALSE, check.names = TRUE, stringsAsFactors = default.stringsAsFactors()) 
body: {
body:     data.row.names <- if (check.rows && is.null(row.names)) 
body:         function(current, new, i) {
body:             if (is.character(current)) 
body:                 new <- as.character(new)
body:             if (is.character(new)) 
body:                 current <- as.character(current)
body:             if (anyDuplicated(new)) 
body:                 return(current)
body:             if (is.null(current)) 
body:                 return(new)
body:             if (all(current == new) || all(current == "")) 
body:                 return(new)
body:             stop(gettextf("mismatch of row names in arguments of 'data.frame', item %d", i), domain = NA)
body:         }
body:     else function(current, new, i) {
body:         if (is.null(current)) {
body:             if (anyDuplicated(new)) {
body:                 warning(gettextf("some row.names duplicated: %s --> row.names NOT used", paste(which(duplicated(new)), collapse = ",")), domain = NA)
body:                 current
body:             }
body:             else new
body:         }
body:         else current
body:     }
body:     object <- as.list(substitute(list(...)))[-1L]
body:     mirn <- missing(row.names)
body:     mrn <- is.null(row.names)
body:     x <- list(...)
body:     n <- length(x)
body:     if (n < 1L) {
body:         if (!mrn) {
body:             if (is.object(row.names) || !is.integer(row.names)) 
body:                 row.names <- as.character(row.names)
body:             if (any(is.na(row.names))) 
body:                 stop("row names contain missing values")
body:             if (anyDuplicated(row.names)) 
body:                 stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:         }
body:         else row.names <- integer()
body:         return(structure(list(), names = character(), row.names = row.names, class = "data.frame"))
body:     }
body:     vnames <- names(x)
body:     if (length(vnames) != n) 
body:         vnames <- character(n)
body:     no.vn <- !nzchar(vnames)
body:     vlist <- vnames <- as.list(vnames)
body:     nrows <- ncols <- integer(n)
body:     for (i in seq_len(n)) {
body:         xi <- if (is.character(x[[i]]) || is.list(x[[i]])) 
body:             as.data.frame(x[[i]], optional = TRUE, stringsAsFactors = stringsAsFactors)
body:         else as.data.frame(x[[i]], optional = TRUE)
body:         nrows[i] <- .row_names_info(xi)
body:         ncols[i] <- length(xi)
body:         namesi <- names(xi)
body:         if (ncols[i] > 1L) {
body:             if (length(namesi) == 0L) 
body:                 namesi <- seq_len(ncols[i])
body:             if (no.vn[i]) 
body:                 vnames[[i]] <- namesi
body:             else vnames[[i]] <- paste(vnames[[i]], namesi, sep = ".")
body:         }
body:         else {
body:             if (length(namesi)) 
body:                 vnames[[i]] <- namesi
body:             else if (no.vn[[i]]) {
body:                 tmpname <- deparse(object[[i]])[1L]
body:                 if (substr(tmpname, 1L, 2L) == "I(") {
body:                   ntmpn <- nchar(tmpname, "c")
body:                   if (substr(tmpname, ntmpn, ntmpn) == ")") 
body:                     tmpname <- substr(tmpname, 3L, ntmpn - 1L)
body:                 }
body:                 vnames[[i]] <- tmpname
body:             }
body:         }
body:         if (mirn && nrows[i] > 0L) {
body:             rowsi <- attr(xi, "row.names")
body:             nc <- nchar(rowsi, allowNA = FALSE)
body:             nc <- nc[!is.na(nc)]
body:             if (length(nc) && any(nc)) 
body:                 row.names <- data.row.names(row.names, rowsi, i)
body:         }
body:         nrows[i] <- abs(nrows[i])
body:         vlist[[i]] <- xi
body:     }
body:     nr <- max(nrows)
body:     for (i in seq_len(n)[nrows < nr]) {
body:         xi <- vlist[[i]]
body:         if (nrows[i] > 0L && (nr%%nrows[i] == 0L)) {
body:             xi <- unclass(xi)
body:             fixed <- TRUE
body:             for (j in seq_along(xi)) {
body:                 xi1 <- xi[[j]]
body:                 if (is.vector(xi1) || is.factor(xi1)) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else if (is.character(xi1) && inherits(xi1, "AsIs")) 
body:                   xi[[j]] <- structure(rep(xi1, length.out = nr), class = class(xi1))
body:                 else if (inherits(xi1, "Date") || inherits(xi1, "POSIXct")) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else {
body:                   fixed <- FALSE
body:                   break
body:                 }
body:             }
body:             if (fixed) {
body:                 vlist[[i]] <- xi
body:                 next
body:             }
body:         }
body:         stop(gettextf("arguments imply differing number of rows: %s", paste(unique(nrows), collapse = ", ")), domain = NA)
body:     }
body:     value <- unlist(vlist, recursive = FALSE, use.names = FALSE)
body:     vnames <- unlist(vnames[ncols > 0L])
body:     noname <- !nzchar(vnames)
body:     if (any(noname)) 
body:         vnames[noname] <- paste("Var", seq_along(vnames), sep = ".")[noname]
body:     if (check.names) 
body:         vnames <- make.names(vnames, unique = TRUE)
body:     names(value) <- vnames
body:     if (!mrn) {
body:         if (length(row.names) == 1L && nr != 1L) {
body:             if (is.character(row.names)) 
body:                 row.names <- match(row.names, vnames, 0L)
body:             if (length(row.names) != 1L || row.names < 1L || row.names > length(vnames)) 
body:                 stop("'row.names' should specify one of the variables")
body:             i <- row.names
body:             row.names <- value[[i]]
body:             value <- value[-i]
body:         }
body:         else if (!is.null(row.names) && length(row.names) != nr) 
body:             stop("row names supplied are of the wrong length")
body:     }
body:     else if (!is.null(row.names) && length(row.names) != nr) {
body:         warning("row names were found from a short variable and have been discarded")
body:         row.names <- NULL
body:     }
body:     if (is.null(row.names)) 
body:         row.names <- .set_row_names(nr)
body:     else {
body:         if (is.object(row.names) || !is.integer(row.names)) 
body:             row.names <- as.character(row.names)
body:         if (any(is.na(row.names))) 
body:             stop("row names contain missing values")
body:         if (anyDuplicated(row.names)) 
body:             stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:     }
body:     attr(value, "row.names") <- row.names
body:     attr(value, "class") <- "data.frame"
body:     value
body: }
args: list(`FALSE` = structure("FALSE", class = "AsIs"), check.names = FALSE, row.names = "1")
retn: structure(list(`FALSE` = structure("FALSE", class = "AsIs")), .Names = "FALSE", row.names = "1", class = "data.frame")

func: quote(data.frame)
body: function (..., row.names = NULL, check.rows = FALSE, check.names = TRUE, stringsAsFactors = default.stringsAsFactors()) 
body: {
body:     data.row.names <- if (check.rows && is.null(row.names)) 
body:         function(current, new, i) {
body:             if (is.character(current)) 
body:                 new <- as.character(new)
body:             if (is.character(new)) 
body:                 current <- as.character(current)
body:             if (anyDuplicated(new)) 
body:                 return(current)
body:             if (is.null(current)) 
body:                 return(new)
body:             if (all(current == new) || all(current == "")) 
body:                 return(new)
body:             stop(gettextf("mismatch of row names in arguments of 'data.frame', item %d", i), domain = NA)
body:         }
body:     else function(current, new, i) {
body:         if (is.null(current)) {
body:             if (anyDuplicated(new)) {
body:                 warning(gettextf("some row.names duplicated: %s --> row.names NOT used", paste(which(duplicated(new)), collapse = ",")), domain = NA)
body:                 current
body:             }
body:             else new
body:         }
body:         else current
body:     }
body:     object <- as.list(substitute(list(...)))[-1L]
body:     mirn <- missing(row.names)
body:     mrn <- is.null(row.names)
body:     x <- list(...)
body:     n <- length(x)
body:     if (n < 1L) {
body:         if (!mrn) {
body:             if (is.object(row.names) || !is.integer(row.names)) 
body:                 row.names <- as.character(row.names)
body:             if (any(is.na(row.names))) 
body:                 stop("row names contain missing values")
body:             if (anyDuplicated(row.names)) 
body:                 stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:         }
body:         else row.names <- integer()
body:         return(structure(list(), names = character(), row.names = row.names, class = "data.frame"))
body:     }
body:     vnames <- names(x)
body:     if (length(vnames) != n) 
body:         vnames <- character(n)
body:     no.vn <- !nzchar(vnames)
body:     vlist <- vnames <- as.list(vnames)
body:     nrows <- ncols <- integer(n)
body:     for (i in seq_len(n)) {
body:         xi <- if (is.character(x[[i]]) || is.list(x[[i]])) 
body:             as.data.frame(x[[i]], optional = TRUE, stringsAsFactors = stringsAsFactors)
body:         else as.data.frame(x[[i]], optional = TRUE)
body:         nrows[i] <- .row_names_info(xi)
body:         ncols[i] <- length(xi)
body:         namesi <- names(xi)
body:         if (ncols[i] > 1L) {
body:             if (length(namesi) == 0L) 
body:                 namesi <- seq_len(ncols[i])
body:             if (no.vn[i]) 
body:                 vnames[[i]] <- namesi
body:             else vnames[[i]] <- paste(vnames[[i]], namesi, sep = ".")
body:         }
body:         else {
body:             if (length(namesi)) 
body:                 vnames[[i]] <- namesi
body:             else if (no.vn[[i]]) {
body:                 tmpname <- deparse(object[[i]])[1L]
body:                 if (substr(tmpname, 1L, 2L) == "I(") {
body:                   ntmpn <- nchar(tmpname, "c")
body:                   if (substr(tmpname, ntmpn, ntmpn) == ")") 
body:                     tmpname <- substr(tmpname, 3L, ntmpn - 1L)
body:                 }
body:                 vnames[[i]] <- tmpname
body:             }
body:         }
body:         if (mirn && nrows[i] > 0L) {
body:             rowsi <- attr(xi, "row.names")
body:             nc <- nchar(rowsi, allowNA = FALSE)
body:             nc <- nc[!is.na(nc)]
body:             if (length(nc) && any(nc)) 
body:                 row.names <- data.row.names(row.names, rowsi, i)
body:         }
body:         nrows[i] <- abs(nrows[i])
body:         vlist[[i]] <- xi
body:     }
body:     nr <- max(nrows)
body:     for (i in seq_len(n)[nrows < nr]) {
body:         xi <- vlist[[i]]
body:         if (nrows[i] > 0L && (nr%%nrows[i] == 0L)) {
body:             xi <- unclass(xi)
body:             fixed <- TRUE
body:             for (j in seq_along(xi)) {
body:                 xi1 <- xi[[j]]
body:                 if (is.vector(xi1) || is.factor(xi1)) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else if (is.character(xi1) && inherits(xi1, "AsIs")) 
body:                   xi[[j]] <- structure(rep(xi1, length.out = nr), class = class(xi1))
body:                 else if (inherits(xi1, "Date") || inherits(xi1, "POSIXct")) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else {
body:                   fixed <- FALSE
body:                   break
body:                 }
body:             }
body:             if (fixed) {
body:                 vlist[[i]] <- xi
body:                 next
body:             }
body:         }
body:         stop(gettextf("arguments imply differing number of rows: %s", paste(unique(nrows), collapse = ", ")), domain = NA)
body:     }
body:     value <- unlist(vlist, recursive = FALSE, use.names = FALSE)
body:     vnames <- unlist(vnames[ncols > 0L])
body:     noname <- !nzchar(vnames)
body:     if (any(noname)) 
body:         vnames[noname] <- paste("Var", seq_along(vnames), sep = ".")[noname]
body:     if (check.names) 
body:         vnames <- make.names(vnames, unique = TRUE)
body:     names(value) <- vnames
body:     if (!mrn) {
body:         if (length(row.names) == 1L && nr != 1L) {
body:             if (is.character(row.names)) 
body:                 row.names <- match(row.names, vnames, 0L)
body:             if (length(row.names) != 1L || row.names < 1L || row.names > length(vnames)) 
body:                 stop("'row.names' should specify one of the variables")
body:             i <- row.names
body:             row.names <- value[[i]]
body:             value <- value[-i]
body:         }
body:         else if (!is.null(row.names) && length(row.names) != nr) 
body:             stop("row names supplied are of the wrong length")
body:     }
body:     else if (!is.null(row.names) && length(row.names) != nr) {
body:         warning("row names were found from a short variable and have been discarded")
body:         row.names <- NULL
body:     }
body:     if (is.null(row.names)) 
body:         row.names <- .set_row_names(nr)
body:     else {
body:         if (is.object(row.names) || !is.integer(row.names)) 
body:             row.names <- as.character(row.names)
body:         if (any(is.na(row.names))) 
body:             stop("row names contain missing values")
body:         if (anyDuplicated(row.names)) 
body:             stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:     }
body:     attr(value, "row.names") <- row.names
body:     attr(value, "class") <- "data.frame"
body:     value
body: }
args: list(`NA` = structure(character(0), class = "AsIs"), check.names = FALSE, row.names = character(0))
retn: structure(list(`NA` = structure(character(0), class = "AsIs")), .Names = "NA", row.names = character(0), class = "data.frame")

func: quote(data.frame)
body: function (..., row.names = NULL, check.rows = FALSE, check.names = TRUE, stringsAsFactors = default.stringsAsFactors()) 
body: {
body:     data.row.names <- if (check.rows && is.null(row.names)) 
body:         function(current, new, i) {
body:             if (is.character(current)) 
body:                 new <- as.character(new)
body:             if (is.character(new)) 
body:                 current <- as.character(current)
body:             if (anyDuplicated(new)) 
body:                 return(current)
body:             if (is.null(current)) 
body:                 return(new)
body:             if (all(current == new) || all(current == "")) 
body:                 return(new)
body:             stop(gettextf("mismatch of row names in arguments of 'data.frame', item %d", i), domain = NA)
body:         }
body:     else function(current, new, i) {
body:         if (is.null(current)) {
body:             if (anyDuplicated(new)) {
body:                 warning(gettextf("some row.names duplicated: %s --> row.names NOT used", paste(which(duplicated(new)), collapse = ",")), domain = NA)
body:                 current
body:             }
body:             else new
body:         }
body:         else current
body:     }
body:     object <- as.list(substitute(list(...)))[-1L]
body:     mirn <- missing(row.names)
body:     mrn <- is.null(row.names)
body:     x <- list(...)
body:     n <- length(x)
body:     if (n < 1L) {
body:         if (!mrn) {
body:             if (is.object(row.names) || !is.integer(row.names)) 
body:                 row.names <- as.character(row.names)
body:             if (any(is.na(row.names))) 
body:                 stop("row names contain missing values")
body:             if (anyDuplicated(row.names)) 
body:                 stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:         }
body:         else row.names <- integer()
body:         return(structure(list(), names = character(), row.names = row.names, class = "data.frame"))
body:     }
body:     vnames <- names(x)
body:     if (length(vnames) != n) 
body:         vnames <- character(n)
body:     no.vn <- !nzchar(vnames)
body:     vlist <- vnames <- as.list(vnames)
body:     nrows <- ncols <- integer(n)
body:     for (i in seq_len(n)) {
body:         xi <- if (is.character(x[[i]]) || is.list(x[[i]])) 
body:             as.data.frame(x[[i]], optional = TRUE, stringsAsFactors = stringsAsFactors)
body:         else as.data.frame(x[[i]], optional = TRUE)
body:         nrows[i] <- .row_names_info(xi)
body:         ncols[i] <- length(xi)
body:         namesi <- names(xi)
body:         if (ncols[i] > 1L) {
body:             if (length(namesi) == 0L) 
body:                 namesi <- seq_len(ncols[i])
body:             if (no.vn[i]) 
body:                 vnames[[i]] <- namesi
body:             else vnames[[i]] <- paste(vnames[[i]], namesi, sep = ".")
body:         }
body:         else {
body:             if (length(namesi)) 
body:                 vnames[[i]] <- namesi
body:             else if (no.vn[[i]]) {
body:                 tmpname <- deparse(object[[i]])[1L]
body:                 if (substr(tmpname, 1L, 2L) == "I(") {
body:                   ntmpn <- nchar(tmpname, "c")
body:                   if (substr(tmpname, ntmpn, ntmpn) == ")") 
body:                     tmpname <- substr(tmpname, 3L, ntmpn - 1L)
body:                 }
body:                 vnames[[i]] <- tmpname
body:             }
body:         }
body:         if (mirn && nrows[i] > 0L) {
body:             rowsi <- attr(xi, "row.names")
body:             nc <- nchar(rowsi, allowNA = FALSE)
body:             nc <- nc[!is.na(nc)]
body:             if (length(nc) && any(nc)) 
body:                 row.names <- data.row.names(row.names, rowsi, i)
body:         }
body:         nrows[i] <- abs(nrows[i])
body:         vlist[[i]] <- xi
body:     }
body:     nr <- max(nrows)
body:     for (i in seq_len(n)[nrows < nr]) {
body:         xi <- vlist[[i]]
body:         if (nrows[i] > 0L && (nr%%nrows[i] == 0L)) {
body:             xi <- unclass(xi)
body:             fixed <- TRUE
body:             for (j in seq_along(xi)) {
body:                 xi1 <- xi[[j]]
body:                 if (is.vector(xi1) || is.factor(xi1)) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else if (is.character(xi1) && inherits(xi1, "AsIs")) 
body:                   xi[[j]] <- structure(rep(xi1, length.out = nr), class = class(xi1))
body:                 else if (inherits(xi1, "Date") || inherits(xi1, "POSIXct")) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else {
body:                   fixed <- FALSE
body:                   break
body:                 }
body:             }
body:             if (fixed) {
body:                 vlist[[i]] <- xi
body:                 next
body:             }
body:         }
body:         stop(gettextf("arguments imply differing number of rows: %s", paste(unique(nrows), collapse = ", ")), domain = NA)
body:     }
body:     value <- unlist(vlist, recursive = FALSE, use.names = FALSE)
body:     vnames <- unlist(vnames[ncols > 0L])
body:     noname <- !nzchar(vnames)
body:     if (any(noname)) 
body:         vnames[noname] <- paste("Var", seq_along(vnames), sep = ".")[noname]
body:     if (check.names) 
body:         vnames <- make.names(vnames, unique = TRUE)
body:     names(value) <- vnames
body:     if (!mrn) {
body:         if (length(row.names) == 1L && nr != 1L) {
body:             if (is.character(row.names)) 
body:                 row.names <- match(row.names, vnames, 0L)
body:             if (length(row.names) != 1L || row.names < 1L || row.names > length(vnames)) 
body:                 stop("'row.names' should specify one of the variables")
body:             i <- row.names
body:             row.names <- value[[i]]
body:             value <- value[-i]
body:         }
body:         else if (!is.null(row.names) && length(row.names) != nr) 
body:             stop("row names supplied are of the wrong length")
body:     }
body:     else if (!is.null(row.names) && length(row.names) != nr) {
body:         warning("row names were found from a short variable and have been discarded")
body:         row.names <- NULL
body:     }
body:     if (is.null(row.names)) 
body:         row.names <- .set_row_names(nr)
body:     else {
body:         if (is.object(row.names) || !is.integer(row.names)) 
body:             row.names <- as.character(row.names)
body:         if (any(is.na(row.names))) 
body:             stop("row names contain missing values")
body:         if (anyDuplicated(row.names)) 
body:             stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:     }
body:     attr(value, "row.names") <- row.names
body:     attr(value, "class") <- "data.frame"
body:     value
body: }
args: list(df0 = structure(list(V1 = NA), .Names = "V1", row.names = 1L, class = "data.frame"), check.names = FALSE, row.names = "c0")
retn: structure(list(V1 = NA), .Names = "V1", row.names = "c0", class = "data.frame")

func: quote(data.frame)
body: function (..., row.names = NULL, check.rows = FALSE, check.names = TRUE, stringsAsFactors = default.stringsAsFactors()) 
body: {
body:     data.row.names <- if (check.rows && is.null(row.names)) 
body:         function(current, new, i) {
body:             if (is.character(current)) 
body:                 new <- as.character(new)
body:             if (is.character(new)) 
body:                 current <- as.character(current)
body:             if (anyDuplicated(new)) 
body:                 return(current)
body:             if (is.null(current)) 
body:                 return(new)
body:             if (all(current == new) || all(current == "")) 
body:                 return(new)
body:             stop(gettextf("mismatch of row names in arguments of 'data.frame', item %d", i), domain = NA)
body:         }
body:     else function(current, new, i) {
body:         if (is.null(current)) {
body:             if (anyDuplicated(new)) {
body:                 warning(gettextf("some row.names duplicated: %s --> row.names NOT used", paste(which(duplicated(new)), collapse = ",")), domain = NA)
body:                 current
body:             }
body:             else new
body:         }
body:         else current
body:     }
body:     object <- as.list(substitute(list(...)))[-1L]
body:     mirn <- missing(row.names)
body:     mrn <- is.null(row.names)
body:     x <- list(...)
body:     n <- length(x)
body:     if (n < 1L) {
body:         if (!mrn) {
body:             if (is.object(row.names) || !is.integer(row.names)) 
body:                 row.names <- as.character(row.names)
body:             if (any(is.na(row.names))) 
body:                 stop("row names contain missing values")
body:             if (anyDuplicated(row.names)) 
body:                 stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:         }
body:         else row.names <- integer()
body:         return(structure(list(), names = character(), row.names = row.names, class = "data.frame"))
body:     }
body:     vnames <- names(x)
body:     if (length(vnames) != n) 
body:         vnames <- character(n)
body:     no.vn <- !nzchar(vnames)
body:     vlist <- vnames <- as.list(vnames)
body:     nrows <- ncols <- integer(n)
body:     for (i in seq_len(n)) {
body:         xi <- if (is.character(x[[i]]) || is.list(x[[i]])) 
body:             as.data.frame(x[[i]], optional = TRUE, stringsAsFactors = stringsAsFactors)
body:         else as.data.frame(x[[i]], optional = TRUE)
body:         nrows[i] <- .row_names_info(xi)
body:         ncols[i] <- length(xi)
body:         namesi <- names(xi)
body:         if (ncols[i] > 1L) {
body:             if (length(namesi) == 0L) 
body:                 namesi <- seq_len(ncols[i])
body:             if (no.vn[i]) 
body:                 vnames[[i]] <- namesi
body:             else vnames[[i]] <- paste(vnames[[i]], namesi, sep = ".")
body:         }
body:         else {
body:             if (length(namesi)) 
body:                 vnames[[i]] <- namesi
body:             else if (no.vn[[i]]) {
body:                 tmpname <- deparse(object[[i]])[1L]
body:                 if (substr(tmpname, 1L, 2L) == "I(") {
body:                   ntmpn <- nchar(tmpname, "c")
body:                   if (substr(tmpname, ntmpn, ntmpn) == ")") 
body:                     tmpname <- substr(tmpname, 3L, ntmpn - 1L)
body:                 }
body:                 vnames[[i]] <- tmpname
body:             }
body:         }
body:         if (mirn && nrows[i] > 0L) {
body:             rowsi <- attr(xi, "row.names")
body:             nc <- nchar(rowsi, allowNA = FALSE)
body:             nc <- nc[!is.na(nc)]
body:             if (length(nc) && any(nc)) 
body:                 row.names <- data.row.names(row.names, rowsi, i)
body:         }
body:         nrows[i] <- abs(nrows[i])
body:         vlist[[i]] <- xi
body:     }
body:     nr <- max(nrows)
body:     for (i in seq_len(n)[nrows < nr]) {
body:         xi <- vlist[[i]]
body:         if (nrows[i] > 0L && (nr%%nrows[i] == 0L)) {
body:             xi <- unclass(xi)
body:             fixed <- TRUE
body:             for (j in seq_along(xi)) {
body:                 xi1 <- xi[[j]]
body:                 if (is.vector(xi1) || is.factor(xi1)) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else if (is.character(xi1) && inherits(xi1, "AsIs")) 
body:                   xi[[j]] <- structure(rep(xi1, length.out = nr), class = class(xi1))
body:                 else if (inherits(xi1, "Date") || inherits(xi1, "POSIXct")) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else {
body:                   fixed <- FALSE
body:                   break
body:                 }
body:             }
body:             if (fixed) {
body:                 vlist[[i]] <- xi
body:                 next
body:             }
body:         }
body:         stop(gettextf("arguments imply differing number of rows: %s", paste(unique(nrows), collapse = ", ")), domain = NA)
body:     }
body:     value <- unlist(vlist, recursive = FALSE, use.names = FALSE)
body:     vnames <- unlist(vnames[ncols > 0L])
body:     noname <- !nzchar(vnames)
body:     if (any(noname)) 
body:         vnames[noname] <- paste("Var", seq_along(vnames), sep = ".")[noname]
body:     if (check.names) 
body:         vnames <- make.names(vnames, unique = TRUE)
body:     names(value) <- vnames
body:     if (!mrn) {
body:         if (length(row.names) == 1L && nr != 1L) {
body:             if (is.character(row.names)) 
body:                 row.names <- match(row.names, vnames, 0L)
body:             if (length(row.names) != 1L || row.names < 1L || row.names > length(vnames)) 
body:                 stop("'row.names' should specify one of the variables")
body:             i <- row.names
body:             row.names <- value[[i]]
body:             value <- value[-i]
body:         }
body:         else if (!is.null(row.names) && length(row.names) != nr) 
body:             stop("row names supplied are of the wrong length")
body:     }
body:     else if (!is.null(row.names) && length(row.names) != nr) {
body:         warning("row names were found from a short variable and have been discarded")
body:         row.names <- NULL
body:     }
body:     if (is.null(row.names)) 
body:         row.names <- .set_row_names(nr)
body:     else {
body:         if (is.object(row.names) || !is.integer(row.names)) 
body:             row.names <- as.character(row.names)
body:         if (any(is.na(row.names))) 
body:             stop("row names contain missing values")
body:         if (anyDuplicated(row.names)) 
body:             stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:     }
body:     attr(value, "row.names") <- row.names
body:     attr(value, "class") <- "data.frame"
body:     value
body: }
args: list(c0 = structure(integer(0), .Label = character(0), class = "factor"), check.names = TRUE, stringsAsFactors = TRUE)
retn: structure(list(c0 = structure(integer(0), .Label = character(0), class = "factor")), .Names = "c0", row.names = integer(0), class = "data.frame")

func: quote(data.frame)
body: function (..., row.names = NULL, check.rows = FALSE, check.names = TRUE, stringsAsFactors = default.stringsAsFactors()) 
body: {
body:     data.row.names <- if (check.rows && is.null(row.names)) 
body:         function(current, new, i) {
body:             if (is.character(current)) 
body:                 new <- as.character(new)
body:             if (is.character(new)) 
body:                 current <- as.character(current)
body:             if (anyDuplicated(new)) 
body:                 return(current)
body:             if (is.null(current)) 
body:                 return(new)
body:             if (all(current == new) || all(current == "")) 
body:                 return(new)
body:             stop(gettextf("mismatch of row names in arguments of 'data.frame', item %d", i), domain = NA)
body:         }
body:     else function(current, new, i) {
body:         if (is.null(current)) {
body:             if (anyDuplicated(new)) {
body:                 warning(gettextf("some row.names duplicated: %s --> row.names NOT used", paste(which(duplicated(new)), collapse = ",")), domain = NA)
body:                 current
body:             }
body:             else new
body:         }
body:         else current
body:     }
body:     object <- as.list(substitute(list(...)))[-1L]
body:     mirn <- missing(row.names)
body:     mrn <- is.null(row.names)
body:     x <- list(...)
body:     n <- length(x)
body:     if (n < 1L) {
body:         if (!mrn) {
body:             if (is.object(row.names) || !is.integer(row.names)) 
body:                 row.names <- as.character(row.names)
body:             if (any(is.na(row.names))) 
body:                 stop("row names contain missing values")
body:             if (anyDuplicated(row.names)) 
body:                 stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:         }
body:         else row.names <- integer()
body:         return(structure(list(), names = character(), row.names = row.names, class = "data.frame"))
body:     }
body:     vnames <- names(x)
body:     if (length(vnames) != n) 
body:         vnames <- character(n)
body:     no.vn <- !nzchar(vnames)
body:     vlist <- vnames <- as.list(vnames)
body:     nrows <- ncols <- integer(n)
body:     for (i in seq_len(n)) {
body:         xi <- if (is.character(x[[i]]) || is.list(x[[i]])) 
body:             as.data.frame(x[[i]], optional = TRUE, stringsAsFactors = stringsAsFactors)
body:         else as.data.frame(x[[i]], optional = TRUE)
body:         nrows[i] <- .row_names_info(xi)
body:         ncols[i] <- length(xi)
body:         namesi <- names(xi)
body:         if (ncols[i] > 1L) {
body:             if (length(namesi) == 0L) 
body:                 namesi <- seq_len(ncols[i])
body:             if (no.vn[i]) 
body:                 vnames[[i]] <- namesi
body:             else vnames[[i]] <- paste(vnames[[i]], namesi, sep = ".")
body:         }
body:         else {
body:             if (length(namesi)) 
body:                 vnames[[i]] <- namesi
body:             else if (no.vn[[i]]) {
body:                 tmpname <- deparse(object[[i]])[1L]
body:                 if (substr(tmpname, 1L, 2L) == "I(") {
body:                   ntmpn <- nchar(tmpname, "c")
body:                   if (substr(tmpname, ntmpn, ntmpn) == ")") 
body:                     tmpname <- substr(tmpname, 3L, ntmpn - 1L)
body:                 }
body:                 vnames[[i]] <- tmpname
body:             }
body:         }
body:         if (mirn && nrows[i] > 0L) {
body:             rowsi <- attr(xi, "row.names")
body:             nc <- nchar(rowsi, allowNA = FALSE)
body:             nc <- nc[!is.na(nc)]
body:             if (length(nc) && any(nc)) 
body:                 row.names <- data.row.names(row.names, rowsi, i)
body:         }
body:         nrows[i] <- abs(nrows[i])
body:         vlist[[i]] <- xi
body:     }
body:     nr <- max(nrows)
body:     for (i in seq_len(n)[nrows < nr]) {
body:         xi <- vlist[[i]]
body:         if (nrows[i] > 0L && (nr%%nrows[i] == 0L)) {
body:             xi <- unclass(xi)
body:             fixed <- TRUE
body:             for (j in seq_along(xi)) {
body:                 xi1 <- xi[[j]]
body:                 if (is.vector(xi1) || is.factor(xi1)) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else if (is.character(xi1) && inherits(xi1, "AsIs")) 
body:                   xi[[j]] <- structure(rep(xi1, length.out = nr), class = class(xi1))
body:                 else if (inherits(xi1, "Date") || inherits(xi1, "POSIXct")) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else {
body:                   fixed <- FALSE
body:                   break
body:                 }
body:             }
body:             if (fixed) {
body:                 vlist[[i]] <- xi
body:                 next
body:             }
body:         }
body:         stop(gettextf("arguments imply differing number of rows: %s", paste(unique(nrows), collapse = ", ")), domain = NA)
body:     }
body:     value <- unlist(vlist, recursive = FALSE, use.names = FALSE)
body:     vnames <- unlist(vnames[ncols > 0L])
body:     noname <- !nzchar(vnames)
body:     if (any(noname)) 
body:         vnames[noname] <- paste("Var", seq_along(vnames), sep = ".")[noname]
body:     if (check.names) 
body:         vnames <- make.names(vnames, unique = TRUE)
body:     names(value) <- vnames
body:     if (!mrn) {
body:         if (length(row.names) == 1L && nr != 1L) {
body:             if (is.character(row.names)) 
body:                 row.names <- match(row.names, vnames, 0L)
body:             if (length(row.names) != 1L || row.names < 1L || row.names > length(vnames)) 
body:                 stop("'row.names' should specify one of the variables")
body:             i <- row.names
body:             row.names <- value[[i]]
body:             value <- value[-i]
body:         }
body:         else if (!is.null(row.names) && length(row.names) != nr) 
body:             stop("row names supplied are of the wrong length")
body:     }
body:     else if (!is.null(row.names) && length(row.names) != nr) {
body:         warning("row names were found from a short variable and have been discarded")
body:         row.names <- NULL
body:     }
body:     if (is.null(row.names)) 
body:         row.names <- .set_row_names(nr)
body:     else {
body:         if (is.object(row.names) || !is.integer(row.names)) 
body:             row.names <- as.character(row.names)
body:         if (any(is.na(row.names))) 
body:             stop("row names contain missing values")
body:         if (anyDuplicated(row.names)) 
body:             stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:     }
body:     attr(value, "row.names") <- row.names
body:     attr(value, "class") <- "data.frame"
body:     value
body: }
args: list(FALSE, check.names = TRUE, stringsAsFactors = TRUE)
retn: structure(list(FALSE. = FALSE), .Names = "FALSE.", row.names = c(NA, -1L), class = "data.frame")

func: quote(data.frame)
body: function (..., row.names = NULL, check.rows = FALSE, check.names = TRUE, stringsAsFactors = default.stringsAsFactors()) 
body: {
body:     data.row.names <- if (check.rows && is.null(row.names)) 
body:         function(current, new, i) {
body:             if (is.character(current)) 
body:                 new <- as.character(new)
body:             if (is.character(new)) 
body:                 current <- as.character(current)
body:             if (anyDuplicated(new)) 
body:                 return(current)
body:             if (is.null(current)) 
body:                 return(new)
body:             if (all(current == new) || all(current == "")) 
body:                 return(new)
body:             stop(gettextf("mismatch of row names in arguments of 'data.frame', item %d", i), domain = NA)
body:         }
body:     else function(current, new, i) {
body:         if (is.null(current)) {
body:             if (anyDuplicated(new)) {
body:                 warning(gettextf("some row.names duplicated: %s --> row.names NOT used", paste(which(duplicated(new)), collapse = ",")), domain = NA)
body:                 current
body:             }
body:             else new
body:         }
body:         else current
body:     }
body:     object <- as.list(substitute(list(...)))[-1L]
body:     mirn <- missing(row.names)
body:     mrn <- is.null(row.names)
body:     x <- list(...)
body:     n <- length(x)
body:     if (n < 1L) {
body:         if (!mrn) {
body:             if (is.object(row.names) || !is.integer(row.names)) 
body:                 row.names <- as.character(row.names)
body:             if (any(is.na(row.names))) 
body:                 stop("row names contain missing values")
body:             if (anyDuplicated(row.names)) 
body:                 stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:         }
body:         else row.names <- integer()
body:         return(structure(list(), names = character(), row.names = row.names, class = "data.frame"))
body:     }
body:     vnames <- names(x)
body:     if (length(vnames) != n) 
body:         vnames <- character(n)
body:     no.vn <- !nzchar(vnames)
body:     vlist <- vnames <- as.list(vnames)
body:     nrows <- ncols <- integer(n)
body:     for (i in seq_len(n)) {
body:         xi <- if (is.character(x[[i]]) || is.list(x[[i]])) 
body:             as.data.frame(x[[i]], optional = TRUE, stringsAsFactors = stringsAsFactors)
body:         else as.data.frame(x[[i]], optional = TRUE)
body:         nrows[i] <- .row_names_info(xi)
body:         ncols[i] <- length(xi)
body:         namesi <- names(xi)
body:         if (ncols[i] > 1L) {
body:             if (length(namesi) == 0L) 
body:                 namesi <- seq_len(ncols[i])
body:             if (no.vn[i]) 
body:                 vnames[[i]] <- namesi
body:             else vnames[[i]] <- paste(vnames[[i]], namesi, sep = ".")
body:         }
body:         else {
body:             if (length(namesi)) 
body:                 vnames[[i]] <- namesi
body:             else if (no.vn[[i]]) {
body:                 tmpname <- deparse(object[[i]])[1L]
body:                 if (substr(tmpname, 1L, 2L) == "I(") {
body:                   ntmpn <- nchar(tmpname, "c")
body:                   if (substr(tmpname, ntmpn, ntmpn) == ")") 
body:                     tmpname <- substr(tmpname, 3L, ntmpn - 1L)
body:                 }
body:                 vnames[[i]] <- tmpname
body:             }
body:         }
body:         if (mirn && nrows[i] > 0L) {
body:             rowsi <- attr(xi, "row.names")
body:             nc <- nchar(rowsi, allowNA = FALSE)
body:             nc <- nc[!is.na(nc)]
body:             if (length(nc) && any(nc)) 
body:                 row.names <- data.row.names(row.names, rowsi, i)
body:         }
body:         nrows[i] <- abs(nrows[i])
body:         vlist[[i]] <- xi
body:     }
body:     nr <- max(nrows)
body:     for (i in seq_len(n)[nrows < nr]) {
body:         xi <- vlist[[i]]
body:         if (nrows[i] > 0L && (nr%%nrows[i] == 0L)) {
body:             xi <- unclass(xi)
body:             fixed <- TRUE
body:             for (j in seq_along(xi)) {
body:                 xi1 <- xi[[j]]
body:                 if (is.vector(xi1) || is.factor(xi1)) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else if (is.character(xi1) && inherits(xi1, "AsIs")) 
body:                   xi[[j]] <- structure(rep(xi1, length.out = nr), class = class(xi1))
body:                 else if (inherits(xi1, "Date") || inherits(xi1, "POSIXct")) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else {
body:                   fixed <- FALSE
body:                   break
body:                 }
body:             }
body:             if (fixed) {
body:                 vlist[[i]] <- xi
body:                 next
body:             }
body:         }
body:         stop(gettextf("arguments imply differing number of rows: %s", paste(unique(nrows), collapse = ", ")), domain = NA)
body:     }
body:     value <- unlist(vlist, recursive = FALSE, use.names = FALSE)
body:     vnames <- unlist(vnames[ncols > 0L])
body:     noname <- !nzchar(vnames)
body:     if (any(noname)) 
body:         vnames[noname] <- paste("Var", seq_along(vnames), sep = ".")[noname]
body:     if (check.names) 
body:         vnames <- make.names(vnames, unique = TRUE)
body:     names(value) <- vnames
body:     if (!mrn) {
body:         if (length(row.names) == 1L && nr != 1L) {
body:             if (is.character(row.names)) 
body:                 row.names <- match(row.names, vnames, 0L)
body:             if (length(row.names) != 1L || row.names < 1L || row.names > length(vnames)) 
body:                 stop("'row.names' should specify one of the variables")
body:             i <- row.names
body:             row.names <- value[[i]]
body:             value <- value[-i]
body:         }
body:         else if (!is.null(row.names) && length(row.names) != nr) 
body:             stop("row names supplied are of the wrong length")
body:     }
body:     else if (!is.null(row.names) && length(row.names) != nr) {
body:         warning("row names were found from a short variable and have been discarded")
body:         row.names <- NULL
body:     }
body:     if (is.null(row.names)) 
body:         row.names <- .set_row_names(nr)
body:     else {
body:         if (is.object(row.names) || !is.integer(row.names)) 
body:             row.names <- as.character(row.names)
body:         if (any(is.na(row.names))) 
body:             stop("row names contain missing values")
body:         if (anyDuplicated(row.names)) 
body:             stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:     }
body:     attr(value, "row.names") <- row.names
body:     attr(value, "class") <- "data.frame"
body:     value
body: }
args: list(FALSE. = structure("FALSE", class = "AsIs"), check.names = FALSE, row.names = "1")
retn: structure(list(FALSE. = structure("FALSE", class = "AsIs")), .Names = "FALSE.", row.names = "1", class = "data.frame")

func: quote(data.frame)
body: function (..., row.names = NULL, check.rows = FALSE, check.names = TRUE, stringsAsFactors = default.stringsAsFactors()) 
body: {
body:     data.row.names <- if (check.rows && is.null(row.names)) 
body:         function(current, new, i) {
body:             if (is.character(current)) 
body:                 new <- as.character(new)
body:             if (is.character(new)) 
body:                 current <- as.character(current)
body:             if (anyDuplicated(new)) 
body:                 return(current)
body:             if (is.null(current)) 
body:                 return(new)
body:             if (all(current == new) || all(current == "")) 
body:                 return(new)
body:             stop(gettextf("mismatch of row names in arguments of 'data.frame', item %d", i), domain = NA)
body:         }
body:     else function(current, new, i) {
body:         if (is.null(current)) {
body:             if (anyDuplicated(new)) {
body:                 warning(gettextf("some row.names duplicated: %s --> row.names NOT used", paste(which(duplicated(new)), collapse = ",")), domain = NA)
body:                 current
body:             }
body:             else new
body:         }
body:         else current
body:     }
body:     object <- as.list(substitute(list(...)))[-1L]
body:     mirn <- missing(row.names)
body:     mrn <- is.null(row.names)
body:     x <- list(...)
body:     n <- length(x)
body:     if (n < 1L) {
body:         if (!mrn) {
body:             if (is.object(row.names) || !is.integer(row.names)) 
body:                 row.names <- as.character(row.names)
body:             if (any(is.na(row.names))) 
body:                 stop("row names contain missing values")
body:             if (anyDuplicated(row.names)) 
body:                 stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:         }
body:         else row.names <- integer()
body:         return(structure(list(), names = character(), row.names = row.names, class = "data.frame"))
body:     }
body:     vnames <- names(x)
body:     if (length(vnames) != n) 
body:         vnames <- character(n)
body:     no.vn <- !nzchar(vnames)
body:     vlist <- vnames <- as.list(vnames)
body:     nrows <- ncols <- integer(n)
body:     for (i in seq_len(n)) {
body:         xi <- if (is.character(x[[i]]) || is.list(x[[i]])) 
body:             as.data.frame(x[[i]], optional = TRUE, stringsAsFactors = stringsAsFactors)
body:         else as.data.frame(x[[i]], optional = TRUE)
body:         nrows[i] <- .row_names_info(xi)
body:         ncols[i] <- length(xi)
body:         namesi <- names(xi)
body:         if (ncols[i] > 1L) {
body:             if (length(namesi) == 0L) 
body:                 namesi <- seq_len(ncols[i])
body:             if (no.vn[i]) 
body:                 vnames[[i]] <- namesi
body:             else vnames[[i]] <- paste(vnames[[i]], namesi, sep = ".")
body:         }
body:         else {
body:             if (length(namesi)) 
body:                 vnames[[i]] <- namesi
body:             else if (no.vn[[i]]) {
body:                 tmpname <- deparse(object[[i]])[1L]
body:                 if (substr(tmpname, 1L, 2L) == "I(") {
body:                   ntmpn <- nchar(tmpname, "c")
body:                   if (substr(tmpname, ntmpn, ntmpn) == ")") 
body:                     tmpname <- substr(tmpname, 3L, ntmpn - 1L)
body:                 }
body:                 vnames[[i]] <- tmpname
body:             }
body:         }
body:         if (mirn && nrows[i] > 0L) {
body:             rowsi <- attr(xi, "row.names")
body:             nc <- nchar(rowsi, allowNA = FALSE)
body:             nc <- nc[!is.na(nc)]
body:             if (length(nc) && any(nc)) 
body:                 row.names <- data.row.names(row.names, rowsi, i)
body:         }
body:         nrows[i] <- abs(nrows[i])
body:         vlist[[i]] <- xi
body:     }
body:     nr <- max(nrows)
body:     for (i in seq_len(n)[nrows < nr]) {
body:         xi <- vlist[[i]]
body:         if (nrows[i] > 0L && (nr%%nrows[i] == 0L)) {
body:             xi <- unclass(xi)
body:             fixed <- TRUE
body:             for (j in seq_along(xi)) {
body:                 xi1 <- xi[[j]]
body:                 if (is.vector(xi1) || is.factor(xi1)) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else if (is.character(xi1) && inherits(xi1, "AsIs")) 
body:                   xi[[j]] <- structure(rep(xi1, length.out = nr), class = class(xi1))
body:                 else if (inherits(xi1, "Date") || inherits(xi1, "POSIXct")) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else {
body:                   fixed <- FALSE
body:                   break
body:                 }
body:             }
body:             if (fixed) {
body:                 vlist[[i]] <- xi
body:                 next
body:             }
body:         }
body:         stop(gettextf("arguments imply differing number of rows: %s", paste(unique(nrows), collapse = ", ")), domain = NA)
body:     }
body:     value <- unlist(vlist, recursive = FALSE, use.names = FALSE)
body:     vnames <- unlist(vnames[ncols > 0L])
body:     noname <- !nzchar(vnames)
body:     if (any(noname)) 
body:         vnames[noname] <- paste("Var", seq_along(vnames), sep = ".")[noname]
body:     if (check.names) 
body:         vnames <- make.names(vnames, unique = TRUE)
body:     names(value) <- vnames
body:     if (!mrn) {
body:         if (length(row.names) == 1L && nr != 1L) {
body:             if (is.character(row.names)) 
body:                 row.names <- match(row.names, vnames, 0L)
body:             if (length(row.names) != 1L || row.names < 1L || row.names > length(vnames)) 
body:                 stop("'row.names' should specify one of the variables")
body:             i <- row.names
body:             row.names <- value[[i]]
body:             value <- value[-i]
body:         }
body:         else if (!is.null(row.names) && length(row.names) != nr) 
body:             stop("row names supplied are of the wrong length")
body:     }
body:     else if (!is.null(row.names) && length(row.names) != nr) {
body:         warning("row names were found from a short variable and have been discarded")
body:         row.names <- NULL
body:     }
body:     if (is.null(row.names)) 
body:         row.names <- .set_row_names(nr)
body:     else {
body:         if (is.object(row.names) || !is.integer(row.names)) 
body:             row.names <- as.character(row.names)
body:         if (any(is.na(row.names))) 
body:             stop("row names contain missing values")
body:         if (anyDuplicated(row.names)) 
body:             stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:     }
body:     attr(value, "row.names") <- row.names
body:     attr(value, "class") <- "data.frame"
body:     value
body: }
args: list(c0 = structure(integer(0), .Label = character(0), class = "factor"), check.names = FALSE, stringsAsFactors = TRUE)
retn: structure(list(c0 = structure(integer(0), .Label = character(0), class = "factor")), .Names = "c0", row.names = integer(0), class = "data.frame")

func: quote(data.frame)
body: function (..., row.names = NULL, check.rows = FALSE, check.names = TRUE, stringsAsFactors = default.stringsAsFactors()) 
body: {
body:     data.row.names <- if (check.rows && is.null(row.names)) 
body:         function(current, new, i) {
body:             if (is.character(current)) 
body:                 new <- as.character(new)
body:             if (is.character(new)) 
body:                 current <- as.character(current)
body:             if (anyDuplicated(new)) 
body:                 return(current)
body:             if (is.null(current)) 
body:                 return(new)
body:             if (all(current == new) || all(current == "")) 
body:                 return(new)
body:             stop(gettextf("mismatch of row names in arguments of 'data.frame', item %d", i), domain = NA)
body:         }
body:     else function(current, new, i) {
body:         if (is.null(current)) {
body:             if (anyDuplicated(new)) {
body:                 warning(gettextf("some row.names duplicated: %s --> row.names NOT used", paste(which(duplicated(new)), collapse = ",")), domain = NA)
body:                 current
body:             }
body:             else new
body:         }
body:         else current
body:     }
body:     object <- as.list(substitute(list(...)))[-1L]
body:     mirn <- missing(row.names)
body:     mrn <- is.null(row.names)
body:     x <- list(...)
body:     n <- length(x)
body:     if (n < 1L) {
body:         if (!mrn) {
body:             if (is.object(row.names) || !is.integer(row.names)) 
body:                 row.names <- as.character(row.names)
body:             if (any(is.na(row.names))) 
body:                 stop("row names contain missing values")
body:             if (anyDuplicated(row.names)) 
body:                 stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:         }
body:         else row.names <- integer()
body:         return(structure(list(), names = character(), row.names = row.names, class = "data.frame"))
body:     }
body:     vnames <- names(x)
body:     if (length(vnames) != n) 
body:         vnames <- character(n)
body:     no.vn <- !nzchar(vnames)
body:     vlist <- vnames <- as.list(vnames)
body:     nrows <- ncols <- integer(n)
body:     for (i in seq_len(n)) {
body:         xi <- if (is.character(x[[i]]) || is.list(x[[i]])) 
body:             as.data.frame(x[[i]], optional = TRUE, stringsAsFactors = stringsAsFactors)
body:         else as.data.frame(x[[i]], optional = TRUE)
body:         nrows[i] <- .row_names_info(xi)
body:         ncols[i] <- length(xi)
body:         namesi <- names(xi)
body:         if (ncols[i] > 1L) {
body:             if (length(namesi) == 0L) 
body:                 namesi <- seq_len(ncols[i])
body:             if (no.vn[i]) 
body:                 vnames[[i]] <- namesi
body:             else vnames[[i]] <- paste(vnames[[i]], namesi, sep = ".")
body:         }
body:         else {
body:             if (length(namesi)) 
body:                 vnames[[i]] <- namesi
body:             else if (no.vn[[i]]) {
body:                 tmpname <- deparse(object[[i]])[1L]
body:                 if (substr(tmpname, 1L, 2L) == "I(") {
body:                   ntmpn <- nchar(tmpname, "c")
body:                   if (substr(tmpname, ntmpn, ntmpn) == ")") 
body:                     tmpname <- substr(tmpname, 3L, ntmpn - 1L)
body:                 }
body:                 vnames[[i]] <- tmpname
body:             }
body:         }
body:         if (mirn && nrows[i] > 0L) {
body:             rowsi <- attr(xi, "row.names")
body:             nc <- nchar(rowsi, allowNA = FALSE)
body:             nc <- nc[!is.na(nc)]
body:             if (length(nc) && any(nc)) 
body:                 row.names <- data.row.names(row.names, rowsi, i)
body:         }
body:         nrows[i] <- abs(nrows[i])
body:         vlist[[i]] <- xi
body:     }
body:     nr <- max(nrows)
body:     for (i in seq_len(n)[nrows < nr]) {
body:         xi <- vlist[[i]]
body:         if (nrows[i] > 0L && (nr%%nrows[i] == 0L)) {
body:             xi <- unclass(xi)
body:             fixed <- TRUE
body:             for (j in seq_along(xi)) {
body:                 xi1 <- xi[[j]]
body:                 if (is.vector(xi1) || is.factor(xi1)) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else if (is.character(xi1) && inherits(xi1, "AsIs")) 
body:                   xi[[j]] <- structure(rep(xi1, length.out = nr), class = class(xi1))
body:                 else if (inherits(xi1, "Date") || inherits(xi1, "POSIXct")) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else {
body:                   fixed <- FALSE
body:                   break
body:                 }
body:             }
body:             if (fixed) {
body:                 vlist[[i]] <- xi
body:                 next
body:             }
body:         }
body:         stop(gettextf("arguments imply differing number of rows: %s", paste(unique(nrows), collapse = ", ")), domain = NA)
body:     }
body:     value <- unlist(vlist, recursive = FALSE, use.names = FALSE)
body:     vnames <- unlist(vnames[ncols > 0L])
body:     noname <- !nzchar(vnames)
body:     if (any(noname)) 
body:         vnames[noname] <- paste("Var", seq_along(vnames), sep = ".")[noname]
body:     if (check.names) 
body:         vnames <- make.names(vnames, unique = TRUE)
body:     names(value) <- vnames
body:     if (!mrn) {
body:         if (length(row.names) == 1L && nr != 1L) {
body:             if (is.character(row.names)) 
body:                 row.names <- match(row.names, vnames, 0L)
body:             if (length(row.names) != 1L || row.names < 1L || row.names > length(vnames)) 
body:                 stop("'row.names' should specify one of the variables")
body:             i <- row.names
body:             row.names <- value[[i]]
body:             value <- value[-i]
body:         }
body:         else if (!is.null(row.names) && length(row.names) != nr) 
body:             stop("row names supplied are of the wrong length")
body:     }
body:     else if (!is.null(row.names) && length(row.names) != nr) {
body:         warning("row names were found from a short variable and have been discarded")
body:         row.names <- NULL
body:     }
body:     if (is.null(row.names)) 
body:         row.names <- .set_row_names(nr)
body:     else {
body:         if (is.object(row.names) || !is.integer(row.names)) 
body:             row.names <- as.character(row.names)
body:         if (any(is.na(row.names))) 
body:             stop("row names contain missing values")
body:         if (anyDuplicated(row.names)) 
body:             stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:     }
body:     attr(value, "row.names") <- row.names
body:     attr(value, "class") <- "data.frame"
body:     value
body: }
args: list(structure(list(Var1 = character(0), Var2 = character(0)), .Names = c("Var1", "Var2"), class = "data.frame", row.names = integer(0)), Freq = structure(list(c0 = structure(integer(0), .Label = character(0), class = "factor")), .Names = "c0"), row.names = NULL)
retn: structure(list(Var1 = character(0), Var2 = character(0), c0 = structure(integer(0), .Label = character(0), class = "factor")), .Names = c("Var1", "Var2", "c0"), row.names = integer(0), class = "data.frame")

func: quote(data.frame)
body: function (..., row.names = NULL, check.rows = FALSE, check.names = TRUE, stringsAsFactors = default.stringsAsFactors()) 
body: {
body:     data.row.names <- if (check.rows && is.null(row.names)) 
body:         function(current, new, i) {
body:             if (is.character(current)) 
body:                 new <- as.character(new)
body:             if (is.character(new)) 
body:                 current <- as.character(current)
body:             if (anyDuplicated(new)) 
body:                 return(current)
body:             if (is.null(current)) 
body:                 return(new)
body:             if (all(current == new) || all(current == "")) 
body:                 return(new)
body:             stop(gettextf("mismatch of row names in arguments of 'data.frame', item %d", i), domain = NA)
body:         }
body:     else function(current, new, i) {
body:         if (is.null(current)) {
body:             if (anyDuplicated(new)) {
body:                 warning(gettextf("some row.names duplicated: %s --> row.names NOT used", paste(which(duplicated(new)), collapse = ",")), domain = NA)
body:                 current
body:             }
body:             else new
body:         }
body:         else current
body:     }
body:     object <- as.list(substitute(list(...)))[-1L]
body:     mirn <- missing(row.names)
body:     mrn <- is.null(row.names)
body:     x <- list(...)
body:     n <- length(x)
body:     if (n < 1L) {
body:         if (!mrn) {
body:             if (is.object(row.names) || !is.integer(row.names)) 
body:                 row.names <- as.character(row.names)
body:             if (any(is.na(row.names))) 
body:                 stop("row names contain missing values")
body:             if (anyDuplicated(row.names)) 
body:                 stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:         }
body:         else row.names <- integer()
body:         return(structure(list(), names = character(), row.names = row.names, class = "data.frame"))
body:     }
body:     vnames <- names(x)
body:     if (length(vnames) != n) 
body:         vnames <- character(n)
body:     no.vn <- !nzchar(vnames)
body:     vlist <- vnames <- as.list(vnames)
body:     nrows <- ncols <- integer(n)
body:     for (i in seq_len(n)) {
body:         xi <- if (is.character(x[[i]]) || is.list(x[[i]])) 
body:             as.data.frame(x[[i]], optional = TRUE, stringsAsFactors = stringsAsFactors)
body:         else as.data.frame(x[[i]], optional = TRUE)
body:         nrows[i] <- .row_names_info(xi)
body:         ncols[i] <- length(xi)
body:         namesi <- names(xi)
body:         if (ncols[i] > 1L) {
body:             if (length(namesi) == 0L) 
body:                 namesi <- seq_len(ncols[i])
body:             if (no.vn[i]) 
body:                 vnames[[i]] <- namesi
body:             else vnames[[i]] <- paste(vnames[[i]], namesi, sep = ".")
body:         }
body:         else {
body:             if (length(namesi)) 
body:                 vnames[[i]] <- namesi
body:             else if (no.vn[[i]]) {
body:                 tmpname <- deparse(object[[i]])[1L]
body:                 if (substr(tmpname, 1L, 2L) == "I(") {
body:                   ntmpn <- nchar(tmpname, "c")
body:                   if (substr(tmpname, ntmpn, ntmpn) == ")") 
body:                     tmpname <- substr(tmpname, 3L, ntmpn - 1L)
body:                 }
body:                 vnames[[i]] <- tmpname
body:             }
body:         }
body:         if (mirn && nrows[i] > 0L) {
body:             rowsi <- attr(xi, "row.names")
body:             nc <- nchar(rowsi, allowNA = FALSE)
body:             nc <- nc[!is.na(nc)]
body:             if (length(nc) && any(nc)) 
body:                 row.names <- data.row.names(row.names, rowsi, i)
body:         }
body:         nrows[i] <- abs(nrows[i])
body:         vlist[[i]] <- xi
body:     }
body:     nr <- max(nrows)
body:     for (i in seq_len(n)[nrows < nr]) {
body:         xi <- vlist[[i]]
body:         if (nrows[i] > 0L && (nr%%nrows[i] == 0L)) {
body:             xi <- unclass(xi)
body:             fixed <- TRUE
body:             for (j in seq_along(xi)) {
body:                 xi1 <- xi[[j]]
body:                 if (is.vector(xi1) || is.factor(xi1)) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else if (is.character(xi1) && inherits(xi1, "AsIs")) 
body:                   xi[[j]] <- structure(rep(xi1, length.out = nr), class = class(xi1))
body:                 else if (inherits(xi1, "Date") || inherits(xi1, "POSIXct")) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else {
body:                   fixed <- FALSE
body:                   break
body:                 }
body:             }
body:             if (fixed) {
body:                 vlist[[i]] <- xi
body:                 next
body:             }
body:         }
body:         stop(gettextf("arguments imply differing number of rows: %s", paste(unique(nrows), collapse = ", ")), domain = NA)
body:     }
body:     value <- unlist(vlist, recursive = FALSE, use.names = FALSE)
body:     vnames <- unlist(vnames[ncols > 0L])
body:     noname <- !nzchar(vnames)
body:     if (any(noname)) 
body:         vnames[noname] <- paste("Var", seq_along(vnames), sep = ".")[noname]
body:     if (check.names) 
body:         vnames <- make.names(vnames, unique = TRUE)
body:     names(value) <- vnames
body:     if (!mrn) {
body:         if (length(row.names) == 1L && nr != 1L) {
body:             if (is.character(row.names)) 
body:                 row.names <- match(row.names, vnames, 0L)
body:             if (length(row.names) != 1L || row.names < 1L || row.names > length(vnames)) 
body:                 stop("'row.names' should specify one of the variables")
body:             i <- row.names
body:             row.names <- value[[i]]
body:             value <- value[-i]
body:         }
body:         else if (!is.null(row.names) && length(row.names) != nr) 
body:             stop("row names supplied are of the wrong length")
body:     }
body:     else if (!is.null(row.names) && length(row.names) != nr) {
body:         warning("row names were found from a short variable and have been discarded")
body:         row.names <- NULL
body:     }
body:     if (is.null(row.names)) 
body:         row.names <- .set_row_names(nr)
body:     else {
body:         if (is.object(row.names) || !is.integer(row.names)) 
body:             row.names <- as.character(row.names)
body:         if (any(is.na(row.names))) 
body:             stop("row names contain missing values")
body:         if (anyDuplicated(row.names)) 
body:             stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:     }
body:     attr(value, "row.names") <- row.names
body:     attr(value, "class") <- "data.frame"
body:     value
body: }
args: list(x = structure(list(V1 = NA), .Names = "V1", row.names = 1L, class = "data.frame"), check.names = FALSE, row.names = "c0")
retn: structure(list(V1 = NA), .Names = "V1", row.names = "c0", class = "data.frame")

func: quote(data.frame)
body: function (..., row.names = NULL, check.rows = FALSE, check.names = TRUE, stringsAsFactors = default.stringsAsFactors()) 
body: {
body:     data.row.names <- if (check.rows && is.null(row.names)) 
body:         function(current, new, i) {
body:             if (is.character(current)) 
body:                 new <- as.character(new)
body:             if (is.character(new)) 
body:                 current <- as.character(current)
body:             if (anyDuplicated(new)) 
body:                 return(current)
body:             if (is.null(current)) 
body:                 return(new)
body:             if (all(current == new) || all(current == "")) 
body:                 return(new)
body:             stop(gettextf("mismatch of row names in arguments of 'data.frame', item %d", i), domain = NA)
body:         }
body:     else function(current, new, i) {
body:         if (is.null(current)) {
body:             if (anyDuplicated(new)) {
body:                 warning(gettextf("some row.names duplicated: %s --> row.names NOT used", paste(which(duplicated(new)), collapse = ",")), domain = NA)
body:                 current
body:             }
body:             else new
body:         }
body:         else current
body:     }
body:     object <- as.list(substitute(list(...)))[-1L]
body:     mirn <- missing(row.names)
body:     mrn <- is.null(row.names)
body:     x <- list(...)
body:     n <- length(x)
body:     if (n < 1L) {
body:         if (!mrn) {
body:             if (is.object(row.names) || !is.integer(row.names)) 
body:                 row.names <- as.character(row.names)
body:             if (any(is.na(row.names))) 
body:                 stop("row names contain missing values")
body:             if (anyDuplicated(row.names)) 
body:                 stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:         }
body:         else row.names <- integer()
body:         return(structure(list(), names = character(), row.names = row.names, class = "data.frame"))
body:     }
body:     vnames <- names(x)
body:     if (length(vnames) != n) 
body:         vnames <- character(n)
body:     no.vn <- !nzchar(vnames)
body:     vlist <- vnames <- as.list(vnames)
body:     nrows <- ncols <- integer(n)
body:     for (i in seq_len(n)) {
body:         xi <- if (is.character(x[[i]]) || is.list(x[[i]])) 
body:             as.data.frame(x[[i]], optional = TRUE, stringsAsFactors = stringsAsFactors)
body:         else as.data.frame(x[[i]], optional = TRUE)
body:         nrows[i] <- .row_names_info(xi)
body:         ncols[i] <- length(xi)
body:         namesi <- names(xi)
body:         if (ncols[i] > 1L) {
body:             if (length(namesi) == 0L) 
body:                 namesi <- seq_len(ncols[i])
body:             if (no.vn[i]) 
body:                 vnames[[i]] <- namesi
body:             else vnames[[i]] <- paste(vnames[[i]], namesi, sep = ".")
body:         }
body:         else {
body:             if (length(namesi)) 
body:                 vnames[[i]] <- namesi
body:             else if (no.vn[[i]]) {
body:                 tmpname <- deparse(object[[i]])[1L]
body:                 if (substr(tmpname, 1L, 2L) == "I(") {
body:                   ntmpn <- nchar(tmpname, "c")
body:                   if (substr(tmpname, ntmpn, ntmpn) == ")") 
body:                     tmpname <- substr(tmpname, 3L, ntmpn - 1L)
body:                 }
body:                 vnames[[i]] <- tmpname
body:             }
body:         }
body:         if (mirn && nrows[i] > 0L) {
body:             rowsi <- attr(xi, "row.names")
body:             nc <- nchar(rowsi, allowNA = FALSE)
body:             nc <- nc[!is.na(nc)]
body:             if (length(nc) && any(nc)) 
body:                 row.names <- data.row.names(row.names, rowsi, i)
body:         }
body:         nrows[i] <- abs(nrows[i])
body:         vlist[[i]] <- xi
body:     }
body:     nr <- max(nrows)
body:     for (i in seq_len(n)[nrows < nr]) {
body:         xi <- vlist[[i]]
body:         if (nrows[i] > 0L && (nr%%nrows[i] == 0L)) {
body:             xi <- unclass(xi)
body:             fixed <- TRUE
body:             for (j in seq_along(xi)) {
body:                 xi1 <- xi[[j]]
body:                 if (is.vector(xi1) || is.factor(xi1)) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else if (is.character(xi1) && inherits(xi1, "AsIs")) 
body:                   xi[[j]] <- structure(rep(xi1, length.out = nr), class = class(xi1))
body:                 else if (inherits(xi1, "Date") || inherits(xi1, "POSIXct")) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else {
body:                   fixed <- FALSE
body:                   break
body:                 }
body:             }
body:             if (fixed) {
body:                 vlist[[i]] <- xi
body:                 next
body:             }
body:         }
body:         stop(gettextf("arguments imply differing number of rows: %s", paste(unique(nrows), collapse = ", ")), domain = NA)
body:     }
body:     value <- unlist(vlist, recursive = FALSE, use.names = FALSE)
body:     vnames <- unlist(vnames[ncols > 0L])
body:     noname <- !nzchar(vnames)
body:     if (any(noname)) 
body:         vnames[noname] <- paste("Var", seq_along(vnames), sep = ".")[noname]
body:     if (check.names) 
body:         vnames <- make.names(vnames, unique = TRUE)
body:     names(value) <- vnames
body:     if (!mrn) {
body:         if (length(row.names) == 1L && nr != 1L) {
body:             if (is.character(row.names)) 
body:                 row.names <- match(row.names, vnames, 0L)
body:             if (length(row.names) != 1L || row.names < 1L || row.names > length(vnames)) 
body:                 stop("'row.names' should specify one of the variables")
body:             i <- row.names
body:             row.names <- value[[i]]
body:             value <- value[-i]
body:         }
body:         else if (!is.null(row.names) && length(row.names) != nr) 
body:             stop("row names supplied are of the wrong length")
body:     }
body:     else if (!is.null(row.names) && length(row.names) != nr) {
body:         warning("row names were found from a short variable and have been discarded")
body:         row.names <- NULL
body:     }
body:     if (is.null(row.names)) 
body:         row.names <- .set_row_names(nr)
body:     else {
body:         if (is.object(row.names) || !is.integer(row.names)) 
body:             row.names <- as.character(row.names)
body:         if (any(is.na(row.names))) 
body:             stop("row names contain missing values")
body:         if (anyDuplicated(row.names)) 
body:             stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:     }
body:     attr(value, "row.names") <- row.names
body:     attr(value, "class") <- "data.frame"
body:     value
body: }
args: list(x = structure("FALSE", class = "AsIs"), check.names = FALSE, row.names = "1")
retn: structure(list(x = structure("FALSE", class = "AsIs")), .Names = "x", row.names = "1", class = "data.frame")

func: quote(data.frame)
body: function (..., row.names = NULL, check.rows = FALSE, check.names = TRUE, stringsAsFactors = default.stringsAsFactors()) 
body: {
body:     data.row.names <- if (check.rows && is.null(row.names)) 
body:         function(current, new, i) {
body:             if (is.character(current)) 
body:                 new <- as.character(new)
body:             if (is.character(new)) 
body:                 current <- as.character(current)
body:             if (anyDuplicated(new)) 
body:                 return(current)
body:             if (is.null(current)) 
body:                 return(new)
body:             if (all(current == new) || all(current == "")) 
body:                 return(new)
body:             stop(gettextf("mismatch of row names in arguments of 'data.frame', item %d", i), domain = NA)
body:         }
body:     else function(current, new, i) {
body:         if (is.null(current)) {
body:             if (anyDuplicated(new)) {
body:                 warning(gettextf("some row.names duplicated: %s --> row.names NOT used", paste(which(duplicated(new)), collapse = ",")), domain = NA)
body:                 current
body:             }
body:             else new
body:         }
body:         else current
body:     }
body:     object <- as.list(substitute(list(...)))[-1L]
body:     mirn <- missing(row.names)
body:     mrn <- is.null(row.names)
body:     x <- list(...)
body:     n <- length(x)
body:     if (n < 1L) {
body:         if (!mrn) {
body:             if (is.object(row.names) || !is.integer(row.names)) 
body:                 row.names <- as.character(row.names)
body:             if (any(is.na(row.names))) 
body:                 stop("row names contain missing values")
body:             if (anyDuplicated(row.names)) 
body:                 stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:         }
body:         else row.names <- integer()
body:         return(structure(list(), names = character(), row.names = row.names, class = "data.frame"))
body:     }
body:     vnames <- names(x)
body:     if (length(vnames) != n) 
body:         vnames <- character(n)
body:     no.vn <- !nzchar(vnames)
body:     vlist <- vnames <- as.list(vnames)
body:     nrows <- ncols <- integer(n)
body:     for (i in seq_len(n)) {
body:         xi <- if (is.character(x[[i]]) || is.list(x[[i]])) 
body:             as.data.frame(x[[i]], optional = TRUE, stringsAsFactors = stringsAsFactors)
body:         else as.data.frame(x[[i]], optional = TRUE)
body:         nrows[i] <- .row_names_info(xi)
body:         ncols[i] <- length(xi)
body:         namesi <- names(xi)
body:         if (ncols[i] > 1L) {
body:             if (length(namesi) == 0L) 
body:                 namesi <- seq_len(ncols[i])
body:             if (no.vn[i]) 
body:                 vnames[[i]] <- namesi
body:             else vnames[[i]] <- paste(vnames[[i]], namesi, sep = ".")
body:         }
body:         else {
body:             if (length(namesi)) 
body:                 vnames[[i]] <- namesi
body:             else if (no.vn[[i]]) {
body:                 tmpname <- deparse(object[[i]])[1L]
body:                 if (substr(tmpname, 1L, 2L) == "I(") {
body:                   ntmpn <- nchar(tmpname, "c")
body:                   if (substr(tmpname, ntmpn, ntmpn) == ")") 
body:                     tmpname <- substr(tmpname, 3L, ntmpn - 1L)
body:                 }
body:                 vnames[[i]] <- tmpname
body:             }
body:         }
body:         if (mirn && nrows[i] > 0L) {
body:             rowsi <- attr(xi, "row.names")
body:             nc <- nchar(rowsi, allowNA = FALSE)
body:             nc <- nc[!is.na(nc)]
body:             if (length(nc) && any(nc)) 
body:                 row.names <- data.row.names(row.names, rowsi, i)
body:         }
body:         nrows[i] <- abs(nrows[i])
body:         vlist[[i]] <- xi
body:     }
body:     nr <- max(nrows)
body:     for (i in seq_len(n)[nrows < nr]) {
body:         xi <- vlist[[i]]
body:         if (nrows[i] > 0L && (nr%%nrows[i] == 0L)) {
body:             xi <- unclass(xi)
body:             fixed <- TRUE
body:             for (j in seq_along(xi)) {
body:                 xi1 <- xi[[j]]
body:                 if (is.vector(xi1) || is.factor(xi1)) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else if (is.character(xi1) && inherits(xi1, "AsIs")) 
body:                   xi[[j]] <- structure(rep(xi1, length.out = nr), class = class(xi1))
body:                 else if (inherits(xi1, "Date") || inherits(xi1, "POSIXct")) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else {
body:                   fixed <- FALSE
body:                   break
body:                 }
body:             }
body:             if (fixed) {
body:                 vlist[[i]] <- xi
body:                 next
body:             }
body:         }
body:         stop(gettextf("arguments imply differing number of rows: %s", paste(unique(nrows), collapse = ", ")), domain = NA)
body:     }
body:     value <- unlist(vlist, recursive = FALSE, use.names = FALSE)
body:     vnames <- unlist(vnames[ncols > 0L])
body:     noname <- !nzchar(vnames)
body:     if (any(noname)) 
body:         vnames[noname] <- paste("Var", seq_along(vnames), sep = ".")[noname]
body:     if (check.names) 
body:         vnames <- make.names(vnames, unique = TRUE)
body:     names(value) <- vnames
body:     if (!mrn) {
body:         if (length(row.names) == 1L && nr != 1L) {
body:             if (is.character(row.names)) 
body:                 row.names <- match(row.names, vnames, 0L)
body:             if (length(row.names) != 1L || row.names < 1L || row.names > length(vnames)) 
body:                 stop("'row.names' should specify one of the variables")
body:             i <- row.names
body:             row.names <- value[[i]]
body:             value <- value[-i]
body:         }
body:         else if (!is.null(row.names) && length(row.names) != nr) 
body:             stop("row names supplied are of the wrong length")
body:     }
body:     else if (!is.null(row.names) && length(row.names) != nr) {
body:         warning("row names were found from a short variable and have been discarded")
body:         row.names <- NULL
body:     }
body:     if (is.null(row.names)) 
body:         row.names <- .set_row_names(nr)
body:     else {
body:         if (is.object(row.names) || !is.integer(row.names)) 
body:             row.names <- as.character(row.names)
body:         if (any(is.na(row.names))) 
body:             stop("row names contain missing values")
body:         if (anyDuplicated(row.names)) 
body:             stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:     }
body:     attr(value, "row.names") <- row.names
body:     attr(value, "class") <- "data.frame"
body:     value
body: }
args: list(check.names = FALSE, stringsAsFactors = TRUE)
retn: structure(list(), .Names = character(0), row.names = integer(0), class = "data.frame")

func: quote(data.frame)
body: function (..., row.names = NULL, check.rows = FALSE, check.names = TRUE, stringsAsFactors = default.stringsAsFactors()) 
body: {
body:     data.row.names <- if (check.rows && is.null(row.names)) 
body:         function(current, new, i) {
body:             if (is.character(current)) 
body:                 new <- as.character(new)
body:             if (is.character(new)) 
body:                 current <- as.character(current)
body:             if (anyDuplicated(new)) 
body:                 return(current)
body:             if (is.null(current)) 
body:                 return(new)
body:             if (all(current == new) || all(current == "")) 
body:                 return(new)
body:             stop(gettextf("mismatch of row names in arguments of 'data.frame', item %d", i), domain = NA)
body:         }
body:     else function(current, new, i) {
body:         if (is.null(current)) {
body:             if (anyDuplicated(new)) {
body:                 warning(gettextf("some row.names duplicated: %s --> row.names NOT used", paste(which(duplicated(new)), collapse = ",")), domain = NA)
body:                 current
body:             }
body:             else new
body:         }
body:         else current
body:     }
body:     object <- as.list(substitute(list(...)))[-1L]
body:     mirn <- missing(row.names)
body:     mrn <- is.null(row.names)
body:     x <- list(...)
body:     n <- length(x)
body:     if (n < 1L) {
body:         if (!mrn) {
body:             if (is.object(row.names) || !is.integer(row.names)) 
body:                 row.names <- as.character(row.names)
body:             if (any(is.na(row.names))) 
body:                 stop("row names contain missing values")
body:             if (anyDuplicated(row.names)) 
body:                 stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:         }
body:         else row.names <- integer()
body:         return(structure(list(), names = character(), row.names = row.names, class = "data.frame"))
body:     }
body:     vnames <- names(x)
body:     if (length(vnames) != n) 
body:         vnames <- character(n)
body:     no.vn <- !nzchar(vnames)
body:     vlist <- vnames <- as.list(vnames)
body:     nrows <- ncols <- integer(n)
body:     for (i in seq_len(n)) {
body:         xi <- if (is.character(x[[i]]) || is.list(x[[i]])) 
body:             as.data.frame(x[[i]], optional = TRUE, stringsAsFactors = stringsAsFactors)
body:         else as.data.frame(x[[i]], optional = TRUE)
body:         nrows[i] <- .row_names_info(xi)
body:         ncols[i] <- length(xi)
body:         namesi <- names(xi)
body:         if (ncols[i] > 1L) {
body:             if (length(namesi) == 0L) 
body:                 namesi <- seq_len(ncols[i])
body:             if (no.vn[i]) 
body:                 vnames[[i]] <- namesi
body:             else vnames[[i]] <- paste(vnames[[i]], namesi, sep = ".")
body:         }
body:         else {
body:             if (length(namesi)) 
body:                 vnames[[i]] <- namesi
body:             else if (no.vn[[i]]) {
body:                 tmpname <- deparse(object[[i]])[1L]
body:                 if (substr(tmpname, 1L, 2L) == "I(") {
body:                   ntmpn <- nchar(tmpname, "c")
body:                   if (substr(tmpname, ntmpn, ntmpn) == ")") 
body:                     tmpname <- substr(tmpname, 3L, ntmpn - 1L)
body:                 }
body:                 vnames[[i]] <- tmpname
body:             }
body:         }
body:         if (mirn && nrows[i] > 0L) {
body:             rowsi <- attr(xi, "row.names")
body:             nc <- nchar(rowsi, allowNA = FALSE)
body:             nc <- nc[!is.na(nc)]
body:             if (length(nc) && any(nc)) 
body:                 row.names <- data.row.names(row.names, rowsi, i)
body:         }
body:         nrows[i] <- abs(nrows[i])
body:         vlist[[i]] <- xi
body:     }
body:     nr <- max(nrows)
body:     for (i in seq_len(n)[nrows < nr]) {
body:         xi <- vlist[[i]]
body:         if (nrows[i] > 0L && (nr%%nrows[i] == 0L)) {
body:             xi <- unclass(xi)
body:             fixed <- TRUE
body:             for (j in seq_along(xi)) {
body:                 xi1 <- xi[[j]]
body:                 if (is.vector(xi1) || is.factor(xi1)) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else if (is.character(xi1) && inherits(xi1, "AsIs")) 
body:                   xi[[j]] <- structure(rep(xi1, length.out = nr), class = class(xi1))
body:                 else if (inherits(xi1, "Date") || inherits(xi1, "POSIXct")) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else {
body:                   fixed <- FALSE
body:                   break
body:                 }
body:             }
body:             if (fixed) {
body:                 vlist[[i]] <- xi
body:                 next
body:             }
body:         }
body:         stop(gettextf("arguments imply differing number of rows: %s", paste(unique(nrows), collapse = ", ")), domain = NA)
body:     }
body:     value <- unlist(vlist, recursive = FALSE, use.names = FALSE)
body:     vnames <- unlist(vnames[ncols > 0L])
body:     noname <- !nzchar(vnames)
body:     if (any(noname)) 
body:         vnames[noname] <- paste("Var", seq_along(vnames), sep = ".")[noname]
body:     if (check.names) 
body:         vnames <- make.names(vnames, unique = TRUE)
body:     names(value) <- vnames
body:     if (!mrn) {
body:         if (length(row.names) == 1L && nr != 1L) {
body:             if (is.character(row.names)) 
body:                 row.names <- match(row.names, vnames, 0L)
body:             if (length(row.names) != 1L || row.names < 1L || row.names > length(vnames)) 
body:                 stop("'row.names' should specify one of the variables")
body:             i <- row.names
body:             row.names <- value[[i]]
body:             value <- value[-i]
body:         }
body:         else if (!is.null(row.names) && length(row.names) != nr) 
body:             stop("row names supplied are of the wrong length")
body:     }
body:     else if (!is.null(row.names) && length(row.names) != nr) {
body:         warning("row names were found from a short variable and have been discarded")
body:         row.names <- NULL
body:     }
body:     if (is.null(row.names)) 
body:         row.names <- .set_row_names(nr)
body:     else {
body:         if (is.object(row.names) || !is.integer(row.names)) 
body:             row.names <- as.character(row.names)
body:         if (any(is.na(row.names))) 
body:             stop("row names contain missing values")
body:         if (anyDuplicated(row.names)) 
body:             stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:     }
body:     attr(value, "row.names") <- row.names
body:     attr(value, "class") <- "data.frame"
body:     value
body: }
args: list(`FALSE` = structure("FALSE", class = "AsIs"), `FALSE` = structure("FALSE", class = "AsIs"), check.names = FALSE, row.names = "1")
retn: structure(list(`FALSE` = structure("FALSE", class = "AsIs"), `FALSE` = structure("FALSE", class = "AsIs")), .Names = c("FALSE", "FALSE"), row.names = "1", class = "data.frame")

func: quote(data.frame)
body: function (..., row.names = NULL, check.rows = FALSE, check.names = TRUE, stringsAsFactors = default.stringsAsFactors()) 
body: {
body:     data.row.names <- if (check.rows && is.null(row.names)) 
body:         function(current, new, i) {
body:             if (is.character(current)) 
body:                 new <- as.character(new)
body:             if (is.character(new)) 
body:                 current <- as.character(current)
body:             if (anyDuplicated(new)) 
body:                 return(current)
body:             if (is.null(current)) 
body:                 return(new)
body:             if (all(current == new) || all(current == "")) 
body:                 return(new)
body:             stop(gettextf("mismatch of row names in arguments of 'data.frame', item %d", i), domain = NA)
body:         }
body:     else function(current, new, i) {
body:         if (is.null(current)) {
body:             if (anyDuplicated(new)) {
body:                 warning(gettextf("some row.names duplicated: %s --> row.names NOT used", paste(which(duplicated(new)), collapse = ",")), domain = NA)
body:                 current
body:             }
body:             else new
body:         }
body:         else current
body:     }
body:     object <- as.list(substitute(list(...)))[-1L]
body:     mirn <- missing(row.names)
body:     mrn <- is.null(row.names)
body:     x <- list(...)
body:     n <- length(x)
body:     if (n < 1L) {
body:         if (!mrn) {
body:             if (is.object(row.names) || !is.integer(row.names)) 
body:                 row.names <- as.character(row.names)
body:             if (any(is.na(row.names))) 
body:                 stop("row names contain missing values")
body:             if (anyDuplicated(row.names)) 
body:                 stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:         }
body:         else row.names <- integer()
body:         return(structure(list(), names = character(), row.names = row.names, class = "data.frame"))
body:     }
body:     vnames <- names(x)
body:     if (length(vnames) != n) 
body:         vnames <- character(n)
body:     no.vn <- !nzchar(vnames)
body:     vlist <- vnames <- as.list(vnames)
body:     nrows <- ncols <- integer(n)
body:     for (i in seq_len(n)) {
body:         xi <- if (is.character(x[[i]]) || is.list(x[[i]])) 
body:             as.data.frame(x[[i]], optional = TRUE, stringsAsFactors = stringsAsFactors)
body:         else as.data.frame(x[[i]], optional = TRUE)
body:         nrows[i] <- .row_names_info(xi)
body:         ncols[i] <- length(xi)
body:         namesi <- names(xi)
body:         if (ncols[i] > 1L) {
body:             if (length(namesi) == 0L) 
body:                 namesi <- seq_len(ncols[i])
body:             if (no.vn[i]) 
body:                 vnames[[i]] <- namesi
body:             else vnames[[i]] <- paste(vnames[[i]], namesi, sep = ".")
body:         }
body:         else {
body:             if (length(namesi)) 
body:                 vnames[[i]] <- namesi
body:             else if (no.vn[[i]]) {
body:                 tmpname <- deparse(object[[i]])[1L]
body:                 if (substr(tmpname, 1L, 2L) == "I(") {
body:                   ntmpn <- nchar(tmpname, "c")
body:                   if (substr(tmpname, ntmpn, ntmpn) == ")") 
body:                     tmpname <- substr(tmpname, 3L, ntmpn - 1L)
body:                 }
body:                 vnames[[i]] <- tmpname
body:             }
body:         }
body:         if (mirn && nrows[i] > 0L) {
body:             rowsi <- attr(xi, "row.names")
body:             nc <- nchar(rowsi, allowNA = FALSE)
body:             nc <- nc[!is.na(nc)]
body:             if (length(nc) && any(nc)) 
body:                 row.names <- data.row.names(row.names, rowsi, i)
body:         }
body:         nrows[i] <- abs(nrows[i])
body:         vlist[[i]] <- xi
body:     }
body:     nr <- max(nrows)
body:     for (i in seq_len(n)[nrows < nr]) {
body:         xi <- vlist[[i]]
body:         if (nrows[i] > 0L && (nr%%nrows[i] == 0L)) {
body:             xi <- unclass(xi)
body:             fixed <- TRUE
body:             for (j in seq_along(xi)) {
body:                 xi1 <- xi[[j]]
body:                 if (is.vector(xi1) || is.factor(xi1)) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else if (is.character(xi1) && inherits(xi1, "AsIs")) 
body:                   xi[[j]] <- structure(rep(xi1, length.out = nr), class = class(xi1))
body:                 else if (inherits(xi1, "Date") || inherits(xi1, "POSIXct")) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else {
body:                   fixed <- FALSE
body:                   break
body:                 }
body:             }
body:             if (fixed) {
body:                 vlist[[i]] <- xi
body:                 next
body:             }
body:         }
body:         stop(gettextf("arguments imply differing number of rows: %s", paste(unique(nrows), collapse = ", ")), domain = NA)
body:     }
body:     value <- unlist(vlist, recursive = FALSE, use.names = FALSE)
body:     vnames <- unlist(vnames[ncols > 0L])
body:     noname <- !nzchar(vnames)
body:     if (any(noname)) 
body:         vnames[noname] <- paste("Var", seq_along(vnames), sep = ".")[noname]
body:     if (check.names) 
body:         vnames <- make.names(vnames, unique = TRUE)
body:     names(value) <- vnames
body:     if (!mrn) {
body:         if (length(row.names) == 1L && nr != 1L) {
body:             if (is.character(row.names)) 
body:                 row.names <- match(row.names, vnames, 0L)
body:             if (length(row.names) != 1L || row.names < 1L || row.names > length(vnames)) 
body:                 stop("'row.names' should specify one of the variables")
body:             i <- row.names
body:             row.names <- value[[i]]
body:             value <- value[-i]
body:         }
body:         else if (!is.null(row.names) && length(row.names) != nr) 
body:             stop("row names supplied are of the wrong length")
body:     }
body:     else if (!is.null(row.names) && length(row.names) != nr) {
body:         warning("row names were found from a short variable and have been discarded")
body:         row.names <- NULL
body:     }
body:     if (is.null(row.names)) 
body:         row.names <- .set_row_names(nr)
body:     else {
body:         if (is.object(row.names) || !is.integer(row.names)) 
body:             row.names <- as.character(row.names)
body:         if (any(is.na(row.names))) 
body:             stop("row names contain missing values")
body:         if (anyDuplicated(row.names)) 
body:             stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:     }
body:     attr(value, "row.names") <- row.names
body:     attr(value, "class") <- "data.frame"
body:     value
body: }
args: list(FALSE. = structure("FALSE", class = "AsIs"), FALSE..1 = structure("FALSE", class = "AsIs"), check.names = FALSE, row.names = "1")
retn: structure(list(FALSE. = structure("FALSE", class = "AsIs"), FALSE..1 = structure("FALSE", class = "AsIs")), .Names = c("FALSE.", "FALSE..1"), row.names = "1", class = "data.frame")

func: quote(data.frame)
body: function (..., row.names = NULL, check.rows = FALSE, check.names = TRUE, stringsAsFactors = default.stringsAsFactors()) 
body: {
body:     data.row.names <- if (check.rows && is.null(row.names)) 
body:         function(current, new, i) {
body:             if (is.character(current)) 
body:                 new <- as.character(new)
body:             if (is.character(new)) 
body:                 current <- as.character(current)
body:             if (anyDuplicated(new)) 
body:                 return(current)
body:             if (is.null(current)) 
body:                 return(new)
body:             if (all(current == new) || all(current == "")) 
body:                 return(new)
body:             stop(gettextf("mismatch of row names in arguments of 'data.frame', item %d", i), domain = NA)
body:         }
body:     else function(current, new, i) {
body:         if (is.null(current)) {
body:             if (anyDuplicated(new)) {
body:                 warning(gettextf("some row.names duplicated: %s --> row.names NOT used", paste(which(duplicated(new)), collapse = ",")), domain = NA)
body:                 current
body:             }
body:             else new
body:         }
body:         else current
body:     }
body:     object <- as.list(substitute(list(...)))[-1L]
body:     mirn <- missing(row.names)
body:     mrn <- is.null(row.names)
body:     x <- list(...)
body:     n <- length(x)
body:     if (n < 1L) {
body:         if (!mrn) {
body:             if (is.object(row.names) || !is.integer(row.names)) 
body:                 row.names <- as.character(row.names)
body:             if (any(is.na(row.names))) 
body:                 stop("row names contain missing values")
body:             if (anyDuplicated(row.names)) 
body:                 stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:         }
body:         else row.names <- integer()
body:         return(structure(list(), names = character(), row.names = row.names, class = "data.frame"))
body:     }
body:     vnames <- names(x)
body:     if (length(vnames) != n) 
body:         vnames <- character(n)
body:     no.vn <- !nzchar(vnames)
body:     vlist <- vnames <- as.list(vnames)
body:     nrows <- ncols <- integer(n)
body:     for (i in seq_len(n)) {
body:         xi <- if (is.character(x[[i]]) || is.list(x[[i]])) 
body:             as.data.frame(x[[i]], optional = TRUE, stringsAsFactors = stringsAsFactors)
body:         else as.data.frame(x[[i]], optional = TRUE)
body:         nrows[i] <- .row_names_info(xi)
body:         ncols[i] <- length(xi)
body:         namesi <- names(xi)
body:         if (ncols[i] > 1L) {
body:             if (length(namesi) == 0L) 
body:                 namesi <- seq_len(ncols[i])
body:             if (no.vn[i]) 
body:                 vnames[[i]] <- namesi
body:             else vnames[[i]] <- paste(vnames[[i]], namesi, sep = ".")
body:         }
body:         else {
body:             if (length(namesi)) 
body:                 vnames[[i]] <- namesi
body:             else if (no.vn[[i]]) {
body:                 tmpname <- deparse(object[[i]])[1L]
body:                 if (substr(tmpname, 1L, 2L) == "I(") {
body:                   ntmpn <- nchar(tmpname, "c")
body:                   if (substr(tmpname, ntmpn, ntmpn) == ")") 
body:                     tmpname <- substr(tmpname, 3L, ntmpn - 1L)
body:                 }
body:                 vnames[[i]] <- tmpname
body:             }
body:         }
body:         if (mirn && nrows[i] > 0L) {
body:             rowsi <- attr(xi, "row.names")
body:             nc <- nchar(rowsi, allowNA = FALSE)
body:             nc <- nc[!is.na(nc)]
body:             if (length(nc) && any(nc)) 
body:                 row.names <- data.row.names(row.names, rowsi, i)
body:         }
body:         nrows[i] <- abs(nrows[i])
body:         vlist[[i]] <- xi
body:     }
body:     nr <- max(nrows)
body:     for (i in seq_len(n)[nrows < nr]) {
body:         xi <- vlist[[i]]
body:         if (nrows[i] > 0L && (nr%%nrows[i] == 0L)) {
body:             xi <- unclass(xi)
body:             fixed <- TRUE
body:             for (j in seq_along(xi)) {
body:                 xi1 <- xi[[j]]
body:                 if (is.vector(xi1) || is.factor(xi1)) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else if (is.character(xi1) && inherits(xi1, "AsIs")) 
body:                   xi[[j]] <- structure(rep(xi1, length.out = nr), class = class(xi1))
body:                 else if (inherits(xi1, "Date") || inherits(xi1, "POSIXct")) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else {
body:                   fixed <- FALSE
body:                   break
body:                 }
body:             }
body:             if (fixed) {
body:                 vlist[[i]] <- xi
body:                 next
body:             }
body:         }
body:         stop(gettextf("arguments imply differing number of rows: %s", paste(unique(nrows), collapse = ", ")), domain = NA)
body:     }
body:     value <- unlist(vlist, recursive = FALSE, use.names = FALSE)
body:     vnames <- unlist(vnames[ncols > 0L])
body:     noname <- !nzchar(vnames)
body:     if (any(noname)) 
body:         vnames[noname] <- paste("Var", seq_along(vnames), sep = ".")[noname]
body:     if (check.names) 
body:         vnames <- make.names(vnames, unique = TRUE)
body:     names(value) <- vnames
body:     if (!mrn) {
body:         if (length(row.names) == 1L && nr != 1L) {
body:             if (is.character(row.names)) 
body:                 row.names <- match(row.names, vnames, 0L)
body:             if (length(row.names) != 1L || row.names < 1L || row.names > length(vnames)) 
body:                 stop("'row.names' should specify one of the variables")
body:             i <- row.names
body:             row.names <- value[[i]]
body:             value <- value[-i]
body:         }
body:         else if (!is.null(row.names) && length(row.names) != nr) 
body:             stop("row names supplied are of the wrong length")
body:     }
body:     else if (!is.null(row.names) && length(row.names) != nr) {
body:         warning("row names were found from a short variable and have been discarded")
body:         row.names <- NULL
body:     }
body:     if (is.null(row.names)) 
body:         row.names <- .set_row_names(nr)
body:     else {
body:         if (is.object(row.names) || !is.integer(row.names)) 
body:             row.names <- as.character(row.names)
body:         if (any(is.na(row.names))) 
body:             stop("row names contain missing values")
body:         if (anyDuplicated(row.names)) 
body:             stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:     }
body:     attr(value, "row.names") <- row.names
body:     attr(value, "class") <- "data.frame"
body:     value
body: }
args: list(Var1 = structure("FALSE", class = "AsIs"), check.names = FALSE, row.names = "1")
retn: structure(list(Var1 = structure("FALSE", class = "AsIs")), .Names = "Var1", row.names = "1", class = "data.frame")

func: quote(data.frame)
body: function (..., row.names = NULL, check.rows = FALSE, check.names = TRUE, stringsAsFactors = default.stringsAsFactors()) 
body: {
body:     data.row.names <- if (check.rows && is.null(row.names)) 
body:         function(current, new, i) {
body:             if (is.character(current)) 
body:                 new <- as.character(new)
body:             if (is.character(new)) 
body:                 current <- as.character(current)
body:             if (anyDuplicated(new)) 
body:                 return(current)
body:             if (is.null(current)) 
body:                 return(new)
body:             if (all(current == new) || all(current == "")) 
body:                 return(new)
body:             stop(gettextf("mismatch of row names in arguments of 'data.frame', item %d", i), domain = NA)
body:         }
body:     else function(current, new, i) {
body:         if (is.null(current)) {
body:             if (anyDuplicated(new)) {
body:                 warning(gettextf("some row.names duplicated: %s --> row.names NOT used", paste(which(duplicated(new)), collapse = ",")), domain = NA)
body:                 current
body:             }
body:             else new
body:         }
body:         else current
body:     }
body:     object <- as.list(substitute(list(...)))[-1L]
body:     mirn <- missing(row.names)
body:     mrn <- is.null(row.names)
body:     x <- list(...)
body:     n <- length(x)
body:     if (n < 1L) {
body:         if (!mrn) {
body:             if (is.object(row.names) || !is.integer(row.names)) 
body:                 row.names <- as.character(row.names)
body:             if (any(is.na(row.names))) 
body:                 stop("row names contain missing values")
body:             if (anyDuplicated(row.names)) 
body:                 stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:         }
body:         else row.names <- integer()
body:         return(structure(list(), names = character(), row.names = row.names, class = "data.frame"))
body:     }
body:     vnames <- names(x)
body:     if (length(vnames) != n) 
body:         vnames <- character(n)
body:     no.vn <- !nzchar(vnames)
body:     vlist <- vnames <- as.list(vnames)
body:     nrows <- ncols <- integer(n)
body:     for (i in seq_len(n)) {
body:         xi <- if (is.character(x[[i]]) || is.list(x[[i]])) 
body:             as.data.frame(x[[i]], optional = TRUE, stringsAsFactors = stringsAsFactors)
body:         else as.data.frame(x[[i]], optional = TRUE)
body:         nrows[i] <- .row_names_info(xi)
body:         ncols[i] <- length(xi)
body:         namesi <- names(xi)
body:         if (ncols[i] > 1L) {
body:             if (length(namesi) == 0L) 
body:                 namesi <- seq_len(ncols[i])
body:             if (no.vn[i]) 
body:                 vnames[[i]] <- namesi
body:             else vnames[[i]] <- paste(vnames[[i]], namesi, sep = ".")
body:         }
body:         else {
body:             if (length(namesi)) 
body:                 vnames[[i]] <- namesi
body:             else if (no.vn[[i]]) {
body:                 tmpname <- deparse(object[[i]])[1L]
body:                 if (substr(tmpname, 1L, 2L) == "I(") {
body:                   ntmpn <- nchar(tmpname, "c")
body:                   if (substr(tmpname, ntmpn, ntmpn) == ")") 
body:                     tmpname <- substr(tmpname, 3L, ntmpn - 1L)
body:                 }
body:                 vnames[[i]] <- tmpname
body:             }
body:         }
body:         if (mirn && nrows[i] > 0L) {
body:             rowsi <- attr(xi, "row.names")
body:             nc <- nchar(rowsi, allowNA = FALSE)
body:             nc <- nc[!is.na(nc)]
body:             if (length(nc) && any(nc)) 
body:                 row.names <- data.row.names(row.names, rowsi, i)
body:         }
body:         nrows[i] <- abs(nrows[i])
body:         vlist[[i]] <- xi
body:     }
body:     nr <- max(nrows)
body:     for (i in seq_len(n)[nrows < nr]) {
body:         xi <- vlist[[i]]
body:         if (nrows[i] > 0L && (nr%%nrows[i] == 0L)) {
body:             xi <- unclass(xi)
body:             fixed <- TRUE
body:             for (j in seq_along(xi)) {
body:                 xi1 <- xi[[j]]
body:                 if (is.vector(xi1) || is.factor(xi1)) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else if (is.character(xi1) && inherits(xi1, "AsIs")) 
body:                   xi[[j]] <- structure(rep(xi1, length.out = nr), class = class(xi1))
body:                 else if (inherits(xi1, "Date") || inherits(xi1, "POSIXct")) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else {
body:                   fixed <- FALSE
body:                   break
body:                 }
body:             }
body:             if (fixed) {
body:                 vlist[[i]] <- xi
body:                 next
body:             }
body:         }
body:         stop(gettextf("arguments imply differing number of rows: %s", paste(unique(nrows), collapse = ", ")), domain = NA)
body:     }
body:     value <- unlist(vlist, recursive = FALSE, use.names = FALSE)
body:     vnames <- unlist(vnames[ncols > 0L])
body:     noname <- !nzchar(vnames)
body:     if (any(noname)) 
body:         vnames[noname] <- paste("Var", seq_along(vnames), sep = ".")[noname]
body:     if (check.names) 
body:         vnames <- make.names(vnames, unique = TRUE)
body:     names(value) <- vnames
body:     if (!mrn) {
body:         if (length(row.names) == 1L && nr != 1L) {
body:             if (is.character(row.names)) 
body:                 row.names <- match(row.names, vnames, 0L)
body:             if (length(row.names) != 1L || row.names < 1L || row.names > length(vnames)) 
body:                 stop("'row.names' should specify one of the variables")
body:             i <- row.names
body:             row.names <- value[[i]]
body:             value <- value[-i]
body:         }
body:         else if (!is.null(row.names) && length(row.names) != nr) 
body:             stop("row names supplied are of the wrong length")
body:     }
body:     else if (!is.null(row.names) && length(row.names) != nr) {
body:         warning("row names were found from a short variable and have been discarded")
body:         row.names <- NULL
body:     }
body:     if (is.null(row.names)) 
body:         row.names <- .set_row_names(nr)
body:     else {
body:         if (is.object(row.names) || !is.integer(row.names)) 
body:             row.names <- as.character(row.names)
body:         if (any(is.na(row.names))) 
body:             stop("row names contain missing values")
body:         if (anyDuplicated(row.names)) 
body:             stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:     }
body:     attr(value, "row.names") <- row.names
body:     attr(value, "class") <- "data.frame"
body:     value
body: }
args: list(Var1 = structure("", .Names = "c0", class = "AsIs"), Var2 = structure("", .Names = "c0", class = "AsIs"), check.names = FALSE, row.names = "1")
retn: structure(list(Var1 = structure("", .Names = "c0", class = "AsIs"), Var2 = structure("", .Names = "c0", class = "AsIs")), .Names = c("Var1", "Var2"), row.names = "1", class = "data.frame")

func: quote(data.frame)
body: function (..., row.names = NULL, check.rows = FALSE, check.names = TRUE, stringsAsFactors = default.stringsAsFactors()) 
body: {
body:     data.row.names <- if (check.rows && is.null(row.names)) 
body:         function(current, new, i) {
body:             if (is.character(current)) 
body:                 new <- as.character(new)
body:             if (is.character(new)) 
body:                 current <- as.character(current)
body:             if (anyDuplicated(new)) 
body:                 return(current)
body:             if (is.null(current)) 
body:                 return(new)
body:             if (all(current == new) || all(current == "")) 
body:                 return(new)
body:             stop(gettextf("mismatch of row names in arguments of 'data.frame', item %d", i), domain = NA)
body:         }
body:     else function(current, new, i) {
body:         if (is.null(current)) {
body:             if (anyDuplicated(new)) {
body:                 warning(gettextf("some row.names duplicated: %s --> row.names NOT used", paste(which(duplicated(new)), collapse = ",")), domain = NA)
body:                 current
body:             }
body:             else new
body:         }
body:         else current
body:     }
body:     object <- as.list(substitute(list(...)))[-1L]
body:     mirn <- missing(row.names)
body:     mrn <- is.null(row.names)
body:     x <- list(...)
body:     n <- length(x)
body:     if (n < 1L) {
body:         if (!mrn) {
body:             if (is.object(row.names) || !is.integer(row.names)) 
body:                 row.names <- as.character(row.names)
body:             if (any(is.na(row.names))) 
body:                 stop("row names contain missing values")
body:             if (anyDuplicated(row.names)) 
body:                 stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:         }
body:         else row.names <- integer()
body:         return(structure(list(), names = character(), row.names = row.names, class = "data.frame"))
body:     }
body:     vnames <- names(x)
body:     if (length(vnames) != n) 
body:         vnames <- character(n)
body:     no.vn <- !nzchar(vnames)
body:     vlist <- vnames <- as.list(vnames)
body:     nrows <- ncols <- integer(n)
body:     for (i in seq_len(n)) {
body:         xi <- if (is.character(x[[i]]) || is.list(x[[i]])) 
body:             as.data.frame(x[[i]], optional = TRUE, stringsAsFactors = stringsAsFactors)
body:         else as.data.frame(x[[i]], optional = TRUE)
body:         nrows[i] <- .row_names_info(xi)
body:         ncols[i] <- length(xi)
body:         namesi <- names(xi)
body:         if (ncols[i] > 1L) {
body:             if (length(namesi) == 0L) 
body:                 namesi <- seq_len(ncols[i])
body:             if (no.vn[i]) 
body:                 vnames[[i]] <- namesi
body:             else vnames[[i]] <- paste(vnames[[i]], namesi, sep = ".")
body:         }
body:         else {
body:             if (length(namesi)) 
body:                 vnames[[i]] <- namesi
body:             else if (no.vn[[i]]) {
body:                 tmpname <- deparse(object[[i]])[1L]
body:                 if (substr(tmpname, 1L, 2L) == "I(") {
body:                   ntmpn <- nchar(tmpname, "c")
body:                   if (substr(tmpname, ntmpn, ntmpn) == ")") 
body:                     tmpname <- substr(tmpname, 3L, ntmpn - 1L)
body:                 }
body:                 vnames[[i]] <- tmpname
body:             }
body:         }
body:         if (mirn && nrows[i] > 0L) {
body:             rowsi <- attr(xi, "row.names")
body:             nc <- nchar(rowsi, allowNA = FALSE)
body:             nc <- nc[!is.na(nc)]
body:             if (length(nc) && any(nc)) 
body:                 row.names <- data.row.names(row.names, rowsi, i)
body:         }
body:         nrows[i] <- abs(nrows[i])
body:         vlist[[i]] <- xi
body:     }
body:     nr <- max(nrows)
body:     for (i in seq_len(n)[nrows < nr]) {
body:         xi <- vlist[[i]]
body:         if (nrows[i] > 0L && (nr%%nrows[i] == 0L)) {
body:             xi <- unclass(xi)
body:             fixed <- TRUE
body:             for (j in seq_along(xi)) {
body:                 xi1 <- xi[[j]]
body:                 if (is.vector(xi1) || is.factor(xi1)) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else if (is.character(xi1) && inherits(xi1, "AsIs")) 
body:                   xi[[j]] <- structure(rep(xi1, length.out = nr), class = class(xi1))
body:                 else if (inherits(xi1, "Date") || inherits(xi1, "POSIXct")) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else {
body:                   fixed <- FALSE
body:                   break
body:                 }
body:             }
body:             if (fixed) {
body:                 vlist[[i]] <- xi
body:                 next
body:             }
body:         }
body:         stop(gettextf("arguments imply differing number of rows: %s", paste(unique(nrows), collapse = ", ")), domain = NA)
body:     }
body:     value <- unlist(vlist, recursive = FALSE, use.names = FALSE)
body:     vnames <- unlist(vnames[ncols > 0L])
body:     noname <- !nzchar(vnames)
body:     if (any(noname)) 
body:         vnames[noname] <- paste("Var", seq_along(vnames), sep = ".")[noname]
body:     if (check.names) 
body:         vnames <- make.names(vnames, unique = TRUE)
body:     names(value) <- vnames
body:     if (!mrn) {
body:         if (length(row.names) == 1L && nr != 1L) {
body:             if (is.character(row.names)) 
body:                 row.names <- match(row.names, vnames, 0L)
body:             if (length(row.names) != 1L || row.names < 1L || row.names > length(vnames)) 
body:                 stop("'row.names' should specify one of the variables")
body:             i <- row.names
body:             row.names <- value[[i]]
body:             value <- value[-i]
body:         }
body:         else if (!is.null(row.names) && length(row.names) != nr) 
body:             stop("row names supplied are of the wrong length")
body:     }
body:     else if (!is.null(row.names) && length(row.names) != nr) {
body:         warning("row names were found from a short variable and have been discarded")
body:         row.names <- NULL
body:     }
body:     if (is.null(row.names)) 
body:         row.names <- .set_row_names(nr)
body:     else {
body:         if (is.object(row.names) || !is.integer(row.names)) 
body:             row.names <- as.character(row.names)
body:         if (any(is.na(row.names))) 
body:             stop("row names contain missing values")
body:         if (anyDuplicated(row.names)) 
body:             stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:     }
body:     attr(value, "row.names") <- row.names
body:     attr(value, "class") <- "data.frame"
body:     value
body: }
args: list(Var1 = structure("FALSE", class = "AsIs"), Var2 = structure("FALSE", class = "AsIs"), check.names = FALSE, row.names = "1")
retn: structure(list(Var1 = structure("FALSE", class = "AsIs"), Var2 = structure("FALSE", class = "AsIs")), .Names = c("Var1", "Var2"), row.names = "1", class = "data.frame")

func: quote(data.frame)
body: function (..., row.names = NULL, check.rows = FALSE, check.names = TRUE, stringsAsFactors = default.stringsAsFactors()) 
body: {
body:     data.row.names <- if (check.rows && is.null(row.names)) 
body:         function(current, new, i) {
body:             if (is.character(current)) 
body:                 new <- as.character(new)
body:             if (is.character(new)) 
body:                 current <- as.character(current)
body:             if (anyDuplicated(new)) 
body:                 return(current)
body:             if (is.null(current)) 
body:                 return(new)
body:             if (all(current == new) || all(current == "")) 
body:                 return(new)
body:             stop(gettextf("mismatch of row names in arguments of 'data.frame', item %d", i), domain = NA)
body:         }
body:     else function(current, new, i) {
body:         if (is.null(current)) {
body:             if (anyDuplicated(new)) {
body:                 warning(gettextf("some row.names duplicated: %s --> row.names NOT used", paste(which(duplicated(new)), collapse = ",")), domain = NA)
body:                 current
body:             }
body:             else new
body:         }
body:         else current
body:     }
body:     object <- as.list(substitute(list(...)))[-1L]
body:     mirn <- missing(row.names)
body:     mrn <- is.null(row.names)
body:     x <- list(...)
body:     n <- length(x)
body:     if (n < 1L) {
body:         if (!mrn) {
body:             if (is.object(row.names) || !is.integer(row.names)) 
body:                 row.names <- as.character(row.names)
body:             if (any(is.na(row.names))) 
body:                 stop("row names contain missing values")
body:             if (anyDuplicated(row.names)) 
body:                 stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:         }
body:         else row.names <- integer()
body:         return(structure(list(), names = character(), row.names = row.names, class = "data.frame"))
body:     }
body:     vnames <- names(x)
body:     if (length(vnames) != n) 
body:         vnames <- character(n)
body:     no.vn <- !nzchar(vnames)
body:     vlist <- vnames <- as.list(vnames)
body:     nrows <- ncols <- integer(n)
body:     for (i in seq_len(n)) {
body:         xi <- if (is.character(x[[i]]) || is.list(x[[i]])) 
body:             as.data.frame(x[[i]], optional = TRUE, stringsAsFactors = stringsAsFactors)
body:         else as.data.frame(x[[i]], optional = TRUE)
body:         nrows[i] <- .row_names_info(xi)
body:         ncols[i] <- length(xi)
body:         namesi <- names(xi)
body:         if (ncols[i] > 1L) {
body:             if (length(namesi) == 0L) 
body:                 namesi <- seq_len(ncols[i])
body:             if (no.vn[i]) 
body:                 vnames[[i]] <- namesi
body:             else vnames[[i]] <- paste(vnames[[i]], namesi, sep = ".")
body:         }
body:         else {
body:             if (length(namesi)) 
body:                 vnames[[i]] <- namesi
body:             else if (no.vn[[i]]) {
body:                 tmpname <- deparse(object[[i]])[1L]
body:                 if (substr(tmpname, 1L, 2L) == "I(") {
body:                   ntmpn <- nchar(tmpname, "c")
body:                   if (substr(tmpname, ntmpn, ntmpn) == ")") 
body:                     tmpname <- substr(tmpname, 3L, ntmpn - 1L)
body:                 }
body:                 vnames[[i]] <- tmpname
body:             }
body:         }
body:         if (mirn && nrows[i] > 0L) {
body:             rowsi <- attr(xi, "row.names")
body:             nc <- nchar(rowsi, allowNA = FALSE)
body:             nc <- nc[!is.na(nc)]
body:             if (length(nc) && any(nc)) 
body:                 row.names <- data.row.names(row.names, rowsi, i)
body:         }
body:         nrows[i] <- abs(nrows[i])
body:         vlist[[i]] <- xi
body:     }
body:     nr <- max(nrows)
body:     for (i in seq_len(n)[nrows < nr]) {
body:         xi <- vlist[[i]]
body:         if (nrows[i] > 0L && (nr%%nrows[i] == 0L)) {
body:             xi <- unclass(xi)
body:             fixed <- TRUE
body:             for (j in seq_along(xi)) {
body:                 xi1 <- xi[[j]]
body:                 if (is.vector(xi1) || is.factor(xi1)) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else if (is.character(xi1) && inherits(xi1, "AsIs")) 
body:                   xi[[j]] <- structure(rep(xi1, length.out = nr), class = class(xi1))
body:                 else if (inherits(xi1, "Date") || inherits(xi1, "POSIXct")) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else {
body:                   fixed <- FALSE
body:                   break
body:                 }
body:             }
body:             if (fixed) {
body:                 vlist[[i]] <- xi
body:                 next
body:             }
body:         }
body:         stop(gettextf("arguments imply differing number of rows: %s", paste(unique(nrows), collapse = ", ")), domain = NA)
body:     }
body:     value <- unlist(vlist, recursive = FALSE, use.names = FALSE)
body:     vnames <- unlist(vnames[ncols > 0L])
body:     noname <- !nzchar(vnames)
body:     if (any(noname)) 
body:         vnames[noname] <- paste("Var", seq_along(vnames), sep = ".")[noname]
body:     if (check.names) 
body:         vnames <- make.names(vnames, unique = TRUE)
body:     names(value) <- vnames
body:     if (!mrn) {
body:         if (length(row.names) == 1L && nr != 1L) {
body:             if (is.character(row.names)) 
body:                 row.names <- match(row.names, vnames, 0L)
body:             if (length(row.names) != 1L || row.names < 1L || row.names > length(vnames)) 
body:                 stop("'row.names' should specify one of the variables")
body:             i <- row.names
body:             row.names <- value[[i]]
body:             value <- value[-i]
body:         }
body:         else if (!is.null(row.names) && length(row.names) != nr) 
body:             stop("row names supplied are of the wrong length")
body:     }
body:     else if (!is.null(row.names) && length(row.names) != nr) {
body:         warning("row names were found from a short variable and have been discarded")
body:         row.names <- NULL
body:     }
body:     if (is.null(row.names)) 
body:         row.names <- .set_row_names(nr)
body:     else {
body:         if (is.object(row.names) || !is.integer(row.names)) 
body:             row.names <- as.character(row.names)
body:         if (any(is.na(row.names))) 
body:             stop("row names contain missing values")
body:         if (anyDuplicated(row.names)) 
body:             stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:     }
body:     attr(value, "row.names") <- row.names
body:     attr(value, "class") <- "data.frame"
body:     value
body: }
args: list(`NA` = structure("FALSE", class = "AsIs"), check.names = FALSE)
retn: structure(list(`NA` = structure("FALSE", class = "AsIs")), .Names = "NA", row.names = c(NA, -1L), class = "data.frame")

func: quote(data.frame)
body: function (..., row.names = NULL, check.rows = FALSE, check.names = TRUE, stringsAsFactors = default.stringsAsFactors()) 
body: {
body:     data.row.names <- if (check.rows && is.null(row.names)) 
body:         function(current, new, i) {
body:             if (is.character(current)) 
body:                 new <- as.character(new)
body:             if (is.character(new)) 
body:                 current <- as.character(current)
body:             if (anyDuplicated(new)) 
body:                 return(current)
body:             if (is.null(current)) 
body:                 return(new)
body:             if (all(current == new) || all(current == "")) 
body:                 return(new)
body:             stop(gettextf("mismatch of row names in arguments of 'data.frame', item %d", i), domain = NA)
body:         }
body:     else function(current, new, i) {
body:         if (is.null(current)) {
body:             if (anyDuplicated(new)) {
body:                 warning(gettextf("some row.names duplicated: %s --> row.names NOT used", paste(which(duplicated(new)), collapse = ",")), domain = NA)
body:                 current
body:             }
body:             else new
body:         }
body:         else current
body:     }
body:     object <- as.list(substitute(list(...)))[-1L]
body:     mirn <- missing(row.names)
body:     mrn <- is.null(row.names)
body:     x <- list(...)
body:     n <- length(x)
body:     if (n < 1L) {
body:         if (!mrn) {
body:             if (is.object(row.names) || !is.integer(row.names)) 
body:                 row.names <- as.character(row.names)
body:             if (any(is.na(row.names))) 
body:                 stop("row names contain missing values")
body:             if (anyDuplicated(row.names)) 
body:                 stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:         }
body:         else row.names <- integer()
body:         return(structure(list(), names = character(), row.names = row.names, class = "data.frame"))
body:     }
body:     vnames <- names(x)
body:     if (length(vnames) != n) 
body:         vnames <- character(n)
body:     no.vn <- !nzchar(vnames)
body:     vlist <- vnames <- as.list(vnames)
body:     nrows <- ncols <- integer(n)
body:     for (i in seq_len(n)) {
body:         xi <- if (is.character(x[[i]]) || is.list(x[[i]])) 
body:             as.data.frame(x[[i]], optional = TRUE, stringsAsFactors = stringsAsFactors)
body:         else as.data.frame(x[[i]], optional = TRUE)
body:         nrows[i] <- .row_names_info(xi)
body:         ncols[i] <- length(xi)
body:         namesi <- names(xi)
body:         if (ncols[i] > 1L) {
body:             if (length(namesi) == 0L) 
body:                 namesi <- seq_len(ncols[i])
body:             if (no.vn[i]) 
body:                 vnames[[i]] <- namesi
body:             else vnames[[i]] <- paste(vnames[[i]], namesi, sep = ".")
body:         }
body:         else {
body:             if (length(namesi)) 
body:                 vnames[[i]] <- namesi
body:             else if (no.vn[[i]]) {
body:                 tmpname <- deparse(object[[i]])[1L]
body:                 if (substr(tmpname, 1L, 2L) == "I(") {
body:                   ntmpn <- nchar(tmpname, "c")
body:                   if (substr(tmpname, ntmpn, ntmpn) == ")") 
body:                     tmpname <- substr(tmpname, 3L, ntmpn - 1L)
body:                 }
body:                 vnames[[i]] <- tmpname
body:             }
body:         }
body:         if (mirn && nrows[i] > 0L) {
body:             rowsi <- attr(xi, "row.names")
body:             nc <- nchar(rowsi, allowNA = FALSE)
body:             nc <- nc[!is.na(nc)]
body:             if (length(nc) && any(nc)) 
body:                 row.names <- data.row.names(row.names, rowsi, i)
body:         }
body:         nrows[i] <- abs(nrows[i])
body:         vlist[[i]] <- xi
body:     }
body:     nr <- max(nrows)
body:     for (i in seq_len(n)[nrows < nr]) {
body:         xi <- vlist[[i]]
body:         if (nrows[i] > 0L && (nr%%nrows[i] == 0L)) {
body:             xi <- unclass(xi)
body:             fixed <- TRUE
body:             for (j in seq_along(xi)) {
body:                 xi1 <- xi[[j]]
body:                 if (is.vector(xi1) || is.factor(xi1)) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else if (is.character(xi1) && inherits(xi1, "AsIs")) 
body:                   xi[[j]] <- structure(rep(xi1, length.out = nr), class = class(xi1))
body:                 else if (inherits(xi1, "Date") || inherits(xi1, "POSIXct")) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else {
body:                   fixed <- FALSE
body:                   break
body:                 }
body:             }
body:             if (fixed) {
body:                 vlist[[i]] <- xi
body:                 next
body:             }
body:         }
body:         stop(gettextf("arguments imply differing number of rows: %s", paste(unique(nrows), collapse = ", ")), domain = NA)
body:     }
body:     value <- unlist(vlist, recursive = FALSE, use.names = FALSE)
body:     vnames <- unlist(vnames[ncols > 0L])
body:     noname <- !nzchar(vnames)
body:     if (any(noname)) 
body:         vnames[noname] <- paste("Var", seq_along(vnames), sep = ".")[noname]
body:     if (check.names) 
body:         vnames <- make.names(vnames, unique = TRUE)
body:     names(value) <- vnames
body:     if (!mrn) {
body:         if (length(row.names) == 1L && nr != 1L) {
body:             if (is.character(row.names)) 
body:                 row.names <- match(row.names, vnames, 0L)
body:             if (length(row.names) != 1L || row.names < 1L || row.names > length(vnames)) 
body:                 stop("'row.names' should specify one of the variables")
body:             i <- row.names
body:             row.names <- value[[i]]
body:             value <- value[-i]
body:         }
body:         else if (!is.null(row.names) && length(row.names) != nr) 
body:             stop("row names supplied are of the wrong length")
body:     }
body:     else if (!is.null(row.names) && length(row.names) != nr) {
body:         warning("row names were found from a short variable and have been discarded")
body:         row.names <- NULL
body:     }
body:     if (is.null(row.names)) 
body:         row.names <- .set_row_names(nr)
body:     else {
body:         if (is.object(row.names) || !is.integer(row.names)) 
body:             row.names <- as.character(row.names)
body:         if (any(is.na(row.names))) 
body:             stop("row names contain missing values")
body:         if (anyDuplicated(row.names)) 
body:             stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:     }
body:     attr(value, "row.names") <- row.names
body:     attr(value, "class") <- "data.frame"
body:     value
body: }
args: list(`NA` = structure("FALSE", class = "AsIs"), check.names = FALSE, row.names = "1")
retn: structure(list(`NA` = structure("FALSE", class = "AsIs")), .Names = "NA", row.names = "1", class = "data.frame")

func: quote(data.frame)
body: function (..., row.names = NULL, check.rows = FALSE, check.names = TRUE, stringsAsFactors = default.stringsAsFactors()) 
body: {
body:     data.row.names <- if (check.rows && is.null(row.names)) 
body:         function(current, new, i) {
body:             if (is.character(current)) 
body:                 new <- as.character(new)
body:             if (is.character(new)) 
body:                 current <- as.character(current)
body:             if (anyDuplicated(new)) 
body:                 return(current)
body:             if (is.null(current)) 
body:                 return(new)
body:             if (all(current == new) || all(current == "")) 
body:                 return(new)
body:             stop(gettextf("mismatch of row names in arguments of 'data.frame', item %d", i), domain = NA)
body:         }
body:     else function(current, new, i) {
body:         if (is.null(current)) {
body:             if (anyDuplicated(new)) {
body:                 warning(gettextf("some row.names duplicated: %s --> row.names NOT used", paste(which(duplicated(new)), collapse = ",")), domain = NA)
body:                 current
body:             }
body:             else new
body:         }
body:         else current
body:     }
body:     object <- as.list(substitute(list(...)))[-1L]
body:     mirn <- missing(row.names)
body:     mrn <- is.null(row.names)
body:     x <- list(...)
body:     n <- length(x)
body:     if (n < 1L) {
body:         if (!mrn) {
body:             if (is.object(row.names) || !is.integer(row.names)) 
body:                 row.names <- as.character(row.names)
body:             if (any(is.na(row.names))) 
body:                 stop("row names contain missing values")
body:             if (anyDuplicated(row.names)) 
body:                 stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:         }
body:         else row.names <- integer()
body:         return(structure(list(), names = character(), row.names = row.names, class = "data.frame"))
body:     }
body:     vnames <- names(x)
body:     if (length(vnames) != n) 
body:         vnames <- character(n)
body:     no.vn <- !nzchar(vnames)
body:     vlist <- vnames <- as.list(vnames)
body:     nrows <- ncols <- integer(n)
body:     for (i in seq_len(n)) {
body:         xi <- if (is.character(x[[i]]) || is.list(x[[i]])) 
body:             as.data.frame(x[[i]], optional = TRUE, stringsAsFactors = stringsAsFactors)
body:         else as.data.frame(x[[i]], optional = TRUE)
body:         nrows[i] <- .row_names_info(xi)
body:         ncols[i] <- length(xi)
body:         namesi <- names(xi)
body:         if (ncols[i] > 1L) {
body:             if (length(namesi) == 0L) 
body:                 namesi <- seq_len(ncols[i])
body:             if (no.vn[i]) 
body:                 vnames[[i]] <- namesi
body:             else vnames[[i]] <- paste(vnames[[i]], namesi, sep = ".")
body:         }
body:         else {
body:             if (length(namesi)) 
body:                 vnames[[i]] <- namesi
body:             else if (no.vn[[i]]) {
body:                 tmpname <- deparse(object[[i]])[1L]
body:                 if (substr(tmpname, 1L, 2L) == "I(") {
body:                   ntmpn <- nchar(tmpname, "c")
body:                   if (substr(tmpname, ntmpn, ntmpn) == ")") 
body:                     tmpname <- substr(tmpname, 3L, ntmpn - 1L)
body:                 }
body:                 vnames[[i]] <- tmpname
body:             }
body:         }
body:         if (mirn && nrows[i] > 0L) {
body:             rowsi <- attr(xi, "row.names")
body:             nc <- nchar(rowsi, allowNA = FALSE)
body:             nc <- nc[!is.na(nc)]
body:             if (length(nc) && any(nc)) 
body:                 row.names <- data.row.names(row.names, rowsi, i)
body:         }
body:         nrows[i] <- abs(nrows[i])
body:         vlist[[i]] <- xi
body:     }
body:     nr <- max(nrows)
body:     for (i in seq_len(n)[nrows < nr]) {
body:         xi <- vlist[[i]]
body:         if (nrows[i] > 0L && (nr%%nrows[i] == 0L)) {
body:             xi <- unclass(xi)
body:             fixed <- TRUE
body:             for (j in seq_along(xi)) {
body:                 xi1 <- xi[[j]]
body:                 if (is.vector(xi1) || is.factor(xi1)) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else if (is.character(xi1) && inherits(xi1, "AsIs")) 
body:                   xi[[j]] <- structure(rep(xi1, length.out = nr), class = class(xi1))
body:                 else if (inherits(xi1, "Date") || inherits(xi1, "POSIXct")) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else {
body:                   fixed <- FALSE
body:                   break
body:                 }
body:             }
body:             if (fixed) {
body:                 vlist[[i]] <- xi
body:                 next
body:             }
body:         }
body:         stop(gettextf("arguments imply differing number of rows: %s", paste(unique(nrows), collapse = ", ")), domain = NA)
body:     }
body:     value <- unlist(vlist, recursive = FALSE, use.names = FALSE)
body:     vnames <- unlist(vnames[ncols > 0L])
body:     noname <- !nzchar(vnames)
body:     if (any(noname)) 
body:         vnames[noname] <- paste("Var", seq_along(vnames), sep = ".")[noname]
body:     if (check.names) 
body:         vnames <- make.names(vnames, unique = TRUE)
body:     names(value) <- vnames
body:     if (!mrn) {
body:         if (length(row.names) == 1L && nr != 1L) {
body:             if (is.character(row.names)) 
body:                 row.names <- match(row.names, vnames, 0L)
body:             if (length(row.names) != 1L || row.names < 1L || row.names > length(vnames)) 
body:                 stop("'row.names' should specify one of the variables")
body:             i <- row.names
body:             row.names <- value[[i]]
body:             value <- value[-i]
body:         }
body:         else if (!is.null(row.names) && length(row.names) != nr) 
body:             stop("row names supplied are of the wrong length")
body:     }
body:     else if (!is.null(row.names) && length(row.names) != nr) {
body:         warning("row names were found from a short variable and have been discarded")
body:         row.names <- NULL
body:     }
body:     if (is.null(row.names)) 
body:         row.names <- .set_row_names(nr)
body:     else {
body:         if (is.object(row.names) || !is.integer(row.names)) 
body:             row.names <- as.character(row.names)
body:         if (any(is.na(row.names))) 
body:             stop("row names contain missing values")
body:         if (anyDuplicated(row.names)) 
body:             stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:     }
body:     attr(value, "row.names") <- row.names
body:     attr(value, "class") <- "data.frame"
body:     value
body: }
args: list(Filename = structure(c("base", "/home/roman/r-instrumented/library/utils/libs/utils.so", "/home/roman/r-instrumented/library/methods/libs/methods.so", "/home/roman/r-instrumented/library/grDevices/libs/grDevices.so", "/home/roman/r-instrumented/library/graphics/libs/graphics.so", "/home/roman/r-instrumented/library/stats/libs/stats.so", "/home/roman/r-instrumented/modules//lapack.so", "/home/roman/r-instrumented/modules//R_X11.so"), class = "AsIs"), Dynamic.Lookup = structure(c("FALSE", "FALSE", 
args: "FALSE", "FALSE", "FALSE", "FALSE", " TRUE", " TRUE"), class = "AsIs"), check.names = FALSE, row.names = c("base", "utils", "methods", "grDevices", "graphics", "stats", "lapack", "R_X11"))
retn: structure(list(Filename = structure(c("base", "/home/roman/r-instrumented/library/utils/libs/utils.so", "/home/roman/r-instrumented/library/methods/libs/methods.so", "/home/roman/r-instrumented/library/grDevices/libs/grDevices.so", "/home/roman/r-instrumented/library/graphics/libs/graphics.so", "/home/roman/r-instrumented/library/stats/libs/stats.so", "/home/roman/r-instrumented/modules//lapack.so", "/home/roman/r-instrumented/modules//R_X11.so"), class = "AsIs"), Dynamic.Lookup = structure(c("FALSE", 
retn: "FALSE", "FALSE", "FALSE", "FALSE", "FALSE", " TRUE", " TRUE"), class = "AsIs")), .Names = c("Filename", "Dynamic.Lookup"), row.names = c("base", "utils", "methods", "grDevices", "graphics", "stats", "lapack", "R_X11"), class = "data.frame")

func: quote(data.frame)
body: function (..., row.names = NULL, check.rows = FALSE, check.names = TRUE, stringsAsFactors = default.stringsAsFactors()) 
body: {
body:     data.row.names <- if (check.rows && is.null(row.names)) 
body:         function(current, new, i) {
body:             if (is.character(current)) 
body:                 new <- as.character(new)
body:             if (is.character(new)) 
body:                 current <- as.character(current)
body:             if (anyDuplicated(new)) 
body:                 return(current)
body:             if (is.null(current)) 
body:                 return(new)
body:             if (all(current == new) || all(current == "")) 
body:                 return(new)
body:             stop(gettextf("mismatch of row names in arguments of 'data.frame', item %d", i), domain = NA)
body:         }
body:     else function(current, new, i) {
body:         if (is.null(current)) {
body:             if (anyDuplicated(new)) {
body:                 warning(gettextf("some row.names duplicated: %s --> row.names NOT used", paste(which(duplicated(new)), collapse = ",")), domain = NA)
body:                 current
body:             }
body:             else new
body:         }
body:         else current
body:     }
body:     object <- as.list(substitute(list(...)))[-1L]
body:     mirn <- missing(row.names)
body:     mrn <- is.null(row.names)
body:     x <- list(...)
body:     n <- length(x)
body:     if (n < 1L) {
body:         if (!mrn) {
body:             if (is.object(row.names) || !is.integer(row.names)) 
body:                 row.names <- as.character(row.names)
body:             if (any(is.na(row.names))) 
body:                 stop("row names contain missing values")
body:             if (anyDuplicated(row.names)) 
body:                 stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:         }
body:         else row.names <- integer()
body:         return(structure(list(), names = character(), row.names = row.names, class = "data.frame"))
body:     }
body:     vnames <- names(x)
body:     if (length(vnames) != n) 
body:         vnames <- character(n)
body:     no.vn <- !nzchar(vnames)
body:     vlist <- vnames <- as.list(vnames)
body:     nrows <- ncols <- integer(n)
body:     for (i in seq_len(n)) {
body:         xi <- if (is.character(x[[i]]) || is.list(x[[i]])) 
body:             as.data.frame(x[[i]], optional = TRUE, stringsAsFactors = stringsAsFactors)
body:         else as.data.frame(x[[i]], optional = TRUE)
body:         nrows[i] <- .row_names_info(xi)
body:         ncols[i] <- length(xi)
body:         namesi <- names(xi)
body:         if (ncols[i] > 1L) {
body:             if (length(namesi) == 0L) 
body:                 namesi <- seq_len(ncols[i])
body:             if (no.vn[i]) 
body:                 vnames[[i]] <- namesi
body:             else vnames[[i]] <- paste(vnames[[i]], namesi, sep = ".")
body:         }
body:         else {
body:             if (length(namesi)) 
body:                 vnames[[i]] <- namesi
body:             else if (no.vn[[i]]) {
body:                 tmpname <- deparse(object[[i]])[1L]
body:                 if (substr(tmpname, 1L, 2L) == "I(") {
body:                   ntmpn <- nchar(tmpname, "c")
body:                   if (substr(tmpname, ntmpn, ntmpn) == ")") 
body:                     tmpname <- substr(tmpname, 3L, ntmpn - 1L)
body:                 }
body:                 vnames[[i]] <- tmpname
body:             }
body:         }
body:         if (mirn && nrows[i] > 0L) {
body:             rowsi <- attr(xi, "row.names")
body:             nc <- nchar(rowsi, allowNA = FALSE)
body:             nc <- nc[!is.na(nc)]
body:             if (length(nc) && any(nc)) 
body:                 row.names <- data.row.names(row.names, rowsi, i)
body:         }
body:         nrows[i] <- abs(nrows[i])
body:         vlist[[i]] <- xi
body:     }
body:     nr <- max(nrows)
body:     for (i in seq_len(n)[nrows < nr]) {
body:         xi <- vlist[[i]]
body:         if (nrows[i] > 0L && (nr%%nrows[i] == 0L)) {
body:             xi <- unclass(xi)
body:             fixed <- TRUE
body:             for (j in seq_along(xi)) {
body:                 xi1 <- xi[[j]]
body:                 if (is.vector(xi1) || is.factor(xi1)) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else if (is.character(xi1) && inherits(xi1, "AsIs")) 
body:                   xi[[j]] <- structure(rep(xi1, length.out = nr), class = class(xi1))
body:                 else if (inherits(xi1, "Date") || inherits(xi1, "POSIXct")) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else {
body:                   fixed <- FALSE
body:                   break
body:                 }
body:             }
body:             if (fixed) {
body:                 vlist[[i]] <- xi
body:                 next
body:             }
body:         }
body:         stop(gettextf("arguments imply differing number of rows: %s", paste(unique(nrows), collapse = ", ")), domain = NA)
body:     }
body:     value <- unlist(vlist, recursive = FALSE, use.names = FALSE)
body:     vnames <- unlist(vnames[ncols > 0L])
body:     noname <- !nzchar(vnames)
body:     if (any(noname)) 
body:         vnames[noname] <- paste("Var", seq_along(vnames), sep = ".")[noname]
body:     if (check.names) 
body:         vnames <- make.names(vnames, unique = TRUE)
body:     names(value) <- vnames
body:     if (!mrn) {
body:         if (length(row.names) == 1L && nr != 1L) {
body:             if (is.character(row.names)) 
body:                 row.names <- match(row.names, vnames, 0L)
body:             if (length(row.names) != 1L || row.names < 1L || row.names > length(vnames)) 
body:                 stop("'row.names' should specify one of the variables")
body:             i <- row.names
body:             row.names <- value[[i]]
body:             value <- value[-i]
body:         }
body:         else if (!is.null(row.names) && length(row.names) != nr) 
body:             stop("row names supplied are of the wrong length")
body:     }
body:     else if (!is.null(row.names) && length(row.names) != nr) {
body:         warning("row names were found from a short variable and have been discarded")
body:         row.names <- NULL
body:     }
body:     if (is.null(row.names)) 
body:         row.names <- .set_row_names(nr)
body:     else {
body:         if (is.object(row.names) || !is.integer(row.names)) 
body:             row.names <- as.character(row.names)
body:         if (any(is.na(row.names))) 
body:             stop("row names contain missing values")
body:         if (anyDuplicated(row.names)) 
body:             stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:     }
body:     attr(value, "row.names") <- row.names
body:     attr(value, "class") <- "data.frame"
body:     value
body: }
args: list(Filename = structure(c("/home/roman/r-instrumented/library/utils/libs/utils.so", "/home/roman/r-instrumented/library/methods/libs/methods.so", "/home/roman/r-instrumented/library/grDevices/libs/grDevices.so", "/home/roman/r-instrumented/library/graphics/libs/graphics.so", "/home/roman/r-instrumented/library/stats/libs/stats.so"), class = "AsIs"), Dynamic.Lookup = structure(c("FALSE", "FALSE", "FALSE", "FALSE", "FALSE"), class = "AsIs"), check.names = FALSE, row.names = c("1", "2", "3", "4", 
args: "5"))
retn: structure(list(Filename = structure(c("/home/roman/r-instrumented/library/utils/libs/utils.so", "/home/roman/r-instrumented/library/methods/libs/methods.so", "/home/roman/r-instrumented/library/grDevices/libs/grDevices.so", "/home/roman/r-instrumented/library/graphics/libs/graphics.so", "/home/roman/r-instrumented/library/stats/libs/stats.so"), class = "AsIs"), Dynamic.Lookup = structure(c("FALSE", "FALSE", "FALSE", "FALSE", "FALSE"), class = "AsIs")), .Names = c("Filename", "Dynamic.Lookup"), row.names = c("1", 
retn: "2", "3", "4", "5"), class = "data.frame")

func: quote(data.frame)
body: function (..., row.names = NULL, check.rows = FALSE, check.names = TRUE, stringsAsFactors = default.stringsAsFactors()) 
body: {
body:     data.row.names <- if (check.rows && is.null(row.names)) 
body:         function(current, new, i) {
body:             if (is.character(current)) 
body:                 new <- as.character(new)
body:             if (is.character(new)) 
body:                 current <- as.character(current)
body:             if (anyDuplicated(new)) 
body:                 return(current)
body:             if (is.null(current)) 
body:                 return(new)
body:             if (all(current == new) || all(current == "")) 
body:                 return(new)
body:             stop(gettextf("mismatch of row names in arguments of 'data.frame', item %d", i), domain = NA)
body:         }
body:     else function(current, new, i) {
body:         if (is.null(current)) {
body:             if (anyDuplicated(new)) {
body:                 warning(gettextf("some row.names duplicated: %s --> row.names NOT used", paste(which(duplicated(new)), collapse = ",")), domain = NA)
body:                 current
body:             }
body:             else new
body:         }
body:         else current
body:     }
body:     object <- as.list(substitute(list(...)))[-1L]
body:     mirn <- missing(row.names)
body:     mrn <- is.null(row.names)
body:     x <- list(...)
body:     n <- length(x)
body:     if (n < 1L) {
body:         if (!mrn) {
body:             if (is.object(row.names) || !is.integer(row.names)) 
body:                 row.names <- as.character(row.names)
body:             if (any(is.na(row.names))) 
body:                 stop("row names contain missing values")
body:             if (anyDuplicated(row.names)) 
body:                 stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:         }
body:         else row.names <- integer()
body:         return(structure(list(), names = character(), row.names = row.names, class = "data.frame"))
body:     }
body:     vnames <- names(x)
body:     if (length(vnames) != n) 
body:         vnames <- character(n)
body:     no.vn <- !nzchar(vnames)
body:     vlist <- vnames <- as.list(vnames)
body:     nrows <- ncols <- integer(n)
body:     for (i in seq_len(n)) {
body:         xi <- if (is.character(x[[i]]) || is.list(x[[i]])) 
body:             as.data.frame(x[[i]], optional = TRUE, stringsAsFactors = stringsAsFactors)
body:         else as.data.frame(x[[i]], optional = TRUE)
body:         nrows[i] <- .row_names_info(xi)
body:         ncols[i] <- length(xi)
body:         namesi <- names(xi)
body:         if (ncols[i] > 1L) {
body:             if (length(namesi) == 0L) 
body:                 namesi <- seq_len(ncols[i])
body:             if (no.vn[i]) 
body:                 vnames[[i]] <- namesi
body:             else vnames[[i]] <- paste(vnames[[i]], namesi, sep = ".")
body:         }
body:         else {
body:             if (length(namesi)) 
body:                 vnames[[i]] <- namesi
body:             else if (no.vn[[i]]) {
body:                 tmpname <- deparse(object[[i]])[1L]
body:                 if (substr(tmpname, 1L, 2L) == "I(") {
body:                   ntmpn <- nchar(tmpname, "c")
body:                   if (substr(tmpname, ntmpn, ntmpn) == ")") 
body:                     tmpname <- substr(tmpname, 3L, ntmpn - 1L)
body:                 }
body:                 vnames[[i]] <- tmpname
body:             }
body:         }
body:         if (mirn && nrows[i] > 0L) {
body:             rowsi <- attr(xi, "row.names")
body:             nc <- nchar(rowsi, allowNA = FALSE)
body:             nc <- nc[!is.na(nc)]
body:             if (length(nc) && any(nc)) 
body:                 row.names <- data.row.names(row.names, rowsi, i)
body:         }
body:         nrows[i] <- abs(nrows[i])
body:         vlist[[i]] <- xi
body:     }
body:     nr <- max(nrows)
body:     for (i in seq_len(n)[nrows < nr]) {
body:         xi <- vlist[[i]]
body:         if (nrows[i] > 0L && (nr%%nrows[i] == 0L)) {
body:             xi <- unclass(xi)
body:             fixed <- TRUE
body:             for (j in seq_along(xi)) {
body:                 xi1 <- xi[[j]]
body:                 if (is.vector(xi1) || is.factor(xi1)) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else if (is.character(xi1) && inherits(xi1, "AsIs")) 
body:                   xi[[j]] <- structure(rep(xi1, length.out = nr), class = class(xi1))
body:                 else if (inherits(xi1, "Date") || inherits(xi1, "POSIXct")) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else {
body:                   fixed <- FALSE
body:                   break
body:                 }
body:             }
body:             if (fixed) {
body:                 vlist[[i]] <- xi
body:                 next
body:             }
body:         }
body:         stop(gettextf("arguments imply differing number of rows: %s", paste(unique(nrows), collapse = ", ")), domain = NA)
body:     }
body:     value <- unlist(vlist, recursive = FALSE, use.names = FALSE)
body:     vnames <- unlist(vnames[ncols > 0L])
body:     noname <- !nzchar(vnames)
body:     if (any(noname)) 
body:         vnames[noname] <- paste("Var", seq_along(vnames), sep = ".")[noname]
body:     if (check.names) 
body:         vnames <- make.names(vnames, unique = TRUE)
body:     names(value) <- vnames
body:     if (!mrn) {
body:         if (length(row.names) == 1L && nr != 1L) {
body:             if (is.character(row.names)) 
body:                 row.names <- match(row.names, vnames, 0L)
body:             if (length(row.names) != 1L || row.names < 1L || row.names > length(vnames)) 
body:                 stop("'row.names' should specify one of the variables")
body:             i <- row.names
body:             row.names <- value[[i]]
body:             value <- value[-i]
body:         }
body:         else if (!is.null(row.names) && length(row.names) != nr) 
body:             stop("row names supplied are of the wrong length")
body:     }
body:     else if (!is.null(row.names) && length(row.names) != nr) {
body:         warning("row names were found from a short variable and have been discarded")
body:         row.names <- NULL
body:     }
body:     if (is.null(row.names)) 
body:         row.names <- .set_row_names(nr)
body:     else {
body:         if (is.object(row.names) || !is.integer(row.names)) 
body:             row.names <- as.character(row.names)
body:         if (any(is.na(row.names))) 
body:             stop("row names contain missing values")
body:         if (anyDuplicated(row.names)) 
body:             stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:     }
body:     attr(value, "row.names") <- row.names
body:     attr(value, "class") <- "data.frame"
body:     value
body: }
args: list(x = structure("FALSE", class = "AsIs"), y = structure("FALSE", class = "AsIs"), check.names = FALSE, row.names = "1")
retn: structure(list(x = structure("FALSE", class = "AsIs"), y = structure("FALSE", class = "AsIs")), .Names = c("x", "y"), row.names = "1", class = "data.frame")

func: quote(data.frame)
body: function (..., row.names = NULL, check.rows = FALSE, check.names = TRUE, stringsAsFactors = default.stringsAsFactors()) 
body: {
body:     data.row.names <- if (check.rows && is.null(row.names)) 
body:         function(current, new, i) {
body:             if (is.character(current)) 
body:                 new <- as.character(new)
body:             if (is.character(new)) 
body:                 current <- as.character(current)
body:             if (anyDuplicated(new)) 
body:                 return(current)
body:             if (is.null(current)) 
body:                 return(new)
body:             if (all(current == new) || all(current == "")) 
body:                 return(new)
body:             stop(gettextf("mismatch of row names in arguments of 'data.frame', item %d", i), domain = NA)
body:         }
body:     else function(current, new, i) {
body:         if (is.null(current)) {
body:             if (anyDuplicated(new)) {
body:                 warning(gettextf("some row.names duplicated: %s --> row.names NOT used", paste(which(duplicated(new)), collapse = ",")), domain = NA)
body:                 current
body:             }
body:             else new
body:         }
body:         else current
body:     }
body:     object <- as.list(substitute(list(...)))[-1L]
body:     mirn <- missing(row.names)
body:     mrn <- is.null(row.names)
body:     x <- list(...)
body:     n <- length(x)
body:     if (n < 1L) {
body:         if (!mrn) {
body:             if (is.object(row.names) || !is.integer(row.names)) 
body:                 row.names <- as.character(row.names)
body:             if (any(is.na(row.names))) 
body:                 stop("row names contain missing values")
body:             if (anyDuplicated(row.names)) 
body:                 stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:         }
body:         else row.names <- integer()
body:         return(structure(list(), names = character(), row.names = row.names, class = "data.frame"))
body:     }
body:     vnames <- names(x)
body:     if (length(vnames) != n) 
body:         vnames <- character(n)
body:     no.vn <- !nzchar(vnames)
body:     vlist <- vnames <- as.list(vnames)
body:     nrows <- ncols <- integer(n)
body:     for (i in seq_len(n)) {
body:         xi <- if (is.character(x[[i]]) || is.list(x[[i]])) 
body:             as.data.frame(x[[i]], optional = TRUE, stringsAsFactors = stringsAsFactors)
body:         else as.data.frame(x[[i]], optional = TRUE)
body:         nrows[i] <- .row_names_info(xi)
body:         ncols[i] <- length(xi)
body:         namesi <- names(xi)
body:         if (ncols[i] > 1L) {
body:             if (length(namesi) == 0L) 
body:                 namesi <- seq_len(ncols[i])
body:             if (no.vn[i]) 
body:                 vnames[[i]] <- namesi
body:             else vnames[[i]] <- paste(vnames[[i]], namesi, sep = ".")
body:         }
body:         else {
body:             if (length(namesi)) 
body:                 vnames[[i]] <- namesi
body:             else if (no.vn[[i]]) {
body:                 tmpname <- deparse(object[[i]])[1L]
body:                 if (substr(tmpname, 1L, 2L) == "I(") {
body:                   ntmpn <- nchar(tmpname, "c")
body:                   if (substr(tmpname, ntmpn, ntmpn) == ")") 
body:                     tmpname <- substr(tmpname, 3L, ntmpn - 1L)
body:                 }
body:                 vnames[[i]] <- tmpname
body:             }
body:         }
body:         if (mirn && nrows[i] > 0L) {
body:             rowsi <- attr(xi, "row.names")
body:             nc <- nchar(rowsi, allowNA = FALSE)
body:             nc <- nc[!is.na(nc)]
body:             if (length(nc) && any(nc)) 
body:                 row.names <- data.row.names(row.names, rowsi, i)
body:         }
body:         nrows[i] <- abs(nrows[i])
body:         vlist[[i]] <- xi
body:     }
body:     nr <- max(nrows)
body:     for (i in seq_len(n)[nrows < nr]) {
body:         xi <- vlist[[i]]
body:         if (nrows[i] > 0L && (nr%%nrows[i] == 0L)) {
body:             xi <- unclass(xi)
body:             fixed <- TRUE
body:             for (j in seq_along(xi)) {
body:                 xi1 <- xi[[j]]
body:                 if (is.vector(xi1) || is.factor(xi1)) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else if (is.character(xi1) && inherits(xi1, "AsIs")) 
body:                   xi[[j]] <- structure(rep(xi1, length.out = nr), class = class(xi1))
body:                 else if (inherits(xi1, "Date") || inherits(xi1, "POSIXct")) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else {
body:                   fixed <- FALSE
body:                   break
body:                 }
body:             }
body:             if (fixed) {
body:                 vlist[[i]] <- xi
body:                 next
body:             }
body:         }
body:         stop(gettextf("arguments imply differing number of rows: %s", paste(unique(nrows), collapse = ", ")), domain = NA)
body:     }
body:     value <- unlist(vlist, recursive = FALSE, use.names = FALSE)
body:     vnames <- unlist(vnames[ncols > 0L])
body:     noname <- !nzchar(vnames)
body:     if (any(noname)) 
body:         vnames[noname] <- paste("Var", seq_along(vnames), sep = ".")[noname]
body:     if (check.names) 
body:         vnames <- make.names(vnames, unique = TRUE)
body:     names(value) <- vnames
body:     if (!mrn) {
body:         if (length(row.names) == 1L && nr != 1L) {
body:             if (is.character(row.names)) 
body:                 row.names <- match(row.names, vnames, 0L)
body:             if (length(row.names) != 1L || row.names < 1L || row.names > length(vnames)) 
body:                 stop("'row.names' should specify one of the variables")
body:             i <- row.names
body:             row.names <- value[[i]]
body:             value <- value[-i]
body:         }
body:         else if (!is.null(row.names) && length(row.names) != nr) 
body:             stop("row names supplied are of the wrong length")
body:     }
body:     else if (!is.null(row.names) && length(row.names) != nr) {
body:         warning("row names were found from a short variable and have been discarded")
body:         row.names <- NULL
body:     }
body:     if (is.null(row.names)) 
body:         row.names <- .set_row_names(nr)
body:     else {
body:         if (is.object(row.names) || !is.integer(row.names)) 
body:             row.names <- as.character(row.names)
body:         if (any(is.na(row.names))) 
body:             stop("row names contain missing values")
body:         if (anyDuplicated(row.names)) 
body:             stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:     }
body:     attr(value, "row.names") <- row.names
body:     attr(value, "class") <- "data.frame"
body:     value
body: }
args: list(NULL, NULL, NULL, check.names = TRUE, stringsAsFactors = TRUE)
retn: structure(list(), .Names = character(0), row.names = integer(0), class = "data.frame")

func: quote(data.frame)
body: function (..., row.names = NULL, check.rows = FALSE, check.names = TRUE, stringsAsFactors = default.stringsAsFactors()) 
body: {
body:     data.row.names <- if (check.rows && is.null(row.names)) 
body:         function(current, new, i) {
body:             if (is.character(current)) 
body:                 new <- as.character(new)
body:             if (is.character(new)) 
body:                 current <- as.character(current)
body:             if (anyDuplicated(new)) 
body:                 return(current)
body:             if (is.null(current)) 
body:                 return(new)
body:             if (all(current == new) || all(current == "")) 
body:                 return(new)
body:             stop(gettextf("mismatch of row names in arguments of 'data.frame', item %d", i), domain = NA)
body:         }
body:     else function(current, new, i) {
body:         if (is.null(current)) {
body:             if (anyDuplicated(new)) {
body:                 warning(gettextf("some row.names duplicated: %s --> row.names NOT used", paste(which(duplicated(new)), collapse = ",")), domain = NA)
body:                 current
body:             }
body:             else new
body:         }
body:         else current
body:     }
body:     object <- as.list(substitute(list(...)))[-1L]
body:     mirn <- missing(row.names)
body:     mrn <- is.null(row.names)
body:     x <- list(...)
body:     n <- length(x)
body:     if (n < 1L) {
body:         if (!mrn) {
body:             if (is.object(row.names) || !is.integer(row.names)) 
body:                 row.names <- as.character(row.names)
body:             if (any(is.na(row.names))) 
body:                 stop("row names contain missing values")
body:             if (anyDuplicated(row.names)) 
body:                 stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:         }
body:         else row.names <- integer()
body:         return(structure(list(), names = character(), row.names = row.names, class = "data.frame"))
body:     }
body:     vnames <- names(x)
body:     if (length(vnames) != n) 
body:         vnames <- character(n)
body:     no.vn <- !nzchar(vnames)
body:     vlist <- vnames <- as.list(vnames)
body:     nrows <- ncols <- integer(n)
body:     for (i in seq_len(n)) {
body:         xi <- if (is.character(x[[i]]) || is.list(x[[i]])) 
body:             as.data.frame(x[[i]], optional = TRUE, stringsAsFactors = stringsAsFactors)
body:         else as.data.frame(x[[i]], optional = TRUE)
body:         nrows[i] <- .row_names_info(xi)
body:         ncols[i] <- length(xi)
body:         namesi <- names(xi)
body:         if (ncols[i] > 1L) {
body:             if (length(namesi) == 0L) 
body:                 namesi <- seq_len(ncols[i])
body:             if (no.vn[i]) 
body:                 vnames[[i]] <- namesi
body:             else vnames[[i]] <- paste(vnames[[i]], namesi, sep = ".")
body:         }
body:         else {
body:             if (length(namesi)) 
body:                 vnames[[i]] <- namesi
body:             else if (no.vn[[i]]) {
body:                 tmpname <- deparse(object[[i]])[1L]
body:                 if (substr(tmpname, 1L, 2L) == "I(") {
body:                   ntmpn <- nchar(tmpname, "c")
body:                   if (substr(tmpname, ntmpn, ntmpn) == ")") 
body:                     tmpname <- substr(tmpname, 3L, ntmpn - 1L)
body:                 }
body:                 vnames[[i]] <- tmpname
body:             }
body:         }
body:         if (mirn && nrows[i] > 0L) {
body:             rowsi <- attr(xi, "row.names")
body:             nc <- nchar(rowsi, allowNA = FALSE)
body:             nc <- nc[!is.na(nc)]
body:             if (length(nc) && any(nc)) 
body:                 row.names <- data.row.names(row.names, rowsi, i)
body:         }
body:         nrows[i] <- abs(nrows[i])
body:         vlist[[i]] <- xi
body:     }
body:     nr <- max(nrows)
body:     for (i in seq_len(n)[nrows < nr]) {
body:         xi <- vlist[[i]]
body:         if (nrows[i] > 0L && (nr%%nrows[i] == 0L)) {
body:             xi <- unclass(xi)
body:             fixed <- TRUE
body:             for (j in seq_along(xi)) {
body:                 xi1 <- xi[[j]]
body:                 if (is.vector(xi1) || is.factor(xi1)) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else if (is.character(xi1) && inherits(xi1, "AsIs")) 
body:                   xi[[j]] <- structure(rep(xi1, length.out = nr), class = class(xi1))
body:                 else if (inherits(xi1, "Date") || inherits(xi1, "POSIXct")) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else {
body:                   fixed <- FALSE
body:                   break
body:                 }
body:             }
body:             if (fixed) {
body:                 vlist[[i]] <- xi
body:                 next
body:             }
body:         }
body:         stop(gettextf("arguments imply differing number of rows: %s", paste(unique(nrows), collapse = ", ")), domain = NA)
body:     }
body:     value <- unlist(vlist, recursive = FALSE, use.names = FALSE)
body:     vnames <- unlist(vnames[ncols > 0L])
body:     noname <- !nzchar(vnames)
body:     if (any(noname)) 
body:         vnames[noname] <- paste("Var", seq_along(vnames), sep = ".")[noname]
body:     if (check.names) 
body:         vnames <- make.names(vnames, unique = TRUE)
body:     names(value) <- vnames
body:     if (!mrn) {
body:         if (length(row.names) == 1L && nr != 1L) {
body:             if (is.character(row.names)) 
body:                 row.names <- match(row.names, vnames, 0L)
body:             if (length(row.names) != 1L || row.names < 1L || row.names > length(vnames)) 
body:                 stop("'row.names' should specify one of the variables")
body:             i <- row.names
body:             row.names <- value[[i]]
body:             value <- value[-i]
body:         }
body:         else if (!is.null(row.names) && length(row.names) != nr) 
body:             stop("row names supplied are of the wrong length")
body:     }
body:     else if (!is.null(row.names) && length(row.names) != nr) {
body:         warning("row names were found from a short variable and have been discarded")
body:         row.names <- NULL
body:     }
body:     if (is.null(row.names)) 
body:         row.names <- .set_row_names(nr)
body:     else {
body:         if (is.object(row.names) || !is.integer(row.names)) 
body:             row.names <- as.character(row.names)
body:         if (any(is.na(row.names))) 
body:             stop("row names contain missing values")
body:         if (anyDuplicated(row.names)) 
body:             stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:     }
body:     attr(value, "row.names") <- row.names
body:     attr(value, "class") <- "data.frame"
body:     value
body: }
args: list(NA, NA, NA, check.names = TRUE, stringsAsFactors = TRUE)
retn: structure(list(NA. = NA, NA..1 = NA, NA..2 = NA), .Names = c("NA.", "NA..1", "NA..2"), row.names = c(NA, -1L), class = "data.frame")

func: quote(data.frame)
body: function (..., row.names = NULL, check.rows = FALSE, check.names = TRUE, stringsAsFactors = default.stringsAsFactors()) 
body: {
body:     data.row.names <- if (check.rows && is.null(row.names)) 
body:         function(current, new, i) {
body:             if (is.character(current)) 
body:                 new <- as.character(new)
body:             if (is.character(new)) 
body:                 current <- as.character(current)
body:             if (anyDuplicated(new)) 
body:                 return(current)
body:             if (is.null(current)) 
body:                 return(new)
body:             if (all(current == new) || all(current == "")) 
body:                 return(new)
body:             stop(gettextf("mismatch of row names in arguments of 'data.frame', item %d", i), domain = NA)
body:         }
body:     else function(current, new, i) {
body:         if (is.null(current)) {
body:             if (anyDuplicated(new)) {
body:                 warning(gettextf("some row.names duplicated: %s --> row.names NOT used", paste(which(duplicated(new)), collapse = ",")), domain = NA)
body:                 current
body:             }
body:             else new
body:         }
body:         else current
body:     }
body:     object <- as.list(substitute(list(...)))[-1L]
body:     mirn <- missing(row.names)
body:     mrn <- is.null(row.names)
body:     x <- list(...)
body:     n <- length(x)
body:     if (n < 1L) {
body:         if (!mrn) {
body:             if (is.object(row.names) || !is.integer(row.names)) 
body:                 row.names <- as.character(row.names)
body:             if (any(is.na(row.names))) 
body:                 stop("row names contain missing values")
body:             if (anyDuplicated(row.names)) 
body:                 stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:         }
body:         else row.names <- integer()
body:         return(structure(list(), names = character(), row.names = row.names, class = "data.frame"))
body:     }
body:     vnames <- names(x)
body:     if (length(vnames) != n) 
body:         vnames <- character(n)
body:     no.vn <- !nzchar(vnames)
body:     vlist <- vnames <- as.list(vnames)
body:     nrows <- ncols <- integer(n)
body:     for (i in seq_len(n)) {
body:         xi <- if (is.character(x[[i]]) || is.list(x[[i]])) 
body:             as.data.frame(x[[i]], optional = TRUE, stringsAsFactors = stringsAsFactors)
body:         else as.data.frame(x[[i]], optional = TRUE)
body:         nrows[i] <- .row_names_info(xi)
body:         ncols[i] <- length(xi)
body:         namesi <- names(xi)
body:         if (ncols[i] > 1L) {
body:             if (length(namesi) == 0L) 
body:                 namesi <- seq_len(ncols[i])
body:             if (no.vn[i]) 
body:                 vnames[[i]] <- namesi
body:             else vnames[[i]] <- paste(vnames[[i]], namesi, sep = ".")
body:         }
body:         else {
body:             if (length(namesi)) 
body:                 vnames[[i]] <- namesi
body:             else if (no.vn[[i]]) {
body:                 tmpname <- deparse(object[[i]])[1L]
body:                 if (substr(tmpname, 1L, 2L) == "I(") {
body:                   ntmpn <- nchar(tmpname, "c")
body:                   if (substr(tmpname, ntmpn, ntmpn) == ")") 
body:                     tmpname <- substr(tmpname, 3L, ntmpn - 1L)
body:                 }
body:                 vnames[[i]] <- tmpname
body:             }
body:         }
body:         if (mirn && nrows[i] > 0L) {
body:             rowsi <- attr(xi, "row.names")
body:             nc <- nchar(rowsi, allowNA = FALSE)
body:             nc <- nc[!is.na(nc)]
body:             if (length(nc) && any(nc)) 
body:                 row.names <- data.row.names(row.names, rowsi, i)
body:         }
body:         nrows[i] <- abs(nrows[i])
body:         vlist[[i]] <- xi
body:     }
body:     nr <- max(nrows)
body:     for (i in seq_len(n)[nrows < nr]) {
body:         xi <- vlist[[i]]
body:         if (nrows[i] > 0L && (nr%%nrows[i] == 0L)) {
body:             xi <- unclass(xi)
body:             fixed <- TRUE
body:             for (j in seq_along(xi)) {
body:                 xi1 <- xi[[j]]
body:                 if (is.vector(xi1) || is.factor(xi1)) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else if (is.character(xi1) && inherits(xi1, "AsIs")) 
body:                   xi[[j]] <- structure(rep(xi1, length.out = nr), class = class(xi1))
body:                 else if (inherits(xi1, "Date") || inherits(xi1, "POSIXct")) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else {
body:                   fixed <- FALSE
body:                   break
body:                 }
body:             }
body:             if (fixed) {
body:                 vlist[[i]] <- xi
body:                 next
body:             }
body:         }
body:         stop(gettextf("arguments imply differing number of rows: %s", paste(unique(nrows), collapse = ", ")), domain = NA)
body:     }
body:     value <- unlist(vlist, recursive = FALSE, use.names = FALSE)
body:     vnames <- unlist(vnames[ncols > 0L])
body:     noname <- !nzchar(vnames)
body:     if (any(noname)) 
body:         vnames[noname] <- paste("Var", seq_along(vnames), sep = ".")[noname]
body:     if (check.names) 
body:         vnames <- make.names(vnames, unique = TRUE)
body:     names(value) <- vnames
body:     if (!mrn) {
body:         if (length(row.names) == 1L && nr != 1L) {
body:             if (is.character(row.names)) 
body:                 row.names <- match(row.names, vnames, 0L)
body:             if (length(row.names) != 1L || row.names < 1L || row.names > length(vnames)) 
body:                 stop("'row.names' should specify one of the variables")
body:             i <- row.names
body:             row.names <- value[[i]]
body:             value <- value[-i]
body:         }
body:         else if (!is.null(row.names) && length(row.names) != nr) 
body:             stop("row names supplied are of the wrong length")
body:     }
body:     else if (!is.null(row.names) && length(row.names) != nr) {
body:         warning("row names were found from a short variable and have been discarded")
body:         row.names <- NULL
body:     }
body:     if (is.null(row.names)) 
body:         row.names <- .set_row_names(nr)
body:     else {
body:         if (is.object(row.names) || !is.integer(row.names)) 
body:             row.names <- as.character(row.names)
body:         if (any(is.na(row.names))) 
body:             stop("row names contain missing values")
body:         if (anyDuplicated(row.names)) 
body:             stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:     }
body:     attr(value, "row.names") <- row.names
body:     attr(value, "class") <- "data.frame"
body:     value
body: }
args: list(c(FALSE, FALSE), check.names = TRUE, stringsAsFactors = TRUE)
retn: structure(list(c.FALSE..FALSE. = c(FALSE, FALSE)), .Names = "c.FALSE..FALSE.", row.names = c(NA, -2L), class = "data.frame")

func: quote(data.frame)
body: function (..., row.names = NULL, check.rows = FALSE, check.names = TRUE, stringsAsFactors = default.stringsAsFactors()) 
body: {
body:     data.row.names <- if (check.rows && is.null(row.names)) 
body:         function(current, new, i) {
body:             if (is.character(current)) 
body:                 new <- as.character(new)
body:             if (is.character(new)) 
body:                 current <- as.character(current)
body:             if (anyDuplicated(new)) 
body:                 return(current)
body:             if (is.null(current)) 
body:                 return(new)
body:             if (all(current == new) || all(current == "")) 
body:                 return(new)
body:             stop(gettextf("mismatch of row names in arguments of 'data.frame', item %d", i), domain = NA)
body:         }
body:     else function(current, new, i) {
body:         if (is.null(current)) {
body:             if (anyDuplicated(new)) {
body:                 warning(gettextf("some row.names duplicated: %s --> row.names NOT used", paste(which(duplicated(new)), collapse = ",")), domain = NA)
body:                 current
body:             }
body:             else new
body:         }
body:         else current
body:     }
body:     object <- as.list(substitute(list(...)))[-1L]
body:     mirn <- missing(row.names)
body:     mrn <- is.null(row.names)
body:     x <- list(...)
body:     n <- length(x)
body:     if (n < 1L) {
body:         if (!mrn) {
body:             if (is.object(row.names) || !is.integer(row.names)) 
body:                 row.names <- as.character(row.names)
body:             if (any(is.na(row.names))) 
body:                 stop("row names contain missing values")
body:             if (anyDuplicated(row.names)) 
body:                 stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:         }
body:         else row.names <- integer()
body:         return(structure(list(), names = character(), row.names = row.names, class = "data.frame"))
body:     }
body:     vnames <- names(x)
body:     if (length(vnames) != n) 
body:         vnames <- character(n)
body:     no.vn <- !nzchar(vnames)
body:     vlist <- vnames <- as.list(vnames)
body:     nrows <- ncols <- integer(n)
body:     for (i in seq_len(n)) {
body:         xi <- if (is.character(x[[i]]) || is.list(x[[i]])) 
body:             as.data.frame(x[[i]], optional = TRUE, stringsAsFactors = stringsAsFactors)
body:         else as.data.frame(x[[i]], optional = TRUE)
body:         nrows[i] <- .row_names_info(xi)
body:         ncols[i] <- length(xi)
body:         namesi <- names(xi)
body:         if (ncols[i] > 1L) {
body:             if (length(namesi) == 0L) 
body:                 namesi <- seq_len(ncols[i])
body:             if (no.vn[i]) 
body:                 vnames[[i]] <- namesi
body:             else vnames[[i]] <- paste(vnames[[i]], namesi, sep = ".")
body:         }
body:         else {
body:             if (length(namesi)) 
body:                 vnames[[i]] <- namesi
body:             else if (no.vn[[i]]) {
body:                 tmpname <- deparse(object[[i]])[1L]
body:                 if (substr(tmpname, 1L, 2L) == "I(") {
body:                   ntmpn <- nchar(tmpname, "c")
body:                   if (substr(tmpname, ntmpn, ntmpn) == ")") 
body:                     tmpname <- substr(tmpname, 3L, ntmpn - 1L)
body:                 }
body:                 vnames[[i]] <- tmpname
body:             }
body:         }
body:         if (mirn && nrows[i] > 0L) {
body:             rowsi <- attr(xi, "row.names")
body:             nc <- nchar(rowsi, allowNA = FALSE)
body:             nc <- nc[!is.na(nc)]
body:             if (length(nc) && any(nc)) 
body:                 row.names <- data.row.names(row.names, rowsi, i)
body:         }
body:         nrows[i] <- abs(nrows[i])
body:         vlist[[i]] <- xi
body:     }
body:     nr <- max(nrows)
body:     for (i in seq_len(n)[nrows < nr]) {
body:         xi <- vlist[[i]]
body:         if (nrows[i] > 0L && (nr%%nrows[i] == 0L)) {
body:             xi <- unclass(xi)
body:             fixed <- TRUE
body:             for (j in seq_along(xi)) {
body:                 xi1 <- xi[[j]]
body:                 if (is.vector(xi1) || is.factor(xi1)) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else if (is.character(xi1) && inherits(xi1, "AsIs")) 
body:                   xi[[j]] <- structure(rep(xi1, length.out = nr), class = class(xi1))
body:                 else if (inherits(xi1, "Date") || inherits(xi1, "POSIXct")) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else {
body:                   fixed <- FALSE
body:                   break
body:                 }
body:             }
body:             if (fixed) {
body:                 vlist[[i]] <- xi
body:                 next
body:             }
body:         }
body:         stop(gettextf("arguments imply differing number of rows: %s", paste(unique(nrows), collapse = ", ")), domain = NA)
body:     }
body:     value <- unlist(vlist, recursive = FALSE, use.names = FALSE)
body:     vnames <- unlist(vnames[ncols > 0L])
body:     noname <- !nzchar(vnames)
body:     if (any(noname)) 
body:         vnames[noname] <- paste("Var", seq_along(vnames), sep = ".")[noname]
body:     if (check.names) 
body:         vnames <- make.names(vnames, unique = TRUE)
body:     names(value) <- vnames
body:     if (!mrn) {
body:         if (length(row.names) == 1L && nr != 1L) {
body:             if (is.character(row.names)) 
body:                 row.names <- match(row.names, vnames, 0L)
body:             if (length(row.names) != 1L || row.names < 1L || row.names > length(vnames)) 
body:                 stop("'row.names' should specify one of the variables")
body:             i <- row.names
body:             row.names <- value[[i]]
body:             value <- value[-i]
body:         }
body:         else if (!is.null(row.names) && length(row.names) != nr) 
body:             stop("row names supplied are of the wrong length")
body:     }
body:     else if (!is.null(row.names) && length(row.names) != nr) {
body:         warning("row names were found from a short variable and have been discarded")
body:         row.names <- NULL
body:     }
body:     if (is.null(row.names)) 
body:         row.names <- .set_row_names(nr)
body:     else {
body:         if (is.object(row.names) || !is.integer(row.names)) 
body:             row.names <- as.character(row.names)
body:         if (any(is.na(row.names))) 
body:             stop("row names contain missing values")
body:         if (anyDuplicated(row.names)) 
body:             stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:     }
body:     attr(value, "row.names") <- row.names
body:     attr(value, "class") <- "data.frame"
body:     value
body: }
args: list(c.FALSE..FALSE. = structure(c("FALSE", "FALSE"), class = "AsIs"), check.names = FALSE, row.names = c("1", "2"))
retn: structure(list(c.FALSE..FALSE. = structure(c("FALSE", "FALSE"), class = "AsIs")), .Names = "c.FALSE..FALSE.", row.names = c("1", "2"), class = "data.frame")

func: quote(data.frame)
body: function (..., row.names = NULL, check.rows = FALSE, check.names = TRUE, stringsAsFactors = default.stringsAsFactors()) 
body: {
body:     data.row.names <- if (check.rows && is.null(row.names)) 
body:         function(current, new, i) {
body:             if (is.character(current)) 
body:                 new <- as.character(new)
body:             if (is.character(new)) 
body:                 current <- as.character(current)
body:             if (anyDuplicated(new)) 
body:                 return(current)
body:             if (is.null(current)) 
body:                 return(new)
body:             if (all(current == new) || all(current == "")) 
body:                 return(new)
body:             stop(gettextf("mismatch of row names in arguments of 'data.frame', item %d", i), domain = NA)
body:         }
body:     else function(current, new, i) {
body:         if (is.null(current)) {
body:             if (anyDuplicated(new)) {
body:                 warning(gettextf("some row.names duplicated: %s --> row.names NOT used", paste(which(duplicated(new)), collapse = ",")), domain = NA)
body:                 current
body:             }
body:             else new
body:         }
body:         else current
body:     }
body:     object <- as.list(substitute(list(...)))[-1L]
body:     mirn <- missing(row.names)
body:     mrn <- is.null(row.names)
body:     x <- list(...)
body:     n <- length(x)
body:     if (n < 1L) {
body:         if (!mrn) {
body:             if (is.object(row.names) || !is.integer(row.names)) 
body:                 row.names <- as.character(row.names)
body:             if (any(is.na(row.names))) 
body:                 stop("row names contain missing values")
body:             if (anyDuplicated(row.names)) 
body:                 stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:         }
body:         else row.names <- integer()
body:         return(structure(list(), names = character(), row.names = row.names, class = "data.frame"))
body:     }
body:     vnames <- names(x)
body:     if (length(vnames) != n) 
body:         vnames <- character(n)
body:     no.vn <- !nzchar(vnames)
body:     vlist <- vnames <- as.list(vnames)
body:     nrows <- ncols <- integer(n)
body:     for (i in seq_len(n)) {
body:         xi <- if (is.character(x[[i]]) || is.list(x[[i]])) 
body:             as.data.frame(x[[i]], optional = TRUE, stringsAsFactors = stringsAsFactors)
body:         else as.data.frame(x[[i]], optional = TRUE)
body:         nrows[i] <- .row_names_info(xi)
body:         ncols[i] <- length(xi)
body:         namesi <- names(xi)
body:         if (ncols[i] > 1L) {
body:             if (length(namesi) == 0L) 
body:                 namesi <- seq_len(ncols[i])
body:             if (no.vn[i]) 
body:                 vnames[[i]] <- namesi
body:             else vnames[[i]] <- paste(vnames[[i]], namesi, sep = ".")
body:         }
body:         else {
body:             if (length(namesi)) 
body:                 vnames[[i]] <- namesi
body:             else if (no.vn[[i]]) {
body:                 tmpname <- deparse(object[[i]])[1L]
body:                 if (substr(tmpname, 1L, 2L) == "I(") {
body:                   ntmpn <- nchar(tmpname, "c")
body:                   if (substr(tmpname, ntmpn, ntmpn) == ")") 
body:                     tmpname <- substr(tmpname, 3L, ntmpn - 1L)
body:                 }
body:                 vnames[[i]] <- tmpname
body:             }
body:         }
body:         if (mirn && nrows[i] > 0L) {
body:             rowsi <- attr(xi, "row.names")
body:             nc <- nchar(rowsi, allowNA = FALSE)
body:             nc <- nc[!is.na(nc)]
body:             if (length(nc) && any(nc)) 
body:                 row.names <- data.row.names(row.names, rowsi, i)
body:         }
body:         nrows[i] <- abs(nrows[i])
body:         vlist[[i]] <- xi
body:     }
body:     nr <- max(nrows)
body:     for (i in seq_len(n)[nrows < nr]) {
body:         xi <- vlist[[i]]
body:         if (nrows[i] > 0L && (nr%%nrows[i] == 0L)) {
body:             xi <- unclass(xi)
body:             fixed <- TRUE
body:             for (j in seq_along(xi)) {
body:                 xi1 <- xi[[j]]
body:                 if (is.vector(xi1) || is.factor(xi1)) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else if (is.character(xi1) && inherits(xi1, "AsIs")) 
body:                   xi[[j]] <- structure(rep(xi1, length.out = nr), class = class(xi1))
body:                 else if (inherits(xi1, "Date") || inherits(xi1, "POSIXct")) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else {
body:                   fixed <- FALSE
body:                   break
body:                 }
body:             }
body:             if (fixed) {
body:                 vlist[[i]] <- xi
body:                 next
body:             }
body:         }
body:         stop(gettextf("arguments imply differing number of rows: %s", paste(unique(nrows), collapse = ", ")), domain = NA)
body:     }
body:     value <- unlist(vlist, recursive = FALSE, use.names = FALSE)
body:     vnames <- unlist(vnames[ncols > 0L])
body:     noname <- !nzchar(vnames)
body:     if (any(noname)) 
body:         vnames[noname] <- paste("Var", seq_along(vnames), sep = ".")[noname]
body:     if (check.names) 
body:         vnames <- make.names(vnames, unique = TRUE)
body:     names(value) <- vnames
body:     if (!mrn) {
body:         if (length(row.names) == 1L && nr != 1L) {
body:             if (is.character(row.names)) 
body:                 row.names <- match(row.names, vnames, 0L)
body:             if (length(row.names) != 1L || row.names < 1L || row.names > length(vnames)) 
body:                 stop("'row.names' should specify one of the variables")
body:             i <- row.names
body:             row.names <- value[[i]]
body:             value <- value[-i]
body:         }
body:         else if (!is.null(row.names) && length(row.names) != nr) 
body:             stop("row names supplied are of the wrong length")
body:     }
body:     else if (!is.null(row.names) && length(row.names) != nr) {
body:         warning("row names were found from a short variable and have been discarded")
body:         row.names <- NULL
body:     }
body:     if (is.null(row.names)) 
body:         row.names <- .set_row_names(nr)
body:     else {
body:         if (is.object(row.names) || !is.integer(row.names)) 
body:             row.names <- as.character(row.names)
body:         if (any(is.na(row.names))) 
body:             stop("row names contain missing values")
body:         if (anyDuplicated(row.names)) 
body:             stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:     }
body:     attr(value, "row.names") <- row.names
body:     attr(value, "class") <- "data.frame"
body:     value
body: }
args: list(x = structure("FALSE", class = "AsIs"), check.names = FALSE, row.names = "FALSE")
retn: structure(list(x = structure("FALSE", class = "AsIs")), .Names = "x", row.names = "FALSE", class = "data.frame")

func: quote(data.frame)
body: function (..., row.names = NULL, check.rows = FALSE, check.names = TRUE, stringsAsFactors = default.stringsAsFactors()) 
body: {
body:     data.row.names <- if (check.rows && is.null(row.names)) 
body:         function(current, new, i) {
body:             if (is.character(current)) 
body:                 new <- as.character(new)
body:             if (is.character(new)) 
body:                 current <- as.character(current)
body:             if (anyDuplicated(new)) 
body:                 return(current)
body:             if (is.null(current)) 
body:                 return(new)
body:             if (all(current == new) || all(current == "")) 
body:                 return(new)
body:             stop(gettextf("mismatch of row names in arguments of 'data.frame', item %d", i), domain = NA)
body:         }
body:     else function(current, new, i) {
body:         if (is.null(current)) {
body:             if (anyDuplicated(new)) {
body:                 warning(gettextf("some row.names duplicated: %s --> row.names NOT used", paste(which(duplicated(new)), collapse = ",")), domain = NA)
body:                 current
body:             }
body:             else new
body:         }
body:         else current
body:     }
body:     object <- as.list(substitute(list(...)))[-1L]
body:     mirn <- missing(row.names)
body:     mrn <- is.null(row.names)
body:     x <- list(...)
body:     n <- length(x)
body:     if (n < 1L) {
body:         if (!mrn) {
body:             if (is.object(row.names) || !is.integer(row.names)) 
body:                 row.names <- as.character(row.names)
body:             if (any(is.na(row.names))) 
body:                 stop("row names contain missing values")
body:             if (anyDuplicated(row.names)) 
body:                 stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:         }
body:         else row.names <- integer()
body:         return(structure(list(), names = character(), row.names = row.names, class = "data.frame"))
body:     }
body:     vnames <- names(x)
body:     if (length(vnames) != n) 
body:         vnames <- character(n)
body:     no.vn <- !nzchar(vnames)
body:     vlist <- vnames <- as.list(vnames)
body:     nrows <- ncols <- integer(n)
body:     for (i in seq_len(n)) {
body:         xi <- if (is.character(x[[i]]) || is.list(x[[i]])) 
body:             as.data.frame(x[[i]], optional = TRUE, stringsAsFactors = stringsAsFactors)
body:         else as.data.frame(x[[i]], optional = TRUE)
body:         nrows[i] <- .row_names_info(xi)
body:         ncols[i] <- length(xi)
body:         namesi <- names(xi)
body:         if (ncols[i] > 1L) {
body:             if (length(namesi) == 0L) 
body:                 namesi <- seq_len(ncols[i])
body:             if (no.vn[i]) 
body:                 vnames[[i]] <- namesi
body:             else vnames[[i]] <- paste(vnames[[i]], namesi, sep = ".")
body:         }
body:         else {
body:             if (length(namesi)) 
body:                 vnames[[i]] <- namesi
body:             else if (no.vn[[i]]) {
body:                 tmpname <- deparse(object[[i]])[1L]
body:                 if (substr(tmpname, 1L, 2L) == "I(") {
body:                   ntmpn <- nchar(tmpname, "c")
body:                   if (substr(tmpname, ntmpn, ntmpn) == ")") 
body:                     tmpname <- substr(tmpname, 3L, ntmpn - 1L)
body:                 }
body:                 vnames[[i]] <- tmpname
body:             }
body:         }
body:         if (mirn && nrows[i] > 0L) {
body:             rowsi <- attr(xi, "row.names")
body:             nc <- nchar(rowsi, allowNA = FALSE)
body:             nc <- nc[!is.na(nc)]
body:             if (length(nc) && any(nc)) 
body:                 row.names <- data.row.names(row.names, rowsi, i)
body:         }
body:         nrows[i] <- abs(nrows[i])
body:         vlist[[i]] <- xi
body:     }
body:     nr <- max(nrows)
body:     for (i in seq_len(n)[nrows < nr]) {
body:         xi <- vlist[[i]]
body:         if (nrows[i] > 0L && (nr%%nrows[i] == 0L)) {
body:             xi <- unclass(xi)
body:             fixed <- TRUE
body:             for (j in seq_along(xi)) {
body:                 xi1 <- xi[[j]]
body:                 if (is.vector(xi1) || is.factor(xi1)) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else if (is.character(xi1) && inherits(xi1, "AsIs")) 
body:                   xi[[j]] <- structure(rep(xi1, length.out = nr), class = class(xi1))
body:                 else if (inherits(xi1, "Date") || inherits(xi1, "POSIXct")) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else {
body:                   fixed <- FALSE
body:                   break
body:                 }
body:             }
body:             if (fixed) {
body:                 vlist[[i]] <- xi
body:                 next
body:             }
body:         }
body:         stop(gettextf("arguments imply differing number of rows: %s", paste(unique(nrows), collapse = ", ")), domain = NA)
body:     }
body:     value <- unlist(vlist, recursive = FALSE, use.names = FALSE)
body:     vnames <- unlist(vnames[ncols > 0L])
body:     noname <- !nzchar(vnames)
body:     if (any(noname)) 
body:         vnames[noname] <- paste("Var", seq_along(vnames), sep = ".")[noname]
body:     if (check.names) 
body:         vnames <- make.names(vnames, unique = TRUE)
body:     names(value) <- vnames
body:     if (!mrn) {
body:         if (length(row.names) == 1L && nr != 1L) {
body:             if (is.character(row.names)) 
body:                 row.names <- match(row.names, vnames, 0L)
body:             if (length(row.names) != 1L || row.names < 1L || row.names > length(vnames)) 
body:                 stop("'row.names' should specify one of the variables")
body:             i <- row.names
body:             row.names <- value[[i]]
body:             value <- value[-i]
body:         }
body:         else if (!is.null(row.names) && length(row.names) != nr) 
body:             stop("row names supplied are of the wrong length")
body:     }
body:     else if (!is.null(row.names) && length(row.names) != nr) {
body:         warning("row names were found from a short variable and have been discarded")
body:         row.names <- NULL
body:     }
body:     if (is.null(row.names)) 
body:         row.names <- .set_row_names(nr)
body:     else {
body:         if (is.object(row.names) || !is.integer(row.names)) 
body:             row.names <- as.character(row.names)
body:         if (any(is.na(row.names))) 
body:             stop("row names contain missing values")
body:         if (anyDuplicated(row.names)) 
body:             stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:     }
body:     attr(value, "row.names") <- row.names
body:     attr(value, "class") <- "data.frame"
body:     value
body: }
args: list(X_data = structure("FALSE", class = "AsIs"), check.names = FALSE, row.names = "1")
retn: structure(list(X_data = structure("FALSE", class = "AsIs")), .Names = "X_data", row.names = "1", class = "data.frame")

func: quote(data.frame)
body: function (..., row.names = NULL, check.rows = FALSE, check.names = TRUE, stringsAsFactors = default.stringsAsFactors()) 
body: {
body:     data.row.names <- if (check.rows && is.null(row.names)) 
body:         function(current, new, i) {
body:             if (is.character(current)) 
body:                 new <- as.character(new)
body:             if (is.character(new)) 
body:                 current <- as.character(current)
body:             if (anyDuplicated(new)) 
body:                 return(current)
body:             if (is.null(current)) 
body:                 return(new)
body:             if (all(current == new) || all(current == "")) 
body:                 return(new)
body:             stop(gettextf("mismatch of row names in arguments of 'data.frame', item %d", i), domain = NA)
body:         }
body:     else function(current, new, i) {
body:         if (is.null(current)) {
body:             if (anyDuplicated(new)) {
body:                 warning(gettextf("some row.names duplicated: %s --> row.names NOT used", paste(which(duplicated(new)), collapse = ",")), domain = NA)
body:                 current
body:             }
body:             else new
body:         }
body:         else current
body:     }
body:     object <- as.list(substitute(list(...)))[-1L]
body:     mirn <- missing(row.names)
body:     mrn <- is.null(row.names)
body:     x <- list(...)
body:     n <- length(x)
body:     if (n < 1L) {
body:         if (!mrn) {
body:             if (is.object(row.names) || !is.integer(row.names)) 
body:                 row.names <- as.character(row.names)
body:             if (any(is.na(row.names))) 
body:                 stop("row names contain missing values")
body:             if (anyDuplicated(row.names)) 
body:                 stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:         }
body:         else row.names <- integer()
body:         return(structure(list(), names = character(), row.names = row.names, class = "data.frame"))
body:     }
body:     vnames <- names(x)
body:     if (length(vnames) != n) 
body:         vnames <- character(n)
body:     no.vn <- !nzchar(vnames)
body:     vlist <- vnames <- as.list(vnames)
body:     nrows <- ncols <- integer(n)
body:     for (i in seq_len(n)) {
body:         xi <- if (is.character(x[[i]]) || is.list(x[[i]])) 
body:             as.data.frame(x[[i]], optional = TRUE, stringsAsFactors = stringsAsFactors)
body:         else as.data.frame(x[[i]], optional = TRUE)
body:         nrows[i] <- .row_names_info(xi)
body:         ncols[i] <- length(xi)
body:         namesi <- names(xi)
body:         if (ncols[i] > 1L) {
body:             if (length(namesi) == 0L) 
body:                 namesi <- seq_len(ncols[i])
body:             if (no.vn[i]) 
body:                 vnames[[i]] <- namesi
body:             else vnames[[i]] <- paste(vnames[[i]], namesi, sep = ".")
body:         }
body:         else {
body:             if (length(namesi)) 
body:                 vnames[[i]] <- namesi
body:             else if (no.vn[[i]]) {
body:                 tmpname <- deparse(object[[i]])[1L]
body:                 if (substr(tmpname, 1L, 2L) == "I(") {
body:                   ntmpn <- nchar(tmpname, "c")
body:                   if (substr(tmpname, ntmpn, ntmpn) == ")") 
body:                     tmpname <- substr(tmpname, 3L, ntmpn - 1L)
body:                 }
body:                 vnames[[i]] <- tmpname
body:             }
body:         }
body:         if (mirn && nrows[i] > 0L) {
body:             rowsi <- attr(xi, "row.names")
body:             nc <- nchar(rowsi, allowNA = FALSE)
body:             nc <- nc[!is.na(nc)]
body:             if (length(nc) && any(nc)) 
body:                 row.names <- data.row.names(row.names, rowsi, i)
body:         }
body:         nrows[i] <- abs(nrows[i])
body:         vlist[[i]] <- xi
body:     }
body:     nr <- max(nrows)
body:     for (i in seq_len(n)[nrows < nr]) {
body:         xi <- vlist[[i]]
body:         if (nrows[i] > 0L && (nr%%nrows[i] == 0L)) {
body:             xi <- unclass(xi)
body:             fixed <- TRUE
body:             for (j in seq_along(xi)) {
body:                 xi1 <- xi[[j]]
body:                 if (is.vector(xi1) || is.factor(xi1)) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else if (is.character(xi1) && inherits(xi1, "AsIs")) 
body:                   xi[[j]] <- structure(rep(xi1, length.out = nr), class = class(xi1))
body:                 else if (inherits(xi1, "Date") || inherits(xi1, "POSIXct")) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else {
body:                   fixed <- FALSE
body:                   break
body:                 }
body:             }
body:             if (fixed) {
body:                 vlist[[i]] <- xi
body:                 next
body:             }
body:         }
body:         stop(gettextf("arguments imply differing number of rows: %s", paste(unique(nrows), collapse = ", ")), domain = NA)
body:     }
body:     value <- unlist(vlist, recursive = FALSE, use.names = FALSE)
body:     vnames <- unlist(vnames[ncols > 0L])
body:     noname <- !nzchar(vnames)
body:     if (any(noname)) 
body:         vnames[noname] <- paste("Var", seq_along(vnames), sep = ".")[noname]
body:     if (check.names) 
body:         vnames <- make.names(vnames, unique = TRUE)
body:     names(value) <- vnames
body:     if (!mrn) {
body:         if (length(row.names) == 1L && nr != 1L) {
body:             if (is.character(row.names)) 
body:                 row.names <- match(row.names, vnames, 0L)
body:             if (length(row.names) != 1L || row.names < 1L || row.names > length(vnames)) 
body:                 stop("'row.names' should specify one of the variables")
body:             i <- row.names
body:             row.names <- value[[i]]
body:             value <- value[-i]
body:         }
body:         else if (!is.null(row.names) && length(row.names) != nr) 
body:             stop("row names supplied are of the wrong length")
body:     }
body:     else if (!is.null(row.names) && length(row.names) != nr) {
body:         warning("row names were found from a short variable and have been discarded")
body:         row.names <- NULL
body:     }
body:     if (is.null(row.names)) 
body:         row.names <- .set_row_names(nr)
body:     else {
body:         if (is.object(row.names) || !is.integer(row.names)) 
body:             row.names <- as.character(row.names)
body:         if (any(is.na(row.names))) 
body:             stop("row names contain missing values")
body:         if (anyDuplicated(row.names)) 
body:             stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:     }
body:     attr(value, "row.names") <- row.names
body:     attr(value, "class") <- "data.frame"
body:     value
body: }
args: list(check.names = TRUE, stringsAsFactors = FALSE)
retn: structure(list(), .Names = character(0), row.names = integer(0), class = "data.frame")

func: quote(data.frame)
body: function (..., row.names = NULL, check.rows = FALSE, check.names = TRUE, stringsAsFactors = default.stringsAsFactors()) 
body: {
body:     data.row.names <- if (check.rows && is.null(row.names)) 
body:         function(current, new, i) {
body:             if (is.character(current)) 
body:                 new <- as.character(new)
body:             if (is.character(new)) 
body:                 current <- as.character(current)
body:             if (anyDuplicated(new)) 
body:                 return(current)
body:             if (is.null(current)) 
body:                 return(new)
body:             if (all(current == new) || all(current == "")) 
body:                 return(new)
body:             stop(gettextf("mismatch of row names in arguments of 'data.frame', item %d", i), domain = NA)
body:         }
body:     else function(current, new, i) {
body:         if (is.null(current)) {
body:             if (anyDuplicated(new)) {
body:                 warning(gettextf("some row.names duplicated: %s --> row.names NOT used", paste(which(duplicated(new)), collapse = ",")), domain = NA)
body:                 current
body:             }
body:             else new
body:         }
body:         else current
body:     }
body:     object <- as.list(substitute(list(...)))[-1L]
body:     mirn <- missing(row.names)
body:     mrn <- is.null(row.names)
body:     x <- list(...)
body:     n <- length(x)
body:     if (n < 1L) {
body:         if (!mrn) {
body:             if (is.object(row.names) || !is.integer(row.names)) 
body:                 row.names <- as.character(row.names)
body:             if (any(is.na(row.names))) 
body:                 stop("row names contain missing values")
body:             if (anyDuplicated(row.names)) 
body:                 stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:         }
body:         else row.names <- integer()
body:         return(structure(list(), names = character(), row.names = row.names, class = "data.frame"))
body:     }
body:     vnames <- names(x)
body:     if (length(vnames) != n) 
body:         vnames <- character(n)
body:     no.vn <- !nzchar(vnames)
body:     vlist <- vnames <- as.list(vnames)
body:     nrows <- ncols <- integer(n)
body:     for (i in seq_len(n)) {
body:         xi <- if (is.character(x[[i]]) || is.list(x[[i]])) 
body:             as.data.frame(x[[i]], optional = TRUE, stringsAsFactors = stringsAsFactors)
body:         else as.data.frame(x[[i]], optional = TRUE)
body:         nrows[i] <- .row_names_info(xi)
body:         ncols[i] <- length(xi)
body:         namesi <- names(xi)
body:         if (ncols[i] > 1L) {
body:             if (length(namesi) == 0L) 
body:                 namesi <- seq_len(ncols[i])
body:             if (no.vn[i]) 
body:                 vnames[[i]] <- namesi
body:             else vnames[[i]] <- paste(vnames[[i]], namesi, sep = ".")
body:         }
body:         else {
body:             if (length(namesi)) 
body:                 vnames[[i]] <- namesi
body:             else if (no.vn[[i]]) {
body:                 tmpname <- deparse(object[[i]])[1L]
body:                 if (substr(tmpname, 1L, 2L) == "I(") {
body:                   ntmpn <- nchar(tmpname, "c")
body:                   if (substr(tmpname, ntmpn, ntmpn) == ")") 
body:                     tmpname <- substr(tmpname, 3L, ntmpn - 1L)
body:                 }
body:                 vnames[[i]] <- tmpname
body:             }
body:         }
body:         if (mirn && nrows[i] > 0L) {
body:             rowsi <- attr(xi, "row.names")
body:             nc <- nchar(rowsi, allowNA = FALSE)
body:             nc <- nc[!is.na(nc)]
body:             if (length(nc) && any(nc)) 
body:                 row.names <- data.row.names(row.names, rowsi, i)
body:         }
body:         nrows[i] <- abs(nrows[i])
body:         vlist[[i]] <- xi
body:     }
body:     nr <- max(nrows)
body:     for (i in seq_len(n)[nrows < nr]) {
body:         xi <- vlist[[i]]
body:         if (nrows[i] > 0L && (nr%%nrows[i] == 0L)) {
body:             xi <- unclass(xi)
body:             fixed <- TRUE
body:             for (j in seq_along(xi)) {
body:                 xi1 <- xi[[j]]
body:                 if (is.vector(xi1) || is.factor(xi1)) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else if (is.character(xi1) && inherits(xi1, "AsIs")) 
body:                   xi[[j]] <- structure(rep(xi1, length.out = nr), class = class(xi1))
body:                 else if (inherits(xi1, "Date") || inherits(xi1, "POSIXct")) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else {
body:                   fixed <- FALSE
body:                   break
body:                 }
body:             }
body:             if (fixed) {
body:                 vlist[[i]] <- xi
body:                 next
body:             }
body:         }
body:         stop(gettextf("arguments imply differing number of rows: %s", paste(unique(nrows), collapse = ", ")), domain = NA)
body:     }
body:     value <- unlist(vlist, recursive = FALSE, use.names = FALSE)
body:     vnames <- unlist(vnames[ncols > 0L])
body:     noname <- !nzchar(vnames)
body:     if (any(noname)) 
body:         vnames[noname] <- paste("Var", seq_along(vnames), sep = ".")[noname]
body:     if (check.names) 
body:         vnames <- make.names(vnames, unique = TRUE)
body:     names(value) <- vnames
body:     if (!mrn) {
body:         if (length(row.names) == 1L && nr != 1L) {
body:             if (is.character(row.names)) 
body:                 row.names <- match(row.names, vnames, 0L)
body:             if (length(row.names) != 1L || row.names < 1L || row.names > length(vnames)) 
body:                 stop("'row.names' should specify one of the variables")
body:             i <- row.names
body:             row.names <- value[[i]]
body:             value <- value[-i]
body:         }
body:         else if (!is.null(row.names) && length(row.names) != nr) 
body:             stop("row names supplied are of the wrong length")
body:     }
body:     else if (!is.null(row.names) && length(row.names) != nr) {
body:         warning("row names were found from a short variable and have been discarded")
body:         row.names <- NULL
body:     }
body:     if (is.null(row.names)) 
body:         row.names <- .set_row_names(nr)
body:     else {
body:         if (is.object(row.names) || !is.integer(row.names)) 
body:             row.names <- as.character(row.names)
body:         if (any(is.na(row.names))) 
body:             stop("row names contain missing values")
body:         if (anyDuplicated(row.names)) 
body:             stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:     }
body:     attr(value, "row.names") <- row.names
body:     attr(value, "class") <- "data.frame"
body:     value
body: }
args: list(NULL, NULL, check.names = TRUE, stringsAsFactors = TRUE)
retn: structure(list(), .Names = character(0), row.names = integer(0), class = "data.frame")

func: quote(data.frame)
body: function (..., row.names = NULL, check.rows = FALSE, check.names = TRUE, stringsAsFactors = default.stringsAsFactors()) 
body: {
body:     data.row.names <- if (check.rows && is.null(row.names)) 
body:         function(current, new, i) {
body:             if (is.character(current)) 
body:                 new <- as.character(new)
body:             if (is.character(new)) 
body:                 current <- as.character(current)
body:             if (anyDuplicated(new)) 
body:                 return(current)
body:             if (is.null(current)) 
body:                 return(new)
body:             if (all(current == new) || all(current == "")) 
body:                 return(new)
body:             stop(gettextf("mismatch of row names in arguments of 'data.frame', item %d", i), domain = NA)
body:         }
body:     else function(current, new, i) {
body:         if (is.null(current)) {
body:             if (anyDuplicated(new)) {
body:                 warning(gettextf("some row.names duplicated: %s --> row.names NOT used", paste(which(duplicated(new)), collapse = ",")), domain = NA)
body:                 current
body:             }
body:             else new
body:         }
body:         else current
body:     }
body:     object <- as.list(substitute(list(...)))[-1L]
body:     mirn <- missing(row.names)
body:     mrn <- is.null(row.names)
body:     x <- list(...)
body:     n <- length(x)
body:     if (n < 1L) {
body:         if (!mrn) {
body:             if (is.object(row.names) || !is.integer(row.names)) 
body:                 row.names <- as.character(row.names)
body:             if (any(is.na(row.names))) 
body:                 stop("row names contain missing values")
body:             if (anyDuplicated(row.names)) 
body:                 stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:         }
body:         else row.names <- integer()
body:         return(structure(list(), names = character(), row.names = row.names, class = "data.frame"))
body:     }
body:     vnames <- names(x)
body:     if (length(vnames) != n) 
body:         vnames <- character(n)
body:     no.vn <- !nzchar(vnames)
body:     vlist <- vnames <- as.list(vnames)
body:     nrows <- ncols <- integer(n)
body:     for (i in seq_len(n)) {
body:         xi <- if (is.character(x[[i]]) || is.list(x[[i]])) 
body:             as.data.frame(x[[i]], optional = TRUE, stringsAsFactors = stringsAsFactors)
body:         else as.data.frame(x[[i]], optional = TRUE)
body:         nrows[i] <- .row_names_info(xi)
body:         ncols[i] <- length(xi)
body:         namesi <- names(xi)
body:         if (ncols[i] > 1L) {
body:             if (length(namesi) == 0L) 
body:                 namesi <- seq_len(ncols[i])
body:             if (no.vn[i]) 
body:                 vnames[[i]] <- namesi
body:             else vnames[[i]] <- paste(vnames[[i]], namesi, sep = ".")
body:         }
body:         else {
body:             if (length(namesi)) 
body:                 vnames[[i]] <- namesi
body:             else if (no.vn[[i]]) {
body:                 tmpname <- deparse(object[[i]])[1L]
body:                 if (substr(tmpname, 1L, 2L) == "I(") {
body:                   ntmpn <- nchar(tmpname, "c")
body:                   if (substr(tmpname, ntmpn, ntmpn) == ")") 
body:                     tmpname <- substr(tmpname, 3L, ntmpn - 1L)
body:                 }
body:                 vnames[[i]] <- tmpname
body:             }
body:         }
body:         if (mirn && nrows[i] > 0L) {
body:             rowsi <- attr(xi, "row.names")
body:             nc <- nchar(rowsi, allowNA = FALSE)
body:             nc <- nc[!is.na(nc)]
body:             if (length(nc) && any(nc)) 
body:                 row.names <- data.row.names(row.names, rowsi, i)
body:         }
body:         nrows[i] <- abs(nrows[i])
body:         vlist[[i]] <- xi
body:     }
body:     nr <- max(nrows)
body:     for (i in seq_len(n)[nrows < nr]) {
body:         xi <- vlist[[i]]
body:         if (nrows[i] > 0L && (nr%%nrows[i] == 0L)) {
body:             xi <- unclass(xi)
body:             fixed <- TRUE
body:             for (j in seq_along(xi)) {
body:                 xi1 <- xi[[j]]
body:                 if (is.vector(xi1) || is.factor(xi1)) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else if (is.character(xi1) && inherits(xi1, "AsIs")) 
body:                   xi[[j]] <- structure(rep(xi1, length.out = nr), class = class(xi1))
body:                 else if (inherits(xi1, "Date") || inherits(xi1, "POSIXct")) 
body:                   xi[[j]] <- rep(xi1, length.out = nr)
body:                 else {
body:                   fixed <- FALSE
body:                   break
body:                 }
body:             }
body:             if (fixed) {
body:                 vlist[[i]] <- xi
body:                 next
body:             }
body:         }
body:         stop(gettextf("arguments imply differing number of rows: %s", paste(unique(nrows), collapse = ", ")), domain = NA)
body:     }
body:     value <- unlist(vlist, recursive = FALSE, use.names = FALSE)
body:     vnames <- unlist(vnames[ncols > 0L])
body:     noname <- !nzchar(vnames)
body:     if (any(noname)) 
body:         vnames[noname] <- paste("Var", seq_along(vnames), sep = ".")[noname]
body:     if (check.names) 
body:         vnames <- make.names(vnames, unique = TRUE)
body:     names(value) <- vnames
body:     if (!mrn) {
body:         if (length(row.names) == 1L && nr != 1L) {
body:             if (is.character(row.names)) 
body:                 row.names <- match(row.names, vnames, 0L)
body:             if (length(row.names) != 1L || row.names < 1L || row.names > length(vnames)) 
body:                 stop("'row.names' should specify one of the variables")
body:             i <- row.names
body:             row.names <- value[[i]]
body:             value <- value[-i]
body:         }
body:         else if (!is.null(row.names) && length(row.names) != nr) 
body:             stop("row names supplied are of the wrong length")
body:     }
body:     else if (!is.null(row.names) && length(row.names) != nr) {
body:         warning("row names were found from a short variable and have been discarded")
body:         row.names <- NULL
body:     }
body:     if (is.null(row.names)) 
body:         row.names <- .set_row_names(nr)
body:     else {
body:         if (is.object(row.names) || !is.integer(row.names)) 
body:             row.names <- as.character(row.names)
body:         if (any(is.na(row.names))) 
body:             stop("row names contain missing values")
body:         if (anyDuplicated(row.names)) 
body:             stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), collapse = ", ")), domain = NA)
body:     }
body:     attr(value, "row.names") <- row.names
body:     attr(value, "class") <- "data.frame"
body:     value
body: }
args: list(x = structure("0", class = "AsIs"), y = structure("0", class = "AsIs"), check.names = FALSE, row.names = "1")
retn: structure(list(x = structure("0", class = "AsIs"), y = structure("0", class = "AsIs")), .Names = c("x", "y"), row.names = "1", class = "data.frame")

