func: quote(stopifnot)
body: function (...) 
body: {
body:     n <- length(ll <- list(...))
body:     if (n == 0L) 
body:         return(invisible())
body:     mc <- match.call()
body:     for (i in 1L:n) if (!(is.logical(r <- ll[[i]]) && !any(is.na(r)) && all(r))) {
body:         ch <- deparse(mc[[i + 1]], width.cutoff = 60L)
body:         if (length(ch) > 1L) 
body:             ch <- paste(ch[1L], "....")
body:         stop(sprintf(ngettext(length(r), "%s is not TRUE", "%s are not all TRUE"), ch), call. = FALSE, domain = NA)
body:     }
body:     invisible()
body: }
args: list(TRUE)
retn: NULL

func: quote(stopifnot)
body: function (...) 
body: {
body:     n <- length(ll <- list(...))
body:     if (n == 0L) 
body:         return(invisible())
body:     mc <- match.call()
body:     for (i in 1L:n) if (!(is.logical(r <- ll[[i]]) && !any(is.na(r)) && all(r))) {
body:         ch <- deparse(mc[[i + 1]], width.cutoff = 60L)
body:         if (length(ch) > 1L) 
body:             ch <- paste(ch[1L], "....")
body:         stop(sprintf(ngettext(length(r), "%s is not TRUE", "%s are not all TRUE"), ch), call. = FALSE, domain = NA)
body:     }
body:     invisible()
body: }
args: list(c(TRUE, TRUE), c(TRUE, TRUE))
retn: NULL

func: quote(stopifnot)
body: function (...) 
body: {
body:     n <- length(ll <- list(...))
body:     if (n == 0L) 
body:         return(invisible())
body:     mc <- match.call()
body:     for (i in 1L:n) if (!(is.logical(r <- ll[[i]]) && !any(is.na(r)) && all(r))) {
body:         ch <- deparse(mc[[i + 1]], width.cutoff = 60L)
body:         if (length(ch) > 1L) 
body:             ch <- paste(ch[1L], "....")
body:         stop(sprintf(ngettext(length(r), "%s is not TRUE", "%s are not all TRUE"), ch), call. = FALSE, domain = NA)
body:     }
body:     invisible()
body: }
args: list(structure(c(TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE), .Dim = c(9L, 3L)), structure(c(TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE), .Dim = c(9L, 3L)))
retn: NULL

func: quote(stopifnot)
body: function (...) 
body: {
body:     n <- length(ll <- list(...))
body:     if (n == 0L) 
body:         return(invisible())
body:     mc <- match.call()
body:     for (i in 1L:n) if (!(is.logical(r <- ll[[i]]) && !any(is.na(r)) && all(r))) {
body:         ch <- deparse(mc[[i + 1]], width.cutoff = 60L)
body:         if (length(ch) > 1L) 
body:             ch <- paste(ch[1L], "....")
body:         stop(sprintf(ngettext(length(r), "%s is not TRUE", "%s are not all TRUE"), ch), call. = FALSE, domain = NA)
body:     }
body:     invisible()
body: }
args: list(structure(TRUE, .Dim = c(1L, 1L)))
retn: NULL

func: quote(stopifnot)
body: function (...) 
body: {
body:     n <- length(ll <- list(...))
body:     if (n == 0L) 
body:         return(invisible())
body:     mc <- match.call()
body:     for (i in 1L:n) if (!(is.logical(r <- ll[[i]]) && !any(is.na(r)) && all(r))) {
body:         ch <- deparse(mc[[i + 1]], width.cutoff = 60L)
body:         if (length(ch) > 1L) 
body:             ch <- paste(ch[1L], "....")
body:         stop(sprintf(ngettext(length(r), "%s is not TRUE", "%s are not all TRUE"), ch), call. = FALSE, domain = NA)
body:     }
body:     invisible()
body: }
args: list(TRUE, TRUE, TRUE, TRUE)
retn: NULL

func: quote(stopifnot)
body: function (...) 
body: {
body:     n <- length(ll <- list(...))
body:     if (n == 0L) 
body:         return(invisible())
body:     mc <- match.call()
body:     for (i in 1L:n) if (!(is.logical(r <- ll[[i]]) && !any(is.na(r)) && all(r))) {
body:         ch <- deparse(mc[[i + 1]], width.cutoff = 60L)
body:         if (length(ch) > 1L) 
body:             ch <- paste(ch[1L], "....")
body:         stop(sprintf(ngettext(length(r), "%s is not TRUE", "%s are not all TRUE"), ch), call. = FALSE, domain = NA)
body:     }
body:     invisible()
body: }
args: list(TRUE, perl = TRUE)
retn: NULL

func: quote(stopifnot)
body: function (...) 
body: {
body:     n <- length(ll <- list(...))
body:     if (n == 0L) 
body:         return(invisible())
body:     mc <- match.call()
body:     for (i in 1L:n) if (!(is.logical(r <- ll[[i]]) && !any(is.na(r)) && all(r))) {
body:         ch <- deparse(mc[[i + 1]], width.cutoff = 60L)
body:         if (length(ch) > 1L) 
body:             ch <- paste(ch[1L], "....")
body:         stop(sprintf(ngettext(length(r), "%s is not TRUE", "%s are not all TRUE"), ch), call. = FALSE, domain = NA)
body:     }
body:     invisible()
body: }
args: list(TRUE, useBytes = TRUE)
retn: NULL

func: quote(stopifnot)
body: function (...) 
body: {
body:     n <- length(ll <- list(...))
body:     if (n == 0L) 
body:         return(invisible())
body:     mc <- match.call()
body:     for (i in 1L:n) if (!(is.logical(r <- ll[[i]]) && !any(is.na(r)) && all(r))) {
body:         ch <- deparse(mc[[i + 1]], width.cutoff = 60L)
body:         if (length(ch) > 1L) 
body:             ch <- paste(ch[1L], "....")
body:         stop(sprintf(ngettext(length(r), "%s is not TRUE", "%s are not all TRUE"), ch), call. = FALSE, domain = NA)
body:     }
body:     invisible()
body: }
args: list(TRUE, perl = TRUE, useBytes = TRUE)
retn: NULL

func: quote(stopifnot)
body: function (...) 
body: {
body:     n <- length(ll <- list(...))
body:     if (n == 0L) 
body:         return(invisible())
body:     mc <- match.call()
body:     for (i in 1L:n) if (!(is.logical(r <- ll[[i]]) && !any(is.na(r)) && all(r))) {
body:         ch <- deparse(mc[[i + 1]], width.cutoff = 60L)
body:         if (length(ch) > 1L) 
body:             ch <- paste(ch[1L], "....")
body:         stop(sprintf(ngettext(length(r), "%s is not TRUE", "%s are not all TRUE"), ch), call. = FALSE, domain = NA)
body:     }
body:     invisible()
body: }
args: list(c(TRUE, TRUE, TRUE, TRUE))
retn: NULL

func: quote(stopifnot)
body: function (...) 
body: {
body:     n <- length(ll <- list(...))
body:     if (n == 0L) 
body:         return(invisible())
body:     mc <- match.call()
body:     for (i in 1L:n) if (!(is.logical(r <- ll[[i]]) && !any(is.na(r)) && all(r))) {
body:         ch <- deparse(mc[[i + 1]], width.cutoff = 60L)
body:         if (length(ch) > 1L) 
body:             ch <- paste(ch[1L], "....")
body:         stop(sprintf(ngettext(length(r), "%s is not TRUE", "%s are not all TRUE"), ch), call. = FALSE, domain = NA)
body:     }
body:     invisible()
body: }
args: list(c(TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE))
retn: NULL

